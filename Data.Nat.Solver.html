<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>Data.Nat.Solver - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Data.Nat.Solver - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="Data.Nat.Solver - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script defer src="/main.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

  <!-- Google font embeds -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&amp;family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">Data.Nat.Solver</a>
              </h3>

      <!-- Cube logo -->
      <a id="logo" href="/">
        <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />
      </a>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#the-nat-solver"><a href="#the-nat-solver" class="header-link">The Nat Solver<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#horner-normal-forms"><a href="#horner-normal-forms" class="header-link">Horner Normal Forms<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#operations-on-horner-normal-forms"><a href="#operations-on-horner-normal-forms" class="header-link">Operations on Horner Normal Forms<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#evaluation-of-horner-normal-forms"><a href="#evaluation-of-horner-normal-forms" class="header-link">Evaluation of Horner Normal Forms<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#soundness-of-the-operations"><a href="#soundness-of-the-operations" class="header-link">Soundness of the Operations<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#evaluation-into-polynomials"><a href="#evaluation-into-polynomials" class="header-link">Evaluation into Polynomials<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#soundness-of-evaluation"><a href="#soundness-of-evaluation" class="header-link">Soundness of Evaluation<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#reflection"><a href="#reflection" class="header-link">Reflection<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#the-actual-macros"><a href="#the-actual-macros" class="header-link">The Actual Macros<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      </ul></li>
      <li><a href="#examples"><a href="#examples" class="header-link">Examples<span class="header-link-emoji">🔗</span></a></a></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>

        <!-- Sidebar footnotes control -->
        <span class="inline-footnotes" style="display: none; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-fns" type="checkbox" class="inline-footnotes" id="sidebar-fns">
          <label for="sidebar-fns">Inline Footnotes</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
        <div class="search-form search-form-proxy" role="form">
          <input id="search-box-proxy" type_="text" placeholder="Search..." autocomplete="off" tabindex="0"></input>
        </div>

              <a href="/">back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/575d61d1507dac26d7e1963c13f6ad68d2e1640c/src/Data/Nat/Solver.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Reed Mullanix</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="/">back to index</a>
      </div>
      
      <!-- Navbar equations control -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>

      <!-- Navbar footnotes control -->
      <span class="inline-footnotes" style="display: none; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-fns" type="checkbox" class="inline-footnotes" id="navbar-fns">
        <label for="navbar-fns">Inline Footnotes</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">module</a> <a id="16" href="Data.Nat.Solver.html" class="Module">Data.Nat.Solver</a> <a id="32" class="Keyword">where</a>

<a id="39" class="Keyword">open</a> <a id="44" class="Keyword">import</a> <a id="51" href="1Lab.Type.html" class="Module">1Lab.Type</a>
<a id="61" class="Keyword">open</a> <a id="66" class="Keyword">import</a> <a id="73" href="1Lab.Path.html" class="Module">1Lab.Path</a>
<a id="83" class="Keyword">open</a> <a id="88" class="Keyword">import</a> <a id="95" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a>
<a id="109" class="Keyword">open</a> <a id="114" class="Keyword">import</a> <a id="121" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a>
<a id="141" class="Keyword">open</a> <a id="146" class="Keyword">import</a> <a id="153" href="Data.Fin.Base.html" class="Module">Data.Fin.Base</a>
<a id="167" class="Keyword">open</a> <a id="172" class="Keyword">import</a> <a id="179" href="Data.Bool.html" class="Module">Data.Bool</a>

<a id="190" class="Keyword">open</a> <a id="195" class="Keyword">import</a> <a id="202" href="1Lab.Reflection.html" class="Module">1Lab.Reflection</a>
<a id="218" class="Keyword">open</a> <a id="223" class="Keyword">import</a> <a id="230" href="1Lab.Reflection.Variables.html" class="Module">1Lab.Reflection.Variables</a>
</pre>
<h1 id="the-nat-solver"><a href="#the-nat-solver" class="header-link">The Nat Solver<span class="header-link-emoji">🔗</span></a></h1>
<p>This module defines a solver for equations in commutative semiring of natural numbers. This module can be split up into 3 clean parts: - Horner normal forms for polynomials - Evaluation of reflected terms into polynomials - The reflection interface</p>
<h2 id="horner-normal-forms"><a href="#horner-normal-forms" class="header-link">Horner Normal Forms<span class="header-link-emoji">🔗</span></a></h2>
<p>If we ignore the <span class="Agda"><a href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a></span> and <span class="Agda"><a href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a></span> constructors and their respective equations, the core problem at hand is trying to compute normal forms for polynomials. Luckily, like most problems involving polynomials, this has been thoroughly studied! There are many possible normal forms to choose from, but the most useful for our task is <em>Horner Normal Form</em>, as it admits a particularly nice inductive characterization.</p>
<p>The core idea is that we can rewrite a (univariate) polynomial of the form <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mi>x</mi><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msub><mi>a</mi><mn>3</mn></msub><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>a</mi><mi>n</mi></msub><msup><mi>x</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex"> a_0 + a_1 x + a_2 x^2 + a_3 x^3 + \cdots + a_n x^n </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0141em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0141em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8644em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span> into the following form: <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><mi>x</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>+</mo><mi>x</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mn>2</mn></msub><mo>+</mo><mi>x</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mn>3</mn></msub><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>x</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>x</mi><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> a_0 + x ( a_1 + x ( a_2 + x ( a_3 + \cdots + x ( a_{n-1} + x a_n ) ) ) ) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">))))</span></span></span></span></span></p>
<p>However, we need /multivariate/ polynomials, not just univariate! To do this, we can exploit the isomorphism between <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><msub><mi>X</mi><mn>0</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>X</mi><mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A[X_0, \cdots, X_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> and <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><msub><mi>X</mi><mn>0</mn></msub><mo stretchy="false">]</mo><mo stretchy="false">[</mo><msub><mi>X</mi><mn>1</mn></msub><mo stretchy="false">]</mo><mo>⋯</mo><mo stretchy="false">[</mo><msub><mi>X</mi><mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A[X_0][X_1]\cdots[X_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>.</span> This allows us to define the normal form of a multivariate polynomial as (essentially) a product of univariate ones.</p>
We start by defining the type of n-ary multivariate polynomials.
<pre class="Agda"><a id="1578" class="Keyword">data</a> <a id="Poly"></a><a id="1583" href="Data.Nat.Solver.html#1583" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="1588" class="Symbol">{</a><a id="1589" href="Data.Nat.Solver.html#1589" class="Bound">a</a><a id="1590" class="Symbol">}</a> <a id="1592" class="Symbol">(</a><a id="1593" href="Data.Nat.Solver.html#1593" class="Bound">A</a> <a id="1595" class="Symbol">:</a> <a id="1597" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1602" href="Data.Nat.Solver.html#1589" class="Bound">a</a><a id="1603" class="Symbol">)</a> <a id="1605" class="Symbol">:</a> <a id="1607" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="1611" class="Symbol">→</a> <a id="1613" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1618" href="Data.Nat.Solver.html#1589" class="Bound">a</a> <a id="1620" class="Keyword">where</a>
</pre>
The first polynomial we define is the constant polynomial <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">[</mo><msub><mi>X</mi><mn>0</mn></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">c \in A[X_0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>.</span>
<pre class="Agda">  <a id="Poly.const"></a><a id="1714" href="Data.Nat.Solver.html#1714" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="1720" class="Symbol">:</a> <a id="1722" class="Symbol">(</a><a id="1723" href="Data.Nat.Solver.html#1723" class="Bound">c</a> <a id="1725" class="Symbol">:</a> <a id="1727" href="Data.Nat.Solver.html#1593" class="Bound">A</a><a id="1728" class="Symbol">)</a> <a id="1730" class="Symbol">→</a> <a id="1732" href="Data.Nat.Solver.html#1583" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="1737" href="Data.Nat.Solver.html#1593" class="Bound">A</a> <a id="1739" class="Number">0</a>
</pre>
Next, we define the 0 polynomial <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∈</mo><mi>A</mi><mo stretchy="false">[</mo><msub><mi>X</mi><mn>0</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>X</mi><mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">0 \in A[X_0, \cdots, X_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>.</span> Note that we do /not/ include <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><msub><mi>X</mi><mn>0</mn></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A[X_0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> here! This is important for ensuring that our datatype defines a (somewhat) /unique/ normal form. If we had instead chosen <code>Poly A (suc n)</code>, we could represent the 0 polynomial by both <code>const 0</code> and <code>zerop</code>, which complicates matters somewhat.
<pre class="Agda">  <a id="Poly.zerop"></a><a id="2100" href="Data.Nat.Solver.html#2100" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a>  <a id="2107" class="Symbol">:</a> <a id="2109" class="Symbol">∀</a> <a id="2111" class="Symbol">{</a><a id="2112" href="Data.Nat.Solver.html#2112" class="Bound">n</a><a id="2113" class="Symbol">}</a> <a id="2115" class="Symbol">→</a> <a id="2117" href="Data.Nat.Solver.html#1583" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="2122" href="Data.Nat.Solver.html#1593" class="Bound">A</a> <a id="2124" class="Symbol">(</a><a id="2125" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="2129" href="Data.Nat.Solver.html#2112" class="Bound">n</a><a id="2130" class="Symbol">)</a>
</pre>
<p>Finally, we define both addition, multiplication by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">X_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> in one fell swoop. This constructor represents the polynomial <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>∗</mo><msub><mi>X</mi><mn>0</mn></msub><mo>+</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p * X_0 + q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6597em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>,</span> where <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">[</mo><msub><mi>X</mi><mn>0</mn></msub><mo stretchy="false">]</mo><mo>⋯</mo><mo stretchy="false">[</mo><msub><mi>X</mi><mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">p \in A[X_0]\cdots[X_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>,</span> and <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">[</mo><msub><mi>X</mi><mn>1</mn></msub><mo stretchy="false">]</mo><mo>⋯</mo><mo stretchy="false">[</mo><msub><mi>X</mi><mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">q \in A[X_1]\cdots[X_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>.</span></p>
This flipping of the index may seem confusing at first, but it serves an important purpose: it makes evaluation /really/ easy! When evaluating, we will need some environment <code>Vec A n</code> to be able to provide values for the various <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span> When encountering this case, the index will ensure that we have a <code>_∷_</code> constructor, at which point we can use the tail of the vector to evaluate <code>q</code>! In this sense, not only does this constructor handle additiona and multiplication by <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">X_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,</span> it <em>also</em> handles weakening.
<pre class="Agda">  <a id="Poly._*X+_"></a><a id="2854" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">_*X+_</a> <a id="2860" class="Symbol">:</a> <a id="2862" class="Symbol">∀</a> <a id="2864" class="Symbol">{</a><a id="2865" href="Data.Nat.Solver.html#2865" class="Bound">n</a><a id="2866" class="Symbol">}</a> <a id="2868" class="Symbol">→</a> <a id="2870" class="Symbol">(</a><a id="2871" href="Data.Nat.Solver.html#2871" class="Bound">p</a> <a id="2873" class="Symbol">:</a> <a id="2875" href="Data.Nat.Solver.html#1583" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="2880" href="Data.Nat.Solver.html#1593" class="Bound">A</a> <a id="2882" class="Symbol">(</a><a id="2883" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="2887" href="Data.Nat.Solver.html#2865" class="Bound">n</a><a id="2888" class="Symbol">))</a> <a id="2891" class="Symbol">→</a> <a id="2893" class="Symbol">(</a><a id="2894" href="Data.Nat.Solver.html#2894" class="Bound">q</a> <a id="2896" class="Symbol">:</a> <a id="2898" href="Data.Nat.Solver.html#1583" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="2903" href="Data.Nat.Solver.html#1593" class="Bound">A</a> <a id="2905" href="Data.Nat.Solver.html#2865" class="Bound">n</a><a id="2906" class="Symbol">)</a> <a id="2908" class="Symbol">→</a> <a id="2910" href="Data.Nat.Solver.html#1583" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="2915" href="Data.Nat.Solver.html#1593" class="Bound">A</a> <a id="2917" class="Symbol">(</a><a id="2918" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="2922" href="Data.Nat.Solver.html#2865" class="Bound">n</a><a id="2923" class="Symbol">)</a> 
</pre>
<!--
<pre class="Agda"><a id="2940" class="Keyword">infixl</a> <a id="2947" class="Number">2</a> <a id="2949" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">_*X+_</a>

<a id="2956" class="Keyword">private</a> <a id="2964" class="Keyword">variable</a>
  <a id="2975" href="Data.Nat.Solver.html#2975" class="Generalizable">a</a> <a id="2977" class="Symbol">:</a> <a id="2979" href="Agda.Primitive.html#597" data-type="Type" class="Postulate">Level</a>
  <a id="2987" href="Data.Nat.Solver.html#2987" class="Generalizable">A</a> <a id="2989" class="Symbol">:</a> <a id="2991" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2996" href="Data.Nat.Solver.html#2975" class="Generalizable">a</a>
  <a id="3000" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a> <a id="3002" class="Symbol">:</a> <a id="3004" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a>

<a id="lookup"></a><a id="3009" href="Data.Nat.Solver.html#3009" data-type="Vec A n → Fin n → A" class="Function">lookup</a> <a id="3016" class="Symbol">:</a> <a id="3018" href="1Lab.Reflection.html#1791" data-type="Type ℓ → Nat → Type ℓ" class="Datatype">Vec</a> <a id="3022" href="Data.Nat.Solver.html#2987" class="Generalizable">A</a> <a id="3024" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a> <a id="3026" class="Symbol">→</a> <a id="3028" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="3032" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a> <a id="3034" class="Symbol">→</a> <a id="3036" href="Data.Nat.Solver.html#2987" class="Generalizable">A</a>
<a id="3038" href="Data.Nat.Solver.html#3009" data-type="Vec A n → Fin n → A" class="Function">lookup</a> <a id="3045" class="Symbol">(</a><a id="3046" href="Data.Nat.Solver.html#3046" class="Bound">x</a> <a id="3048" href="1Lab.Reflection.html#1853" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="3050" href="Data.Nat.Solver.html#3050" class="Bound">xs</a><a id="3052" class="Symbol">)</a> <a id="3054" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="3060" class="Symbol">=</a> <a id="3062" href="Data.Nat.Solver.html#3046" class="Bound">x</a>
<a id="3064" href="Data.Nat.Solver.html#3009" data-type="Vec A n → Fin n → A" class="Function">lookup</a> <a id="3071" class="Symbol">(</a><a id="3072" href="Data.Nat.Solver.html#3072" class="Bound">x</a> <a id="3074" href="1Lab.Reflection.html#1853" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="3076" href="Data.Nat.Solver.html#3076" class="Bound">xs</a><a id="3078" class="Symbol">)</a> <a id="3080" class="Symbol">(</a><a id="3081" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="3086" href="Data.Nat.Solver.html#3086" class="Bound">i</a><a id="3087" class="Symbol">)</a> <a id="3089" class="Symbol">=</a> <a id="3091" href="Data.Nat.Solver.html#3009" data-type="Vec A n → Fin n → A" class="Function">lookup</a> <a id="3098" href="Data.Nat.Solver.html#3076" class="Bound">xs</a> <a id="3101" href="Data.Nat.Solver.html#3086" class="Bound">i</a>

<a id="3104" class="Comment">-- NOTE: These little helper lemmas become very useful, and make</a>
<a id="3169" class="Comment">-- some of the really involved proofs a lot less painful.</a>
<a id="commute-inner"></a><a id="3227" href="Data.Nat.Solver.html#3227" data-type="(w x y z : Nat) → w + x + (y + z) ≡ w + y + (x + z)" class="Function">commute-inner</a> <a id="3241" class="Symbol">:</a> <a id="3243" class="Symbol">∀</a> <a id="3245" href="Data.Nat.Solver.html#3245" class="Bound">w</a> <a id="3247" href="Data.Nat.Solver.html#3247" class="Bound">x</a> <a id="3249" href="Data.Nat.Solver.html#3249" class="Bound">y</a> <a id="3251" href="Data.Nat.Solver.html#3251" class="Bound">z</a> <a id="3253" class="Symbol">→</a> <a id="3255" class="Symbol">(</a><a id="3256" href="Data.Nat.Solver.html#3245" class="Bound">w</a> <a id="3258" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3260" href="Data.Nat.Solver.html#3247" class="Bound">x</a><a id="3261" class="Symbol">)</a> <a id="3263" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3265" class="Symbol">(</a><a id="3266" href="Data.Nat.Solver.html#3249" class="Bound">y</a> <a id="3268" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3270" href="Data.Nat.Solver.html#3251" class="Bound">z</a><a id="3271" class="Symbol">)</a> <a id="3273" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3275" class="Symbol">(</a><a id="3276" href="Data.Nat.Solver.html#3245" class="Bound">w</a> <a id="3278" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3280" href="Data.Nat.Solver.html#3249" class="Bound">y</a><a id="3281" class="Symbol">)</a> <a id="3283" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3285" class="Symbol">(</a><a id="3286" href="Data.Nat.Solver.html#3247" class="Bound">x</a> <a id="3288" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3290" href="Data.Nat.Solver.html#3251" class="Bound">z</a><a id="3291" class="Symbol">)</a>
<a id="3293" href="Data.Nat.Solver.html#3227" data-type="(w x y z : Nat) → w + x + (y + z) ≡ w + y + (x + z)" class="Function">commute-inner</a> <a id="3307" href="Data.Nat.Solver.html#3307" class="Bound">w</a> <a id="3309" href="Data.Nat.Solver.html#3309" class="Bound">x</a> <a id="3311" href="Data.Nat.Solver.html#3311" class="Bound">y</a> <a id="3313" href="Data.Nat.Solver.html#3313" class="Bound">z</a> <a id="3315" class="Symbol">=</a>
  <a id="3319" class="Symbol">(</a><a id="3320" href="Data.Nat.Solver.html#3307" class="Bound">w</a> <a id="3322" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3324" href="Data.Nat.Solver.html#3309" class="Bound">x</a><a id="3325" class="Symbol">)</a> <a id="3327" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3329" class="Symbol">(</a><a id="3330" href="Data.Nat.Solver.html#3311" class="Bound">y</a> <a id="3332" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3334" href="Data.Nat.Solver.html#3313" class="Bound">z</a><a id="3335" class="Symbol">)</a> <a id="3337" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3340" href="Data.Nat.Properties.html#553" data-type="(x y z : Nat) → x + y + z ≡ x + (y + z)" class="Function">+-associative</a> <a id="3354" href="Data.Nat.Solver.html#3307" class="Bound">w</a> <a id="3356" href="Data.Nat.Solver.html#3309" class="Bound">x</a> <a id="3358" class="Symbol">(</a><a id="3359" href="Data.Nat.Solver.html#3311" class="Bound">y</a> <a id="3361" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3363" href="Data.Nat.Solver.html#3313" class="Bound">z</a><a id="3364" class="Symbol">)</a> <a id="3366" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="3370" href="Data.Nat.Solver.html#3307" class="Bound">w</a> <a id="3372" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3374" class="Symbol">(</a><a id="3375" href="Data.Nat.Solver.html#3309" class="Bound">x</a> <a id="3377" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3379" class="Symbol">(</a><a id="3380" href="Data.Nat.Solver.html#3311" class="Bound">y</a> <a id="3382" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3384" href="Data.Nat.Solver.html#3313" class="Bound">z</a><a id="3385" class="Symbol">))</a> <a id="3388" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="3392" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="3395" class="Symbol">(</a><a id="3396" href="Data.Nat.Solver.html#3307" class="Bound">w</a> <a id="3398" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+_</a><a id="3400" class="Symbol">)</a> <a id="3402" class="Symbol">(</a><a id="3403" href="Data.Nat.Properties.html#553" data-type="(x y z : Nat) → x + y + z ≡ x + (y + z)" class="Function">+-associative</a> <a id="3417" href="Data.Nat.Solver.html#3309" class="Bound">x</a> <a id="3419" href="Data.Nat.Solver.html#3311" class="Bound">y</a> <a id="3421" href="Data.Nat.Solver.html#3313" class="Bound">z</a><a id="3422" class="Symbol">)</a> <a id="3424" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
  <a id="3428" href="Data.Nat.Solver.html#3307" class="Bound">w</a> <a id="3430" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3432" class="Symbol">((</a><a id="3434" href="Data.Nat.Solver.html#3309" class="Bound">x</a> <a id="3436" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3438" href="Data.Nat.Solver.html#3311" class="Bound">y</a><a id="3439" class="Symbol">)</a> <a id="3441" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3443" href="Data.Nat.Solver.html#3313" class="Bound">z</a><a id="3444" class="Symbol">)</a> <a id="3446" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3449" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="3452" class="Symbol">(λ</a> <a id="3455" href="Data.Nat.Solver.html#3455" class="Bound">ϕ</a> <a id="3457" class="Symbol">→</a> <a id="3459" href="Data.Nat.Solver.html#3307" class="Bound">w</a> <a id="3461" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3463" class="Symbol">(</a><a id="3464" href="Data.Nat.Solver.html#3455" class="Bound">ϕ</a> <a id="3466" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3468" href="Data.Nat.Solver.html#3313" class="Bound">z</a><a id="3469" class="Symbol">))</a> <a id="3472" class="Symbol">(</a><a id="3473" href="Data.Nat.Properties.html#979" data-type="(x y : Nat) → x + y ≡ y + x" class="Function">+-commutative</a> <a id="3487" href="Data.Nat.Solver.html#3309" class="Bound">x</a> <a id="3489" href="Data.Nat.Solver.html#3311" class="Bound">y</a><a id="3490" class="Symbol">)</a> <a id="3492" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="3496" href="Data.Nat.Solver.html#3307" class="Bound">w</a> <a id="3498" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3500" class="Symbol">(</a><a id="3501" href="Data.Nat.Solver.html#3311" class="Bound">y</a> <a id="3503" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3505" href="Data.Nat.Solver.html#3309" class="Bound">x</a> <a id="3507" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3509" href="Data.Nat.Solver.html#3313" class="Bound">z</a><a id="3510" class="Symbol">)</a>   <a id="3514" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3517" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="3520" class="Symbol">(</a><a id="3521" href="Data.Nat.Solver.html#3307" class="Bound">w</a> <a id="3523" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+_</a><a id="3525" class="Symbol">)</a> <a id="3527" class="Symbol">(</a><a id="3528" href="Data.Nat.Properties.html#553" data-type="(x y z : Nat) → x + y + z ≡ x + (y + z)" class="Function">+-associative</a> <a id="3542" href="Data.Nat.Solver.html#3311" class="Bound">y</a> <a id="3544" href="Data.Nat.Solver.html#3309" class="Bound">x</a> <a id="3546" href="Data.Nat.Solver.html#3313" class="Bound">z</a><a id="3547" class="Symbol">)</a> <a id="3549" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="3553" href="Data.Nat.Solver.html#3307" class="Bound">w</a> <a id="3555" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3557" class="Symbol">(</a><a id="3558" href="Data.Nat.Solver.html#3311" class="Bound">y</a> <a id="3560" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3562" class="Symbol">(</a><a id="3563" href="Data.Nat.Solver.html#3309" class="Bound">x</a> <a id="3565" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3567" href="Data.Nat.Solver.html#3313" class="Bound">z</a><a id="3568" class="Symbol">))</a> <a id="3571" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a>  <a id="3576" href="Data.Nat.Properties.html#553" data-type="(x y z : Nat) → x + y + z ≡ x + (y + z)" class="Function">+-associative</a> <a id="3590" href="Data.Nat.Solver.html#3307" class="Bound">w</a> <a id="3592" href="Data.Nat.Solver.html#3311" class="Bound">y</a> <a id="3594" class="Symbol">(</a><a id="3595" href="Data.Nat.Solver.html#3309" class="Bound">x</a> <a id="3597" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3599" href="Data.Nat.Solver.html#3313" class="Bound">z</a><a id="3600" class="Symbol">)</a> <a id="3602" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
  <a id="3606" class="Symbol">(</a><a id="3607" href="Data.Nat.Solver.html#3307" class="Bound">w</a> <a id="3609" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3611" href="Data.Nat.Solver.html#3311" class="Bound">y</a><a id="3612" class="Symbol">)</a> <a id="3614" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3616" class="Symbol">(</a><a id="3617" href="Data.Nat.Solver.html#3309" class="Bound">x</a> <a id="3619" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3621" href="Data.Nat.Solver.html#3313" class="Bound">z</a><a id="3622" class="Symbol">)</a> <a id="3624" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

<a id="commute-last"></a><a id="3627" href="Data.Nat.Solver.html#3627" data-type="(x y z : Nat) → x * y * z ≡ x * z * y" class="Function">commute-last</a> <a id="3640" class="Symbol">:</a> <a id="3642" class="Symbol">∀</a> <a id="3644" href="Data.Nat.Solver.html#3644" class="Bound">x</a> <a id="3646" href="Data.Nat.Solver.html#3646" class="Bound">y</a> <a id="3648" href="Data.Nat.Solver.html#3648" class="Bound">z</a> <a id="3650" class="Symbol">→</a> <a id="3652" class="Symbol">(</a><a id="3653" href="Data.Nat.Solver.html#3644" class="Bound">x</a> <a id="3655" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="3657" href="Data.Nat.Solver.html#3646" class="Bound">y</a><a id="3658" class="Symbol">)</a> <a id="3660" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="3662" href="Data.Nat.Solver.html#3648" class="Bound">z</a> <a id="3664" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3666" class="Symbol">(</a><a id="3667" href="Data.Nat.Solver.html#3644" class="Bound">x</a> <a id="3669" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="3671" href="Data.Nat.Solver.html#3648" class="Bound">z</a><a id="3672" class="Symbol">)</a> <a id="3674" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="3676" href="Data.Nat.Solver.html#3646" class="Bound">y</a>
<a id="3678" href="Data.Nat.Solver.html#3627" data-type="(x y z : Nat) → x * y * z ≡ x * z * y" class="Function">commute-last</a> <a id="3691" href="Data.Nat.Solver.html#3691" class="Bound">x</a> <a id="3693" href="Data.Nat.Solver.html#3693" class="Bound">y</a> <a id="3695" href="Data.Nat.Solver.html#3695" class="Bound">z</a> <a id="3697" class="Symbol">=</a>
  <a id="3701" href="Data.Nat.Solver.html#3691" class="Bound">x</a> <a id="3703" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="3705" href="Data.Nat.Solver.html#3693" class="Bound">y</a> <a id="3707" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="3709" href="Data.Nat.Solver.html#3695" class="Bound">z</a>   <a id="3713" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3716" href="Data.Nat.Properties.html#2667" data-type="(x y z : Nat) → x * y * z ≡ x * (y * z)" class="Function">*-associative</a> <a id="3730" href="Data.Nat.Solver.html#3691" class="Bound">x</a> <a id="3732" href="Data.Nat.Solver.html#3693" class="Bound">y</a> <a id="3734" href="Data.Nat.Solver.html#3695" class="Bound">z</a> <a id="3736" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="3740" href="Data.Nat.Solver.html#3691" class="Bound">x</a> <a id="3742" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="3744" class="Symbol">(</a><a id="3745" href="Data.Nat.Solver.html#3693" class="Bound">y</a> <a id="3747" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="3749" href="Data.Nat.Solver.html#3695" class="Bound">z</a><a id="3750" class="Symbol">)</a> <a id="3752" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3755" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="3758" class="Symbol">(</a><a id="3759" href="Data.Nat.Solver.html#3691" class="Bound">x</a> <a id="3761" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*_</a><a id="3763" class="Symbol">)</a> <a id="3765" class="Symbol">(</a><a id="3766" href="Data.Nat.Properties.html#2203" data-type="(x y : Nat) → x * y ≡ y * x" class="Function">*-commutative</a> <a id="3780" href="Data.Nat.Solver.html#3693" class="Bound">y</a> <a id="3782" href="Data.Nat.Solver.html#3695" class="Bound">z</a><a id="3783" class="Symbol">)</a> <a id="3785" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="3789" href="Data.Nat.Solver.html#3691" class="Bound">x</a> <a id="3791" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="3793" class="Symbol">(</a><a id="3794" href="Data.Nat.Solver.html#3695" class="Bound">z</a> <a id="3796" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="3798" href="Data.Nat.Solver.html#3693" class="Bound">y</a><a id="3799" class="Symbol">)</a> <a id="3801" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="3805" href="Data.Nat.Properties.html#2667" data-type="(x y z : Nat) → x * y * z ≡ x * (y * z)" class="Function">*-associative</a> <a id="3819" href="Data.Nat.Solver.html#3691" class="Bound">x</a> <a id="3821" href="Data.Nat.Solver.html#3695" class="Bound">z</a> <a id="3823" href="Data.Nat.Solver.html#3693" class="Bound">y</a> <a id="3825" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
  <a id="3829" href="Data.Nat.Solver.html#3691" class="Bound">x</a> <a id="3831" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="3833" href="Data.Nat.Solver.html#3695" class="Bound">z</a> <a id="3835" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="3837" href="Data.Nat.Solver.html#3693" class="Bound">y</a> <a id="3839" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
</pre>-->
<p>Note that this representation, while convienent, does pose some problems. We pay for the (relative) uniqueness by having larger terms: For instance, the polynomial <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>X</mi><mn>4</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">X^4 + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> is represented as so:</p>
<pre class="Agda"><a id="4055" class="Keyword">private</a>
  <a id="x⁴+1"></a><a id="4065" href="Data.Nat.Solver.html#4065" class="Function">x⁴+1</a> <a id="4070" class="Symbol">:</a> <a id="4072" href="Data.Nat.Solver.html#1583" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="4077" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="4081" class="Number">1</a>
  <a id="4085" href="Data.Nat.Solver.html#4065" class="Function">x⁴+1</a> <a id="4090" class="Symbol">=</a> <a id="4092" href="Data.Nat.Solver.html#2100" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a> <a id="4098" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="4102" class="Symbol">(</a><a id="4103" href="Data.Nat.Solver.html#1714" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="4109" class="Number">1</a><a id="4110" class="Symbol">)</a> <a id="4112" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="4116" href="Data.Nat.Solver.html#1714" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="4122" class="Number">0</a> <a id="4124" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="4128" class="Symbol">(</a><a id="4129" href="Data.Nat.Solver.html#1714" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="4135" class="Number">0</a><a id="4136" class="Symbol">)</a> <a id="4138" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="4142" class="Symbol">(</a><a id="4143" href="Data.Nat.Solver.html#1714" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="4149" class="Number">0</a><a id="4150" class="Symbol">)</a> <a id="4152" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="4156" class="Symbol">(</a><a id="4157" href="Data.Nat.Solver.html#1714" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="4163" class="Number">0</a><a id="4164" class="Symbol">)</a>
</pre>
<p>This could be alieviated by using a <em>sparse</em> representation, but this is decidedly more difficult. As the Nat Solver is not expected to deal with polynomials with large degrees, this term blow up is not anticipated to be a problem in practice.</p>
<h3 id="operations-on-horner-normal-forms"><a href="#operations-on-horner-normal-forms" class="header-link">Operations on Horner Normal Forms<span class="header-link-emoji">🔗</span></a></h3>
<p>Now, let’s define a handful of functions for constructing and combining polynomials. The naming here can get a bit confusion, so let’s stick with the convention of adding a subscript ‘p’ to denote an operation on polynomials. As a further note, all of the following section could be generalized to an arbitrary semiring, but this would complicate the dependency graph somewhat, so we stick to natural numbers.</p>
<p>As previously mentioned, we have different representations of the 0 polynomial depending on if we are working with <code>Poly A zero</code> or <code>Poly A (suc n)</code>. This is somewhat annoying, so we define a small helper for picking the correct representation.</p>
<pre class="Agda"><a id="0ₚ"></a><a id="5120" href="Data.Nat.Solver.html#5120" data-type="Poly Nat n" class="Function">0ₚ</a> <a id="5123" class="Symbol">:</a> <a id="5125" href="Data.Nat.Solver.html#1583" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="5130" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="5134" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a>
<a id="5136" href="Data.Nat.Solver.html#5120" data-type="Poly Nat n" class="Function">0ₚ</a> <a id="5139" class="Symbol">{</a><a id="5140" class="Argument">n</a> <a id="5142" class="Symbol">=</a> <a id="5144" href="Agda.Builtin.Nat.html#210" data-type="Nat" class="InductiveConstructor">zero</a><a id="5148" class="Symbol">}</a> <a id="5150" class="Symbol">=</a> <a id="5152" href="Data.Nat.Solver.html#1714" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="5158" href="Agda.Builtin.Nat.html#210" data-type="Nat" class="InductiveConstructor">zero</a>
<a id="5163" href="Data.Nat.Solver.html#5120" data-type="Poly Nat n" class="Function">0ₚ</a> <a id="5166" class="Symbol">{</a><a id="5167" class="Argument">n</a> <a id="5169" class="Symbol">=</a> <a id="5171" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="5175" href="Data.Nat.Solver.html#5175" class="Bound">n</a><a id="5176" class="Symbol">}</a> <a id="5178" class="Symbol">=</a> <a id="5180" href="Data.Nat.Solver.html#2100" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a>
</pre>
<p>While we are at it, we also define the polynomial that represents the constant polynomial <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">[</mo><msub><mi>X</mi><mn>0</mn></msub><mo stretchy="false">]</mo><mo>⋯</mo><mo stretchy="false">[</mo><msub><mi>X</mi><mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">c \in A[X_0]\cdots[X_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>.</span></p>
<pre class="Agda"><a id="constₚ"></a><a id="5317" href="Data.Nat.Solver.html#5317" data-type="Nat → Poly Nat n" class="Function">constₚ</a> <a id="5324" class="Symbol">:</a> <a id="5326" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="5330" class="Symbol">→</a> <a id="5332" href="Data.Nat.Solver.html#1583" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="5337" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="5341" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a>
<a id="5343" href="Data.Nat.Solver.html#5317" data-type="Nat → Poly Nat n" class="Function">constₚ</a> <a id="5350" class="Symbol">{</a><a id="5351" class="Argument">n</a> <a id="5353" class="Symbol">=</a> <a id="5355" href="Agda.Builtin.Nat.html#210" data-type="Nat" class="InductiveConstructor">zero</a><a id="5359" class="Symbol">}</a>  <a id="5362" href="Data.Nat.Solver.html#5362" class="Bound">c</a> <a id="5364" class="Symbol">=</a> <a id="5366" href="Data.Nat.Solver.html#1714" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="5372" href="Data.Nat.Solver.html#5362" class="Bound">c</a>
<a id="5374" href="Data.Nat.Solver.html#5317" data-type="Nat → Poly Nat n" class="Function">constₚ</a> <a id="5381" class="Symbol">{</a><a id="5382" class="Argument">n</a> <a id="5384" class="Symbol">=</a> <a id="5386" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="5390" href="Data.Nat.Solver.html#5390" class="Bound">n</a><a id="5391" class="Symbol">}</a> <a id="5393" href="Data.Nat.Solver.html#5393" class="Bound">c</a> <a id="5395" class="Symbol">=</a> <a id="5397" href="Data.Nat.Solver.html#5120" data-type="Poly Nat n" class="Function">0ₚ</a> <a id="5400" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="5404" href="Data.Nat.Solver.html#5317" data-type="Nat → Poly Nat n" class="Function">constₚ</a> <a id="5411" href="Data.Nat.Solver.html#5393" class="Bound">c</a>
</pre>
The constant 1 is important enough that it deserves it’s own syntax.
<pre class="Agda"><a id="1ₚ"></a><a id="5495" href="Data.Nat.Solver.html#5495" data-type="Poly Nat n" class="Function">1ₚ</a> <a id="5498" class="Symbol">:</a> <a id="5500" href="Data.Nat.Solver.html#1583" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="5505" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="5509" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a>
<a id="5511" href="Data.Nat.Solver.html#5495" data-type="Poly Nat n" class="Function">1ₚ</a> <a id="5514" class="Symbol">=</a> <a id="5516" href="Data.Nat.Solver.html#5317" data-type="Nat → Poly Nat n" class="Function">constₚ</a> <a id="5523" class="Number">1</a>
</pre>
<p>We also define the identity monomials <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo>∈</mo><mi>A</mi><mo stretchy="false">[</mo><msub><mi>X</mi><mn>0</mn></msub><mo stretchy="false">]</mo><mo>⋯</mo><mo stretchy="false">[</mo><msub><mi>X</mi><mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">X_i \in A[X_0]\cdots[X_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>.</span></p>
<pre class="Agda"><a id="X[_]"></a><a id="5606" href="Data.Nat.Solver.html#5606" data-type="Fin n → Poly Nat n" class="Function Operator">X[_]</a> <a id="5611" class="Symbol">:</a> <a id="5613" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="5617" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a> <a id="5619" class="Symbol">→</a> <a id="5621" href="Data.Nat.Solver.html#1583" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="5626" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="5630" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a>
<a id="5632" href="Data.Nat.Solver.html#5606" data-type="Fin n → Poly Nat n" class="Function Operator">X[_]</a> <a id="5637" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="5643" class="Symbol">=</a> <a id="5645" href="Data.Nat.Solver.html#5495" data-type="Poly Nat n" class="Function">1ₚ</a> <a id="5648" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="5652" href="Data.Nat.Solver.html#5120" data-type="Poly Nat n" class="Function">0ₚ</a>
<a id="5655" href="Data.Nat.Solver.html#5606" data-type="Fin n → Poly Nat n" class="Function Operator">X[_]</a> <a id="5660" class="Symbol">(</a><a id="5661" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="5666" href="Data.Nat.Solver.html#5666" class="Bound">i</a><a id="5667" class="Symbol">)</a> <a id="5669" class="Symbol">=</a> <a id="5671" href="Data.Nat.Solver.html#5120" data-type="Poly Nat n" class="Function">0ₚ</a> <a id="5674" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="5678" href="Data.Nat.Solver.html#5606" data-type="Fin n → Poly Nat n" class="Function Operator">X[</a> <a id="5681" href="Data.Nat.Solver.html#5666" class="Bound">i</a> <a id="5683" href="Data.Nat.Solver.html#5606" data-type="Fin n → Poly Nat n" class="Function Operator">]</a>
</pre>
<p>Now, onto addition of polynomials. This is more or less what one would expect if they wrote out the polynomials and did the addition by hand.</p>
<pre class="Agda"><a id="5841" class="Keyword">infixl</a> <a id="5848" class="Number">6</a> <a id="5850" href="Data.Nat.Solver.html#5870" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">_+ₚ_</a>
<a id="5855" class="Keyword">infixl</a> <a id="5862" class="Number">7</a> <a id="5864" href="Data.Nat.Solver.html#6292" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">_*ₚ_</a>

<a id="_+ₚ_"></a><a id="5870" href="Data.Nat.Solver.html#5870" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">_+ₚ_</a> <a id="5875" class="Symbol">:</a> <a id="5877" href="Data.Nat.Solver.html#1583" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="5882" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="5886" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a> <a id="5888" class="Symbol">→</a> <a id="5890" href="Data.Nat.Solver.html#1583" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="5895" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="5899" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a> <a id="5901" class="Symbol">→</a> <a id="5903" href="Data.Nat.Solver.html#1583" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="5908" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="5912" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a>
<a id="5914" href="Data.Nat.Solver.html#1714" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="5920" href="Data.Nat.Solver.html#5920" class="Bound">c₁</a> <a id="5923" href="Data.Nat.Solver.html#5870" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="5926" href="Data.Nat.Solver.html#1714" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="5932" href="Data.Nat.Solver.html#5932" class="Bound">c₂</a> <a id="5935" class="Symbol">=</a> <a id="5937" href="Data.Nat.Solver.html#1714" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="5943" class="Symbol">(</a><a id="5944" href="Data.Nat.Solver.html#5920" class="Bound">c₁</a> <a id="5947" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="5949" href="Data.Nat.Solver.html#5932" class="Bound">c₂</a><a id="5951" class="Symbol">)</a>
<a id="5953" href="Data.Nat.Solver.html#2100" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a> <a id="5959" href="Data.Nat.Solver.html#5870" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="5962" href="Data.Nat.Solver.html#5962" class="Bound">q</a> <a id="5964" class="Symbol">=</a> <a id="5966" href="Data.Nat.Solver.html#5962" class="Bound">q</a>
<a id="5968" class="Symbol">(</a><a id="5969" href="Data.Nat.Solver.html#5969" class="Bound">p</a> <a id="5971" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="5975" href="Data.Nat.Solver.html#5975" class="Bound">q</a><a id="5976" class="Symbol">)</a> <a id="5978" href="Data.Nat.Solver.html#5870" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="5981" href="Data.Nat.Solver.html#2100" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a> <a id="5987" class="Symbol">=</a> <a id="5989" href="Data.Nat.Solver.html#5969" class="Bound">p</a> <a id="5991" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="5995" href="Data.Nat.Solver.html#5975" class="Bound">q</a>
<a id="5997" class="Symbol">(</a><a id="5998" href="Data.Nat.Solver.html#5998" class="Bound">p</a> <a id="6000" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="6004" href="Data.Nat.Solver.html#6004" class="Bound">r</a><a id="6005" class="Symbol">)</a> <a id="6007" href="Data.Nat.Solver.html#5870" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="6010" class="Symbol">(</a><a id="6011" href="Data.Nat.Solver.html#6011" class="Bound">q</a> <a id="6013" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="6017" href="Data.Nat.Solver.html#6017" class="Bound">s</a><a id="6018" class="Symbol">)</a> <a id="6020" class="Symbol">=</a> <a id="6022" class="Symbol">(</a><a id="6023" href="Data.Nat.Solver.html#5998" class="Bound">p</a> <a id="6025" href="Data.Nat.Solver.html#5870" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="6028" href="Data.Nat.Solver.html#6011" class="Bound">q</a><a id="6029" class="Symbol">)</a> <a id="6031" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="6035" class="Symbol">(</a><a id="6036" href="Data.Nat.Solver.html#6004" class="Bound">r</a> <a id="6038" href="Data.Nat.Solver.html#5870" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="6041" href="Data.Nat.Solver.html#6017" class="Bound">s</a><a id="6042" class="Symbol">)</a>
</pre>
Multiplication, however, is somewhat more tricky. The problem is that during the course of recursion, we will need to multiply a <code>Poly A n</code> by a <code>Poly A (suc n)</code>. This ends up being mutually recursive, so let’s predeclare their types.
<pre class="Agda"><a id="_*ₚ_"></a><a id="6292" href="Data.Nat.Solver.html#6292" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">_*ₚ_</a> <a id="6297" class="Symbol">:</a> <a id="6299" href="Data.Nat.Solver.html#1583" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="6304" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="6308" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a> <a id="6310" class="Symbol">→</a> <a id="6312" href="Data.Nat.Solver.html#1583" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="6317" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="6321" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a> <a id="6323" class="Symbol">→</a> <a id="6325" href="Data.Nat.Solver.html#1583" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="6330" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="6334" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a>
<a id="_*ₚ′_"></a><a id="6336" href="Data.Nat.Solver.html#6336" data-type="Poly Nat n → Poly Nat (suc n) → Poly Nat (suc n)" class="Function Operator">_*ₚ′_</a> <a id="6342" class="Symbol">:</a> <a id="6344" href="Data.Nat.Solver.html#1583" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="6349" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="6353" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a> <a id="6355" class="Symbol">→</a> <a id="6357" href="Data.Nat.Solver.html#1583" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="6362" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="6366" class="Symbol">(</a><a id="6367" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="6371" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a><a id="6372" class="Symbol">)</a> <a id="6374" class="Symbol">→</a> <a id="6376" href="Data.Nat.Solver.html#1583" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="6381" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="6385" class="Symbol">(</a><a id="6386" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="6390" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a><a id="6391" class="Symbol">)</a>
</pre>
<p>First, the homogenous multiplication. The first two cases are pretty straightforward, but the final one is decidedly less so. To start, we can distribute the multiplication of <code>r</code> across the <code>+</code>, invoking <span class="Agda"><a href="Data.Nat.Solver.html#5870" class="Function Operator">_+ₚ_</a></span> to add the results together. When multiplying <code>q</code> and <code>r</code>, we need to use the aforementioned heterogeneous multiplication, as <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">[</mo><msub><mi>X</mi><mn>1</mn></msub><mo stretchy="false">]</mo><mo>⋯</mo><mo stretchy="false">[</mo><msub><mi>X</mi><mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">q \in A[X_1]\cdots[X_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>.</span> When multiplying <code>p</code> and <code>r</code>, we need to add on a <code>0ₚ</code> under the <code>*X</code>, as this is the only way of multiplying by <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">X_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span></p>
<pre class="Agda"><a id="6901" href="Data.Nat.Solver.html#1714" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="6907" href="Data.Nat.Solver.html#6907" class="Bound">c₁</a> <a id="6910" href="Data.Nat.Solver.html#6292" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="6913" href="Data.Nat.Solver.html#1714" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="6919" href="Data.Nat.Solver.html#6919" class="Bound">c₂</a> <a id="6922" class="Symbol">=</a> <a id="6924" href="Data.Nat.Solver.html#1714" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="6930" class="Symbol">(</a><a id="6931" href="Data.Nat.Solver.html#6907" class="Bound">c₁</a> <a id="6934" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="6936" href="Data.Nat.Solver.html#6919" class="Bound">c₂</a><a id="6938" class="Symbol">)</a>
<a id="6940" href="Data.Nat.Solver.html#2100" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a> <a id="6946" href="Data.Nat.Solver.html#6292" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="6949" href="Data.Nat.Solver.html#6949" class="Bound">q</a> <a id="6951" class="Symbol">=</a> <a id="6953" href="Data.Nat.Solver.html#2100" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a>
<a id="6959" class="Symbol">(</a><a id="6960" href="Data.Nat.Solver.html#6960" class="Bound">p</a> <a id="6962" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="6966" href="Data.Nat.Solver.html#6966" class="Bound">q</a><a id="6967" class="Symbol">)</a> <a id="6969" href="Data.Nat.Solver.html#6292" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="6972" href="Data.Nat.Solver.html#6972" class="Bound">r</a> <a id="6974" class="Symbol">=</a> <a id="6976" class="Symbol">((</a><a id="6978" href="Data.Nat.Solver.html#6960" class="Bound">p</a> <a id="6980" href="Data.Nat.Solver.html#6292" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="6983" href="Data.Nat.Solver.html#6972" class="Bound">r</a><a id="6984" class="Symbol">)</a> <a id="6986" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="6990" href="Data.Nat.Solver.html#5120" data-type="Poly Nat n" class="Function">0ₚ</a><a id="6992" class="Symbol">)</a> <a id="6994" href="Data.Nat.Solver.html#5870" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="6997" class="Symbol">(</a><a id="6998" href="Data.Nat.Solver.html#6966" class="Bound">q</a> <a id="7000" href="Data.Nat.Solver.html#6336" data-type="Poly Nat n → Poly Nat (suc n) → Poly Nat (suc n)" class="Function Operator">*ₚ′</a> <a id="7004" href="Data.Nat.Solver.html#6972" class="Bound">r</a><a id="7005" class="Symbol">)</a>
</pre>
<p>For the heterogeneous case, the recursion is somewhat more simple.</p>
<pre class="Agda"><a id="7088" href="Data.Nat.Solver.html#7088" class="Bound">r</a> <a id="7090" href="Data.Nat.Solver.html#6336" data-type="Poly Nat n → Poly Nat (suc n) → Poly Nat (suc n)" class="Function Operator">*ₚ′</a> <a id="7094" href="Data.Nat.Solver.html#2100" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a> <a id="7100" class="Symbol">=</a> <a id="7102" href="Data.Nat.Solver.html#2100" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a> 
<a id="7109" href="Data.Nat.Solver.html#7109" class="Bound">r</a> <a id="7111" href="Data.Nat.Solver.html#6336" data-type="Poly Nat n → Poly Nat (suc n) → Poly Nat (suc n)" class="Function Operator">*ₚ′</a> <a id="7115" class="Symbol">(</a><a id="7116" href="Data.Nat.Solver.html#7116" class="Bound">p</a> <a id="7118" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="7122" href="Data.Nat.Solver.html#7122" class="Bound">q</a><a id="7123" class="Symbol">)</a> <a id="7125" class="Symbol">=</a> <a id="7127" class="Symbol">(</a><a id="7128" href="Data.Nat.Solver.html#7109" class="Bound">r</a> <a id="7130" href="Data.Nat.Solver.html#6336" data-type="Poly Nat n → Poly Nat (suc n) → Poly Nat (suc n)" class="Function Operator">*ₚ′</a> <a id="7134" href="Data.Nat.Solver.html#7116" class="Bound">p</a><a id="7135" class="Symbol">)</a> <a id="7137" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="7141" class="Symbol">(</a><a id="7142" href="Data.Nat.Solver.html#7109" class="Bound">r</a> <a id="7144" href="Data.Nat.Solver.html#6292" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="7147" href="Data.Nat.Solver.html#7122" class="Bound">q</a><a id="7148" class="Symbol">)</a>
</pre>
<h3 id="evaluation-of-horner-normal-forms"><a href="#evaluation-of-horner-normal-forms" class="header-link">Evaluation of Horner Normal Forms<span class="header-link-emoji">🔗</span></a></h3>
<p>Multivariate polynomials represent functions <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi>n</mi></msup><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">A^n \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>,</span> so we should be able to interpret them as such. Luckily, Horner Normal Forms are extremely easy to evaluate. As a historical note, this is why this representation was created in first place! In this light, they should probably be called “Sharaf al-Din al-Tusi Normal Forms”.</p>
<pre class="Agda"><a id="block"></a><a id="7536" href="Data.Nat.Solver.html#7536" data-type="Nat → Nat" class="Function">block</a> <a id="7542" class="Symbol">:</a> <a id="7544" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="7548" class="Symbol">→</a> <a id="7550" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a>
<a id="7554" href="Data.Nat.Solver.html#7536" data-type="Nat → Nat" class="Function">block</a> <a id="7560" href="Data.Nat.Solver.html#7560" class="Bound">x</a> <a id="7562" class="Symbol">=</a> <a id="7564" href="Data.Nat.Solver.html#7560" class="Bound">x</a>
</pre>
<pre class="Agda"><a id="⟦_⟧ₚ"></a><a id="7579" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦_⟧ₚ</a> <a id="7584" class="Symbol">:</a> <a id="7586" href="Data.Nat.Solver.html#1583" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="7591" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="7595" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a> <a id="7597" class="Symbol">→</a> <a id="7599" href="1Lab.Reflection.html#1791" data-type="Type ℓ → Nat → Type ℓ" class="Datatype">Vec</a> <a id="7603" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="7607" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a> <a id="7609" class="Symbol">→</a> <a id="7611" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a>
<a id="7615" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="7617" href="Data.Nat.Solver.html#1714" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="7623" href="Data.Nat.Solver.html#7623" class="Bound">c</a> <a id="7625" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="7628" href="Data.Nat.Solver.html#7628" class="Bound">env</a> <a id="7632" class="Symbol">=</a> <a id="7634" href="Data.Nat.Solver.html#7623" class="Bound">c</a>
<a id="7636" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="7638" href="Data.Nat.Solver.html#2100" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a> <a id="7644" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="7647" href="Data.Nat.Solver.html#7647" class="Bound">env</a> <a id="7651" class="Symbol">=</a> <a id="7653" class="Number">0</a>
<a id="7655" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="7657" href="Data.Nat.Solver.html#7657" class="Bound">p</a> <a id="7659" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="7663" href="Data.Nat.Solver.html#7663" class="Bound">q</a> <a id="7665" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="7668" class="Symbol">(</a><a id="7669" href="Data.Nat.Solver.html#7669" class="Bound">x₀</a> <a id="7672" href="1Lab.Reflection.html#1853" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="7674" href="Data.Nat.Solver.html#7674" class="Bound">env</a><a id="7677" class="Symbol">)</a> <a id="7679" class="Symbol">=</a> <a id="7681" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="7683" href="Data.Nat.Solver.html#7657" class="Bound">p</a> <a id="7685" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="7688" class="Symbol">(</a><a id="7689" href="Data.Nat.Solver.html#7669" class="Bound">x₀</a> <a id="7692" href="1Lab.Reflection.html#1853" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="7694" href="Data.Nat.Solver.html#7674" class="Bound">env</a><a id="7697" class="Symbol">)</a> <a id="7699" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="7701" href="Data.Nat.Solver.html#7669" class="Bound">x₀</a> <a id="7704" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="7706" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="7708" href="Data.Nat.Solver.html#7663" class="Bound">q</a> <a id="7710" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="7713" href="Data.Nat.Solver.html#7674" class="Bound">env</a> 
</pre>
<h3 id="soundness-of-the-operations"><a href="#soundness-of-the-operations" class="header-link">Soundness of the Operations<span class="header-link-emoji">🔗</span></a></h3>
<p>Now, it’s important that the operations we defined actually denote the correct operations on natural numbers.</p>
<p>As a warm up, let’s show that the zero polynomial really represents the function <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(x_0, \cdots, x_n) = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>.</span></p>
<pre class="Agda"><a id="sound-0ₚ"></a><a id="7984" href="Data.Nat.Solver.html#7984" data-type="(env : Vec Nat n) → ⟦ 0ₚ ⟧ₚ env ≡ 0" class="Function">sound-0ₚ</a> <a id="7993" class="Symbol">:</a> <a id="7995" class="Symbol">∀</a> <a id="7997" class="Symbol">(</a><a id="7998" href="Data.Nat.Solver.html#7998" class="Bound">env</a> <a id="8002" class="Symbol">:</a> <a id="8004" href="1Lab.Reflection.html#1791" data-type="Type ℓ → Nat → Type ℓ" class="Datatype">Vec</a> <a id="8008" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="8012" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a><a id="8013" class="Symbol">)</a> <a id="8015" class="Symbol">→</a> <a id="8017" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="8019" href="Data.Nat.Solver.html#5120" data-type="Poly Nat n" class="Function">0ₚ</a> <a id="8022" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="8025" href="Data.Nat.Solver.html#7998" class="Bound">env</a> <a id="8029" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="8031" class="Number">0</a>
<a id="8033" href="Data.Nat.Solver.html#7984" data-type="(env : Vec Nat n) → ⟦ 0ₚ ⟧ₚ env ≡ 0" class="Function">sound-0ₚ</a> <a id="8042" href="1Lab.Reflection.html#1835" data-type="Vec A zero" class="InductiveConstructor">[]</a> <a id="8045" class="Symbol">=</a> <a id="8047" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
<a id="8052" href="Data.Nat.Solver.html#7984" data-type="(env : Vec Nat n) → ⟦ 0ₚ ⟧ₚ env ≡ 0" class="Function">sound-0ₚ</a> <a id="8061" class="Symbol">(</a><a id="8062" href="Data.Nat.Solver.html#8062" class="Bound">x</a> <a id="8064" href="1Lab.Reflection.html#1853" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="8066" href="Data.Nat.Solver.html#8066" class="Bound">env</a><a id="8069" class="Symbol">)</a> <a id="8071" class="Symbol">=</a> <a id="8073" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
</pre>
<p>We do the same for the constant polynomial.</p>
<pre class="Agda"><a id="sound-constₚ"></a><a id="8136" href="Data.Nat.Solver.html#8136" data-type="(c : Nat) (env : Vec Nat n) → ⟦ constₚ c ⟧ₚ env ≡ c" class="Function">sound-constₚ</a> <a id="8149" class="Symbol">:</a> <a id="8151" class="Symbol">∀</a> <a id="8153" href="Data.Nat.Solver.html#8153" class="Bound">c</a> <a id="8155" class="Symbol">→</a> <a id="8157" class="Symbol">(</a><a id="8158" href="Data.Nat.Solver.html#8158" class="Bound">env</a> <a id="8162" class="Symbol">:</a> <a id="8164" href="1Lab.Reflection.html#1791" data-type="Type ℓ → Nat → Type ℓ" class="Datatype">Vec</a> <a id="8168" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="8172" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a><a id="8173" class="Symbol">)</a> <a id="8175" class="Symbol">→</a> <a id="8177" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="8179" href="Data.Nat.Solver.html#5317" data-type="Nat → Poly Nat n" class="Function">constₚ</a> <a id="8186" href="Data.Nat.Solver.html#8153" class="Bound">c</a> <a id="8188" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="8191" href="Data.Nat.Solver.html#8158" class="Bound">env</a> <a id="8195" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="8197" href="Data.Nat.Solver.html#8153" class="Bound">c</a>
<a id="8199" href="Data.Nat.Solver.html#8136" data-type="(c : Nat) (env : Vec Nat n) → ⟦ constₚ c ⟧ₚ env ≡ c" class="Function">sound-constₚ</a> <a id="8212" href="Data.Nat.Solver.html#8212" class="Bound">c</a> <a id="8214" href="1Lab.Reflection.html#1835" data-type="Vec A zero" class="InductiveConstructor">[]</a> <a id="8217" class="Symbol">=</a> <a id="8219" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
<a id="8224" href="Data.Nat.Solver.html#8136" data-type="(c : Nat) (env : Vec Nat n) → ⟦ constₚ c ⟧ₚ env ≡ c" class="Function">sound-constₚ</a> <a id="8237" href="Data.Nat.Solver.html#8237" class="Bound">c</a> <a id="8239" class="Symbol">(</a><a id="8240" href="Data.Nat.Solver.html#8240" class="Bound">x</a> <a id="8242" href="1Lab.Reflection.html#1853" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="8244" href="Data.Nat.Solver.html#8244" class="Bound">env</a><a id="8247" class="Symbol">)</a> <a id="8249" class="Symbol">=</a> <a id="8251" href="Data.Nat.Solver.html#8136" data-type="(c : Nat) (env : Vec Nat n) → ⟦ constₚ c ⟧ₚ env ≡ c" class="Function">sound-constₚ</a> <a id="8264" href="Data.Nat.Solver.html#8237" class="Bound">c</a> <a id="8266" href="Data.Nat.Solver.html#8244" class="Bound">env</a>
</pre>
<p>At the risk o</p>
<p>f repeating myself, we also show the same for the monomial <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span></p>
<pre class="Agda"><a id="sound-X[_]"></a><a id="8365" href="Data.Nat.Solver.html#8365" data-type="(i : Fin n) (env : Vec Nat n) → ⟦ X[ i ] ⟧ₚ env ≡ lookup env i" class="Function Operator">sound-X[_]</a> <a id="8376" class="Symbol">:</a> <a id="8378" class="Symbol">∀</a> <a id="8380" href="Data.Nat.Solver.html#8380" class="Bound">i</a> <a id="8382" class="Symbol">→</a> <a id="8384" class="Symbol">(</a><a id="8385" href="Data.Nat.Solver.html#8385" class="Bound">env</a> <a id="8389" class="Symbol">:</a> <a id="8391" href="1Lab.Reflection.html#1791" data-type="Type ℓ → Nat → Type ℓ" class="Datatype">Vec</a> <a id="8395" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="8399" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a><a id="8400" class="Symbol">)</a> <a id="8402" class="Symbol">→</a> <a id="8404" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="8406" href="Data.Nat.Solver.html#5606" data-type="Fin n → Poly Nat n" class="Function Operator">X[</a> <a id="8409" href="Data.Nat.Solver.html#8380" class="Bound">i</a> <a id="8411" href="Data.Nat.Solver.html#5606" data-type="Fin n → Poly Nat n" class="Function Operator">]</a> <a id="8413" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="8416" href="Data.Nat.Solver.html#8385" class="Bound">env</a> <a id="8420" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="8422" href="Data.Nat.Solver.html#3009" data-type="Vec A n → Fin n → A" class="Function">lookup</a> <a id="8429" href="Data.Nat.Solver.html#8385" class="Bound">env</a> <a id="8433" href="Data.Nat.Solver.html#8380" class="Bound">i</a>
<a id="8435" href="Data.Nat.Solver.html#8365" data-type="(i : Fin n) (env : Vec Nat n) → ⟦ X[ i ] ⟧ₚ env ≡ lookup env i" class="Function Operator">sound-X[</a> <a id="8444" href="Data.Fin.Base.html#523" data-type="Fin (suc n)" class="InductiveConstructor">fzero</a> <a id="8450" href="Data.Nat.Solver.html#8365" data-type="(i : Fin n) (env : Vec Nat n) → ⟦ X[ i ] ⟧ₚ env ≡ lookup env i" class="Function Operator">]</a> <a id="8452" class="Symbol">(</a><a id="8453" href="Data.Nat.Solver.html#8453" class="Bound">x₀</a> <a id="8456" href="1Lab.Reflection.html#1853" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="8458" href="Data.Nat.Solver.html#8458" class="Bound">env</a><a id="8461" class="Symbol">)</a> <a id="8463" class="Symbol">=</a>
  <a id="8467" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="8469" href="Data.Nat.Solver.html#5317" data-type="Nat → Poly Nat n" class="Function">constₚ</a> <a id="8476" class="Number">1</a> <a id="8478" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="8481" href="Data.Nat.Solver.html#8458" class="Bound">env</a> <a id="8485" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="8487" href="Data.Nat.Solver.html#8453" class="Bound">x₀</a> <a id="8490" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="8492" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="8494" href="Data.Nat.Solver.html#5120" data-type="Poly Nat n" class="Function">0ₚ</a> <a id="8497" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="8500" href="Data.Nat.Solver.html#8458" class="Bound">env</a> <a id="8504" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8507" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="8511" class="Symbol">(λ</a> <a id="8514" href="Data.Nat.Solver.html#8514" class="Bound">ϕ</a> <a id="8516" href="Data.Nat.Solver.html#8516" class="Bound">ψ</a> <a id="8518" class="Symbol">→</a> <a id="8520" href="Data.Nat.Solver.html#8514" class="Bound">ϕ</a> <a id="8522" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="8524" href="Data.Nat.Solver.html#8453" class="Bound">x₀</a> <a id="8527" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="8529" href="Data.Nat.Solver.html#8516" class="Bound">ψ</a><a id="8530" class="Symbol">)</a> <a id="8532" class="Symbol">(</a><a id="8533" href="Data.Nat.Solver.html#8136" data-type="(c : Nat) (env : Vec Nat n) → ⟦ constₚ c ⟧ₚ env ≡ c" class="Function">sound-constₚ</a> <a id="8546" class="Number">1</a> <a id="8548" href="Data.Nat.Solver.html#8458" class="Bound">env</a><a id="8551" class="Symbol">)</a> <a id="8553" class="Symbol">(</a><a id="8554" href="Data.Nat.Solver.html#7984" data-type="(env : Vec Nat n) → ⟦ 0ₚ ⟧ₚ env ≡ 0" class="Function">sound-0ₚ</a> <a id="8563" href="Data.Nat.Solver.html#8458" class="Bound">env</a><a id="8566" class="Symbol">)</a> <a id="8568" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="8572" class="Number">1</a> <a id="8574" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="8576" href="Data.Nat.Solver.html#8453" class="Bound">x₀</a> <a id="8579" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="8581" class="Number">0</a>                           <a id="8609" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8612" href="Data.Nat.Properties.html#746" data-type="(x : Nat) → x + 0 ≡ x" class="Function">+-zeror</a> <a id="8620" class="Symbol">(</a><a id="8621" class="Number">1</a> <a id="8623" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="8625" href="Data.Nat.Solver.html#8453" class="Bound">x₀</a><a id="8627" class="Symbol">)</a> <a id="8629" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="8633" class="Number">1</a> <a id="8635" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="8637" href="Data.Nat.Solver.html#8453" class="Bound">x₀</a>                               <a id="8670" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8673" href="Data.Nat.Properties.html#1948" data-type="(x : Nat) → 1 * x ≡ x" class="Function">*-onel</a> <a id="8680" href="Data.Nat.Solver.html#8453" class="Bound">x₀</a> <a id="8683" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="8687" href="Data.Nat.Solver.html#8453" class="Bound">x₀</a> <a id="8690" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
<a id="8692" href="Data.Nat.Solver.html#8365" data-type="(i : Fin n) (env : Vec Nat n) → ⟦ X[ i ] ⟧ₚ env ≡ lookup env i" class="Function Operator">sound-X[</a> <a id="8701" href="Data.Fin.Base.html#553" data-type="Fin n → Fin (suc n)" class="InductiveConstructor">fsuc</a> <a id="8706" href="Data.Nat.Solver.html#8706" class="Bound">i</a> <a id="8708" href="Data.Nat.Solver.html#8365" data-type="(i : Fin n) (env : Vec Nat n) → ⟦ X[ i ] ⟧ₚ env ≡ lookup env i" class="Function Operator">]</a> <a id="8710" class="Symbol">(_</a> <a id="8713" href="1Lab.Reflection.html#1853" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="8715" href="Data.Nat.Solver.html#8715" class="Bound">env</a><a id="8718" class="Symbol">)</a> <a id="8720" class="Symbol">=</a> <a id="8722" href="Data.Nat.Solver.html#8365" data-type="(i : Fin n) (env : Vec Nat n) → ⟦ X[ i ] ⟧ₚ env ≡ lookup env i" class="Function Operator">sound-X[</a> <a id="8731" href="Data.Nat.Solver.html#8706" class="Bound">i</a> <a id="8733" href="Data.Nat.Solver.html#8365" data-type="(i : Fin n) (env : Vec Nat n) → ⟦ X[ i ] ⟧ₚ env ≡ lookup env i" class="Function Operator">]</a> <a id="8735" href="Data.Nat.Solver.html#8715" class="Bound">env</a>
</pre>
<p>Now, for something more involved: let’s show that addition of polynomials really deserves the name addition.</p>
<pre class="Agda"><a id="sound-+ₚ"></a><a id="8862" href="Data.Nat.Solver.html#8862" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p +ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env + ⟦ q ⟧ₚ env" class="Function">sound-+ₚ</a> <a id="8871" class="Symbol">:</a> <a id="8873" class="Symbol">∀</a> <a id="8875" href="Data.Nat.Solver.html#8875" class="Bound">p</a> <a id="8877" href="Data.Nat.Solver.html#8877" class="Bound">q</a> <a id="8879" class="Symbol">→</a> <a id="8881" class="Symbol">(</a><a id="8882" href="Data.Nat.Solver.html#8882" class="Bound">env</a> <a id="8886" class="Symbol">:</a> <a id="8888" href="1Lab.Reflection.html#1791" data-type="Type ℓ → Nat → Type ℓ" class="Datatype">Vec</a> <a id="8892" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="8896" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a><a id="8897" class="Symbol">)</a>
           <a id="8910" class="Symbol">→</a> <a id="8912" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="8914" href="Data.Nat.Solver.html#8875" class="Bound">p</a> <a id="8916" href="Data.Nat.Solver.html#5870" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="8919" href="Data.Nat.Solver.html#8877" class="Bound">q</a> <a id="8921" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="8924" href="Data.Nat.Solver.html#8882" class="Bound">env</a> <a id="8928" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="8930" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="8932" href="Data.Nat.Solver.html#8875" class="Bound">p</a> <a id="8934" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="8937" href="Data.Nat.Solver.html#8882" class="Bound">env</a> <a id="8941" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="8943" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="8945" href="Data.Nat.Solver.html#8877" class="Bound">q</a> <a id="8947" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="8950" href="Data.Nat.Solver.html#8882" class="Bound">env</a>
<a id="8954" href="Data.Nat.Solver.html#8862" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p +ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env + ⟦ q ⟧ₚ env" class="Function">sound-+ₚ</a> <a id="8963" class="Symbol">(</a><a id="8964" href="Data.Nat.Solver.html#1714" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="8970" href="Data.Nat.Solver.html#8970" class="Bound">c1</a><a id="8972" class="Symbol">)</a> <a id="8974" class="Symbol">(</a><a id="8975" href="Data.Nat.Solver.html#1714" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="8981" href="Data.Nat.Solver.html#8981" class="Bound">c2</a><a id="8983" class="Symbol">)</a> <a id="8985" href="Data.Nat.Solver.html#8985" class="Bound">env</a> <a id="8989" class="Symbol">=</a> <a id="8991" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
<a id="8996" href="Data.Nat.Solver.html#8862" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p +ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env + ⟦ q ⟧ₚ env" class="Function">sound-+ₚ</a> <a id="9005" href="Data.Nat.Solver.html#2100" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a> <a id="9011" href="Data.Nat.Solver.html#9011" class="Bound">q</a> <a id="9013" href="Data.Nat.Solver.html#9013" class="Bound">env</a> <a id="9017" class="Symbol">=</a> <a id="9019" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
<a id="9024" href="Data.Nat.Solver.html#8862" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p +ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env + ⟦ q ⟧ₚ env" class="Function">sound-+ₚ</a> <a id="9033" class="Symbol">(</a><a id="9034" href="Data.Nat.Solver.html#9034" class="Bound">p</a> <a id="9036" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="9040" href="Data.Nat.Solver.html#9040" class="Bound">r</a><a id="9041" class="Symbol">)</a> <a id="9043" href="Data.Nat.Solver.html#2100" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a> <a id="9049" href="Data.Nat.Solver.html#9049" class="Bound">env</a> <a id="9053" class="Symbol">=</a>
  <a id="9057" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="9061" class="Symbol">(</a><a id="9062" href="Data.Nat.Properties.html#746" data-type="(x : Nat) → x + 0 ≡ x" class="Function">+-zeror</a> <a id="9070" class="Symbol">(</a><a id="9071" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="9073" class="Symbol">(</a><a id="9074" href="Data.Nat.Solver.html#9034" class="Bound">p</a> <a id="9076" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="9080" href="Data.Nat.Solver.html#9040" class="Bound">r</a><a id="9081" class="Symbol">)</a> <a id="9083" href="Data.Nat.Solver.html#5870" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="9086" href="Data.Nat.Solver.html#2100" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a> <a id="9092" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="9095" href="Data.Nat.Solver.html#9049" class="Bound">env</a><a id="9098" class="Symbol">))</a>
<a id="9101" href="Data.Nat.Solver.html#8862" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p +ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env + ⟦ q ⟧ₚ env" class="Function">sound-+ₚ</a> <a id="9110" class="Symbol">(</a><a id="9111" href="Data.Nat.Solver.html#9111" class="Bound">p</a> <a id="9113" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="9117" href="Data.Nat.Solver.html#9117" class="Bound">r</a><a id="9118" class="Symbol">)</a> <a id="9120" class="Symbol">(</a><a id="9121" href="Data.Nat.Solver.html#9121" class="Bound">q</a> <a id="9123" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="9127" href="Data.Nat.Solver.html#9127" class="Bound">s</a><a id="9128" class="Symbol">)</a> <a id="9130" class="Symbol">(</a><a id="9131" href="Data.Nat.Solver.html#9131" class="Bound">x₀</a> <a id="9134" href="1Lab.Reflection.html#1853" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="9136" href="Data.Nat.Solver.html#9136" class="Bound">env</a><a id="9139" class="Symbol">)</a> <a id="9141" class="Symbol">=</a>
  <a id="9145" href="Data.Nat.Solver.html#9483" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p+q⟧</a> <a id="9151" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="9153" href="Data.Nat.Solver.html#9131" class="Bound">x₀</a> <a id="9156" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="9158" href="Data.Nat.Solver.html#9518" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r+s⟧</a>                <a id="9179" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="9182" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="9186" class="Symbol">(λ</a> <a id="9189" href="Data.Nat.Solver.html#9189" class="Bound">ϕ</a> <a id="9191" href="Data.Nat.Solver.html#9191" class="Bound">ψ</a> <a id="9193" class="Symbol">→</a> <a id="9195" href="Data.Nat.Solver.html#9189" class="Bound">ϕ</a> <a id="9197" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="9199" href="Data.Nat.Solver.html#9131" class="Bound">x₀</a> <a id="9202" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="9204" href="Data.Nat.Solver.html#9191" class="Bound">ψ</a><a id="9205" class="Symbol">)</a> <a id="9207" class="Symbol">(</a><a id="9208" href="Data.Nat.Solver.html#8862" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p +ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env + ⟦ q ⟧ₚ env" class="Function">sound-+ₚ</a> <a id="9217" href="Data.Nat.Solver.html#9111" class="Bound">p</a> <a id="9219" href="Data.Nat.Solver.html#9121" class="Bound">q</a> <a id="9221" class="Symbol">(</a><a id="9222" href="Data.Nat.Solver.html#9131" class="Bound">x₀</a> <a id="9225" href="1Lab.Reflection.html#1853" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="9227" href="Data.Nat.Solver.html#9136" class="Bound">env</a><a id="9230" class="Symbol">))</a> <a id="9233" class="Symbol">(</a><a id="9234" href="Data.Nat.Solver.html#8862" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p +ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env + ⟦ q ⟧ₚ env" class="Function">sound-+ₚ</a> <a id="9243" href="Data.Nat.Solver.html#9117" class="Bound">r</a> <a id="9245" href="Data.Nat.Solver.html#9127" class="Bound">s</a> <a id="9247" href="Data.Nat.Solver.html#9136" class="Bound">env</a><a id="9250" class="Symbol">)</a> <a id="9252" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="9256" class="Symbol">(</a><a id="9257" href="Data.Nat.Solver.html#9546" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="9261" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="9263" href="Data.Nat.Solver.html#9595" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a><a id="9266" class="Symbol">)</a> <a id="9268" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="9270" href="Data.Nat.Solver.html#9131" class="Bound">x₀</a> <a id="9273" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="9275" class="Symbol">(</a><a id="9276" href="Data.Nat.Solver.html#9574" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="9280" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="9282" href="Data.Nat.Solver.html#9623" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="9285" class="Symbol">)</a>    <a id="9290" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="9293" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="9296" class="Symbol">(λ</a> <a id="9299" href="Data.Nat.Solver.html#9299" class="Bound">ϕ</a> <a id="9301" class="Symbol">→</a> <a id="9303" href="Data.Nat.Solver.html#9299" class="Bound">ϕ</a> <a id="9305" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="9307" class="Symbol">(</a><a id="9308" href="Data.Nat.Solver.html#9574" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="9312" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="9314" href="Data.Nat.Solver.html#9623" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="9317" class="Symbol">))</a> <a id="9320" class="Symbol">(</a><a id="9321" href="Data.Nat.Properties.html#1218" data-type="(x y z : Nat) → (x + y) * z ≡ x * z + y * z" class="Function">*-distrib-+r</a> <a id="9334" href="Data.Nat.Solver.html#9546" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="9338" href="Data.Nat.Solver.html#9595" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="9342" href="Data.Nat.Solver.html#9131" class="Bound">x₀</a><a id="9344" class="Symbol">)</a> <a id="9346" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="9350" href="Data.Nat.Solver.html#9546" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="9354" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="9356" href="Data.Nat.Solver.html#9131" class="Bound">x₀</a> <a id="9359" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="9361" href="Data.Nat.Solver.html#9595" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="9365" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="9367" href="Data.Nat.Solver.html#9131" class="Bound">x₀</a> <a id="9370" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="9372" class="Symbol">(</a><a id="9373" href="Data.Nat.Solver.html#9574" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="9377" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="9379" href="Data.Nat.Solver.html#9623" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="9382" class="Symbol">)</a> <a id="9384" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="9387" href="Data.Nat.Solver.html#3227" data-type="(w x y z : Nat) → w + x + (y + z) ≡ w + y + (x + z)" class="Function">commute-inner</a> <a id="9401" class="Symbol">(</a><a id="9402" href="Data.Nat.Solver.html#9546" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="9406" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="9408" href="Data.Nat.Solver.html#9131" class="Bound">x₀</a><a id="9410" class="Symbol">)</a> <a id="9412" class="Symbol">(</a><a id="9413" href="Data.Nat.Solver.html#9595" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="9417" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="9419" href="Data.Nat.Solver.html#9131" class="Bound">x₀</a><a id="9421" class="Symbol">)</a> <a id="9423" href="Data.Nat.Solver.html#9574" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="9427" href="Data.Nat.Solver.html#9623" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a> <a id="9431" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="9435" href="Data.Nat.Solver.html#9546" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="9439" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="9441" href="Data.Nat.Solver.html#9131" class="Bound">x₀</a> <a id="9444" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="9446" href="Data.Nat.Solver.html#9574" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="9450" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="9452" class="Symbol">(</a><a id="9453" href="Data.Nat.Solver.html#9595" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="9457" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="9459" href="Data.Nat.Solver.html#9131" class="Bound">x₀</a> <a id="9462" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="9464" href="Data.Nat.Solver.html#9623" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="9467" class="Symbol">)</a> <a id="9469" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
  <a id="9473" class="Keyword">where</a>
    <a id="9483" href="Data.Nat.Solver.html#9483" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p+q⟧</a> <a id="9489" class="Symbol">=</a> <a id="9491" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="9493" href="Data.Nat.Solver.html#9111" class="Bound">p</a> <a id="9495" href="Data.Nat.Solver.html#5870" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="9498" href="Data.Nat.Solver.html#9121" class="Bound">q</a> <a id="9500" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="9503" class="Symbol">(</a><a id="9504" href="Data.Nat.Solver.html#9131" class="Bound">x₀</a> <a id="9507" href="1Lab.Reflection.html#1853" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="9509" href="Data.Nat.Solver.html#9136" class="Bound">env</a><a id="9512" class="Symbol">)</a>
    <a id="9518" href="Data.Nat.Solver.html#9518" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r+s⟧</a> <a id="9524" class="Symbol">=</a> <a id="9526" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="9528" href="Data.Nat.Solver.html#9117" class="Bound">r</a> <a id="9530" href="Data.Nat.Solver.html#5870" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="9533" href="Data.Nat.Solver.html#9127" class="Bound">s</a> <a id="9535" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="9538" href="Data.Nat.Solver.html#9136" class="Bound">env</a>
    <a id="9546" href="Data.Nat.Solver.html#9546" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="9550" class="Symbol">=</a> <a id="9552" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="9554" href="Data.Nat.Solver.html#9111" class="Bound">p</a> <a id="9556" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="9559" class="Symbol">(</a><a id="9560" href="Data.Nat.Solver.html#9131" class="Bound">x₀</a> <a id="9563" href="1Lab.Reflection.html#1853" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="9565" href="Data.Nat.Solver.html#9136" class="Bound">env</a><a id="9568" class="Symbol">)</a>
    <a id="9574" href="Data.Nat.Solver.html#9574" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="9578" class="Symbol">=</a> <a id="9580" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="9582" href="Data.Nat.Solver.html#9117" class="Bound">r</a> <a id="9584" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="9587" href="Data.Nat.Solver.html#9136" class="Bound">env</a>
    <a id="9595" href="Data.Nat.Solver.html#9595" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="9599" class="Symbol">=</a> <a id="9601" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="9603" href="Data.Nat.Solver.html#9121" class="Bound">q</a> <a id="9605" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="9608" class="Symbol">(</a><a id="9609" href="Data.Nat.Solver.html#9131" class="Bound">x₀</a> <a id="9612" href="1Lab.Reflection.html#1853" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="9614" href="Data.Nat.Solver.html#9136" class="Bound">env</a><a id="9617" class="Symbol">)</a>
    <a id="9623" href="Data.Nat.Solver.html#9623" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a> <a id="9627" class="Symbol">=</a> <a id="9629" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="9631" href="Data.Nat.Solver.html#9127" class="Bound">s</a> <a id="9633" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="9636" href="Data.Nat.Solver.html#9136" class="Bound">env</a>
</pre>
<p>Wow, that was a bit painful! This is a somewhat common theme when writing proof automation: it distills down a lot of the annoying proofs we need to write across the entire codebase into one <em>extremely</em> painful proof. Thus, convervation of frustration is preserved.</p>
<p>Philisophical reflections aside, let’s move onto multiplication of polynomials. As the homogenous and heterogeneous multiplication were defined in a mutual recursive manner, we must do so for their proofs as well.</p>
<pre class="Agda"><a id="sound-*ₚ"></a><a id="10135" href="Data.Nat.Solver.html#10135" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p *ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env * ⟦ q ⟧ₚ env" class="Function">sound-*ₚ</a> <a id="10144" class="Symbol">:</a> <a id="10146" class="Symbol">∀</a> <a id="10148" href="Data.Nat.Solver.html#10148" class="Bound">p</a> <a id="10150" href="Data.Nat.Solver.html#10150" class="Bound">q</a> <a id="10152" class="Symbol">→</a> <a id="10154" class="Symbol">(</a><a id="10155" href="Data.Nat.Solver.html#10155" class="Bound">env</a> <a id="10159" class="Symbol">:</a> <a id="10161" href="1Lab.Reflection.html#1791" data-type="Type ℓ → Nat → Type ℓ" class="Datatype">Vec</a> <a id="10165" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="10169" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a><a id="10170" class="Symbol">)</a>
           <a id="10183" class="Symbol">→</a> <a id="10185" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="10187" href="Data.Nat.Solver.html#10148" class="Bound">p</a> <a id="10189" href="Data.Nat.Solver.html#6292" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="10192" href="Data.Nat.Solver.html#10150" class="Bound">q</a> <a id="10194" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="10197" href="Data.Nat.Solver.html#10155" class="Bound">env</a> <a id="10201" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="10203" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="10205" href="Data.Nat.Solver.html#10148" class="Bound">p</a> <a id="10207" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="10210" href="Data.Nat.Solver.html#10155" class="Bound">env</a> <a id="10214" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="10216" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="10218" href="Data.Nat.Solver.html#10150" class="Bound">q</a> <a id="10220" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="10223" href="Data.Nat.Solver.html#10155" class="Bound">env</a>
<a id="sound-*ₚ′"></a><a id="10227" href="Data.Nat.Solver.html#10227" data-type="(p : Poly Nat n) (q : Poly Nat (suc n)) (x₀ : Nat)
(env : Vec Nat n) →
⟦ p *ₚ′ q ⟧ₚ (x₀ ∷ env) ≡ ⟦ p ⟧ₚ env * ⟦ q ⟧ₚ (x₀ ∷ env)" class="Function">sound-*ₚ′</a> <a id="10237" class="Symbol">:</a> <a id="10239" class="Symbol">∀</a> <a id="10241" href="Data.Nat.Solver.html#10241" class="Bound">p</a> <a id="10243" href="Data.Nat.Solver.html#10243" class="Bound">q</a> <a id="10245" class="Symbol">→</a> <a id="10247" class="Symbol">(</a><a id="10248" href="Data.Nat.Solver.html#10248" class="Bound">x₀</a> <a id="10251" class="Symbol">:</a> <a id="10253" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a><a id="10256" class="Symbol">)</a> <a id="10258" class="Symbol">→</a> <a id="10260" class="Symbol">(</a><a id="10261" href="Data.Nat.Solver.html#10261" class="Bound">env</a> <a id="10265" class="Symbol">:</a> <a id="10267" href="1Lab.Reflection.html#1791" data-type="Type ℓ → Nat → Type ℓ" class="Datatype">Vec</a> <a id="10271" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="10275" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a><a id="10276" class="Symbol">)</a>
            <a id="10290" class="Symbol">→</a> <a id="10292" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="10294" href="Data.Nat.Solver.html#10241" class="Bound">p</a> <a id="10296" href="Data.Nat.Solver.html#6336" data-type="Poly Nat n → Poly Nat (suc n) → Poly Nat (suc n)" class="Function Operator">*ₚ′</a> <a id="10300" href="Data.Nat.Solver.html#10243" class="Bound">q</a> <a id="10302" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="10305" class="Symbol">(</a><a id="10306" href="Data.Nat.Solver.html#10248" class="Bound">x₀</a> <a id="10309" class="InductiveConstructor Operator">∷</a> <a id="10311" href="Data.Nat.Solver.html#10261" class="Bound">env</a><a id="10314" class="Symbol">)</a> <a id="10316" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="10318" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="10320" href="Data.Nat.Solver.html#10241" class="Bound">p</a> <a id="10322" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="10325" href="Data.Nat.Solver.html#10261" class="Bound">env</a> <a id="10329" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="10331" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="10333" href="Data.Nat.Solver.html#10243" class="Bound">q</a> <a id="10335" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="10338" class="Symbol">(</a><a id="10339" href="Data.Nat.Solver.html#10248" class="Bound">x₀</a> <a id="10342" class="InductiveConstructor Operator">∷</a> <a id="10344" href="Data.Nat.Solver.html#10261" class="Bound">env</a><a id="10347" class="Symbol">)</a>
</pre>
<p>The first couple of cases of homogenous multiplication don’t look so bad…</p>
<pre class="Agda"><a id="10439" href="Data.Nat.Solver.html#10135" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p *ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env * ⟦ q ⟧ₚ env" class="Function">sound-*ₚ</a> <a id="10448" class="Symbol">(</a><a id="10449" href="Data.Nat.Solver.html#1714" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="10455" href="Data.Nat.Solver.html#10455" class="Bound">c1</a><a id="10457" class="Symbol">)</a> <a id="10459" class="Symbol">(</a><a id="10460" href="Data.Nat.Solver.html#1714" data-type="A → Poly A 0" class="InductiveConstructor">const</a> <a id="10466" href="Data.Nat.Solver.html#10466" class="Bound">c2</a><a id="10468" class="Symbol">)</a> <a id="10470" href="Data.Nat.Solver.html#10470" class="Bound">env</a> <a id="10474" class="Symbol">=</a> <a id="10476" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
<a id="10481" href="Data.Nat.Solver.html#10135" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p *ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env * ⟦ q ⟧ₚ env" class="Function">sound-*ₚ</a> <a id="10490" href="Data.Nat.Solver.html#2100" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a> <a id="10496" href="Data.Nat.Solver.html#10496" class="Bound">q</a> <a id="10498" href="Data.Nat.Solver.html#10498" class="Bound">env</a> <a id="10502" class="Symbol">=</a> <a id="10504" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
<a id="10509" href="Data.Nat.Solver.html#10135" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p *ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env * ⟦ q ⟧ₚ env" class="Function">sound-*ₚ</a> <a id="10518" class="Symbol">(</a><a id="10519" href="Data.Nat.Solver.html#10519" class="Bound">p</a> <a id="10521" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="10525" href="Data.Nat.Solver.html#10525" class="Bound">r</a><a id="10526" class="Symbol">)</a> <a id="10528" href="Data.Nat.Solver.html#2100" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a> <a id="10534" class="Symbol">(</a><a id="10535" href="Data.Nat.Solver.html#10535" class="Bound">x₀</a> <a id="10538" href="1Lab.Reflection.html#1853" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="10540" href="Data.Nat.Solver.html#10540" class="Bound">env</a><a id="10543" class="Symbol">)</a> <a id="10545" class="Symbol">=</a>
  <a id="10549" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="10551" href="Data.Nat.Solver.html#10519" class="Bound">p</a> <a id="10553" href="Data.Nat.Solver.html#6292" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="10556" href="Data.Nat.Solver.html#2100" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a> <a id="10562" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="10565" class="Symbol">(</a><a id="10566" href="Data.Nat.Solver.html#10535" class="Bound">x₀</a> <a id="10569" href="1Lab.Reflection.html#1853" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="10571" href="Data.Nat.Solver.html#10540" class="Bound">env</a><a id="10574" class="Symbol">)</a> <a id="10576" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="10578" href="Data.Nat.Solver.html#10535" class="Bound">x₀</a> <a id="10581" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="10583" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="10585" href="Data.Nat.Solver.html#5120" data-type="Poly Nat n" class="Function">0ₚ</a> <a id="10588" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="10591" href="Data.Nat.Solver.html#10540" class="Bound">env</a> <a id="10595" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="10598" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="10602" class="Symbol">(λ</a> <a id="10605" href="Data.Nat.Solver.html#10605" class="Bound">ϕ</a> <a id="10607" href="Data.Nat.Solver.html#10607" class="Bound">ψ</a> <a id="10609" class="Symbol">→</a> <a id="10611" href="Data.Nat.Solver.html#10605" class="Bound">ϕ</a> <a id="10613" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="10615" href="Data.Nat.Solver.html#10535" class="Bound">x₀</a> <a id="10618" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="10620" href="Data.Nat.Solver.html#10607" class="Bound">ψ</a><a id="10621" class="Symbol">)</a> <a id="10623" class="Symbol">(</a><a id="10624" href="Data.Nat.Solver.html#10135" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p *ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env * ⟦ q ⟧ₚ env" class="Function">sound-*ₚ</a> <a id="10633" href="Data.Nat.Solver.html#10519" class="Bound">p</a> <a id="10635" href="Data.Nat.Solver.html#2100" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a> <a id="10641" class="Symbol">(</a><a id="10642" href="Data.Nat.Solver.html#10535" class="Bound">x₀</a> <a id="10645" href="1Lab.Reflection.html#1853" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="10647" href="Data.Nat.Solver.html#10540" class="Bound">env</a><a id="10650" class="Symbol">))</a> <a id="10653" class="Symbol">(</a><a id="10654" href="Data.Nat.Solver.html#7984" data-type="(env : Vec Nat n) → ⟦ 0ₚ ⟧ₚ env ≡ 0" class="Function">sound-0ₚ</a> <a id="10663" href="Data.Nat.Solver.html#10540" class="Bound">env</a><a id="10666" class="Symbol">)</a> <a id="10668" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="10672" href="Data.Nat.Solver.html#10877" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="10676" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="10678" class="Number">0</a> <a id="10680" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="10682" href="Data.Nat.Solver.html#10535" class="Bound">x₀</a> <a id="10685" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="10687" class="Number">0</a>                              <a id="10718" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="10721" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="10724" class="Symbol">(λ</a> <a id="10727" href="Data.Nat.Solver.html#10727" class="Bound">ϕ</a> <a id="10729" class="Symbol">→</a> <a id="10731" class="Symbol">(</a><a id="10732" href="Data.Nat.Solver.html#10727" class="Bound">ϕ</a> <a id="10734" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="10736" href="Data.Nat.Solver.html#10535" class="Bound">x₀</a><a id="10738" class="Symbol">)</a> <a id="10740" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="10742" class="Number">0</a><a id="10743" class="Symbol">)</a> <a id="10745" class="Symbol">(</a><a id="10746" href="Data.Nat.Properties.html#2122" data-type="(x : Nat) → x * 0 ≡ 0" class="Function">*-zeror</a> <a id="10754" href="Data.Nat.Solver.html#10877" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a><a id="10757" class="Symbol">)</a> <a id="10759" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="10763" class="Number">0</a>                                             <a id="10809" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="10813" href="Data.Nat.Properties.html#2122" data-type="(x : Nat) → x * 0 ≡ 0" class="Function">*-zeror</a> <a id="10821" class="Symbol">(</a><a id="10822" href="Data.Nat.Solver.html#10877" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="10826" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="10828" href="Data.Nat.Solver.html#10535" class="Bound">x₀</a> <a id="10831" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="10833" href="Data.Nat.Solver.html#10905" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a><a id="10836" class="Symbol">)</a> <a id="10838" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
  <a id="10842" class="Symbol">(</a><a id="10843" href="Data.Nat.Solver.html#10877" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="10847" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="10849" href="Data.Nat.Solver.html#10535" class="Bound">x₀</a> <a id="10852" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="10854" href="Data.Nat.Solver.html#10905" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a><a id="10857" class="Symbol">)</a> <a id="10859" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="10861" class="Number">0</a> <a id="10863" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
  <a id="10867" class="Keyword">where</a>
    <a id="10877" href="Data.Nat.Solver.html#10877" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="10881" class="Symbol">=</a> <a id="10883" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="10885" href="Data.Nat.Solver.html#10519" class="Bound">p</a> <a id="10887" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="10890" class="Symbol">(</a><a id="10891" href="Data.Nat.Solver.html#10535" class="Bound">x₀</a> <a id="10894" href="1Lab.Reflection.html#1853" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="10896" href="Data.Nat.Solver.html#10540" class="Bound">env</a><a id="10899" class="Symbol">)</a>
    <a id="10905" href="Data.Nat.Solver.html#10905" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="10909" class="Symbol">=</a> <a id="10911" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="10913" href="Data.Nat.Solver.html#10525" class="Bound">r</a> <a id="10915" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="10918" href="Data.Nat.Solver.html#10540" class="Bound">env</a>
</pre>
<p>However, the case where we need to distribute is not so easy. The consists of repeatedly expanding out the polynomial operations into those on natural numbers, then doing a brutal bit of symbol shuffling. There’s not too much to be gained from dwelling on this, so let’s move on.</p>
<pre class="Agda"><a id="11216" href="Data.Nat.Solver.html#10135" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p *ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env * ⟦ q ⟧ₚ env" class="Function">sound-*ₚ</a> <a id="11225" class="Symbol">(</a><a id="11226" href="Data.Nat.Solver.html#11226" class="Bound">p</a> <a id="11228" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="11232" href="Data.Nat.Solver.html#11232" class="Bound">r</a><a id="11233" class="Symbol">)</a> <a id="11235" class="Symbol">(</a><a id="11236" href="Data.Nat.Solver.html#11236" class="Bound">q</a> <a id="11238" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="11242" href="Data.Nat.Solver.html#11242" class="Bound">s</a><a id="11243" class="Symbol">)</a> <a id="11245" class="Symbol">(</a><a id="11246" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="11249" href="1Lab.Reflection.html#1853" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="11251" href="Data.Nat.Solver.html#11251" class="Bound">env</a><a id="11254" class="Symbol">)</a> <a id="11256" class="Symbol">=</a>
  <a id="11260" href="Data.Nat.Solver.html#12769" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p*⟨qx+s⟩+r*q⟧</a> <a id="11275" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11277" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="11280" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="11282" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="11284" href="Data.Nat.Solver.html#5120" data-type="Poly Nat n" class="Function">0ₚ</a> <a id="11287" href="Data.Nat.Solver.html#5870" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="11290" class="Symbol">(</a><a id="11291" href="Data.Nat.Solver.html#11232" class="Bound">r</a> <a id="11293" href="Data.Nat.Solver.html#6292" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="11296" href="Data.Nat.Solver.html#11242" class="Bound">s</a><a id="11297" class="Symbol">)</a> <a id="11299" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="11302" href="Data.Nat.Solver.html#11251" class="Bound">env</a>                <a id="11321" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="11324" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="11327" class="Symbol">(λ</a> <a id="11330" href="Data.Nat.Solver.html#11330" class="Bound">ϕ</a> <a id="11332" class="Symbol">→</a> <a id="11334" href="Data.Nat.Solver.html#12769" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p*⟨qx+s⟩+r*q⟧</a> <a id="11349" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11351" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="11354" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="11356" href="Data.Nat.Solver.html#11330" class="Bound">ϕ</a><a id="11357" class="Symbol">)</a> <a id="11359" class="Symbol">(</a><a id="11360" href="Data.Nat.Solver.html#8862" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p +ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env + ⟦ q ⟧ₚ env" class="Function">sound-+ₚ</a> <a id="11369" href="Data.Nat.Solver.html#5120" data-type="Poly Nat n" class="Function">0ₚ</a> <a id="11372" class="Symbol">(</a><a id="11373" href="Data.Nat.Solver.html#11232" class="Bound">r</a> <a id="11375" href="Data.Nat.Solver.html#6292" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="11378" href="Data.Nat.Solver.html#11242" class="Bound">s</a><a id="11379" class="Symbol">)</a> <a id="11381" href="Data.Nat.Solver.html#11251" class="Bound">env</a><a id="11384" class="Symbol">)</a> <a id="11386" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="11390" href="Data.Nat.Solver.html#12769" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p*⟨qx+s⟩+r*q⟧</a> <a id="11405" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11407" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="11410" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="11412" class="Symbol">(</a><a id="11413" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="11415" href="Data.Nat.Solver.html#5120" data-type="Poly Nat n" class="Function">0ₚ</a> <a id="11418" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="11421" href="Data.Nat.Solver.html#11251" class="Bound">env</a> <a id="11425" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="11427" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="11429" href="Data.Nat.Solver.html#11232" class="Bound">r</a> <a id="11431" href="Data.Nat.Solver.html#6292" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="11434" href="Data.Nat.Solver.html#11242" class="Bound">s</a> <a id="11436" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="11439" href="Data.Nat.Solver.html#11251" class="Bound">env</a><a id="11442" class="Symbol">)</a>        <a id="11451" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="11454" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="11458" class="Symbol">(λ</a> <a id="11461" href="Data.Nat.Solver.html#11461" class="Bound">ϕ</a> <a id="11463" href="Data.Nat.Solver.html#11463" class="Bound">ψ</a> <a id="11465" class="Symbol">→</a> <a id="11467" href="Data.Nat.Solver.html#12769" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p*⟨qx+s⟩+r*q⟧</a> <a id="11482" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11484" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="11487" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="11489" class="Symbol">(</a><a id="11490" href="Data.Nat.Solver.html#11461" class="Bound">ϕ</a> <a id="11492" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="11494" href="Data.Nat.Solver.html#11463" class="Bound">ψ</a><a id="11495" class="Symbol">))</a> <a id="11498" class="Symbol">(</a><a id="11499" href="Data.Nat.Solver.html#7984" data-type="(env : Vec Nat n) → ⟦ 0ₚ ⟧ₚ env ≡ 0" class="Function">sound-0ₚ</a> <a id="11508" href="Data.Nat.Solver.html#11251" class="Bound">env</a><a id="11511" class="Symbol">)</a> <a id="11513" class="Symbol">(</a><a id="11514" href="Data.Nat.Solver.html#10135" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p *ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env * ⟦ q ⟧ₚ env" class="Function">sound-*ₚ</a> <a id="11523" href="Data.Nat.Solver.html#11232" class="Bound">r</a> <a id="11525" href="Data.Nat.Solver.html#11242" class="Bound">s</a> <a id="11527" href="Data.Nat.Solver.html#11251" class="Bound">env</a><a id="11530" class="Symbol">)</a> <a id="11532" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="11536" href="Data.Nat.Solver.html#12769" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p*⟨qx+s⟩+r*q⟧</a> <a id="11551" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11553" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="11556" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="11558" class="Symbol">(</a><a id="11559" href="Data.Nat.Solver.html#12948" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="11563" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11565" href="Data.Nat.Solver.html#12997" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="11568" class="Symbol">)</a>                            <a id="11597" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="11600" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="11603" class="Symbol">(λ</a> <a id="11606" href="Data.Nat.Solver.html#11606" class="Bound">ϕ</a> <a id="11608" class="Symbol">→</a> <a id="11610" href="Data.Nat.Solver.html#11606" class="Bound">ϕ</a> <a id="11612" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11614" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="11617" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="11619" href="Data.Nat.Solver.html#12948" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="11623" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11625" href="Data.Nat.Solver.html#12997" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="11628" class="Symbol">)</a> <a id="11630" class="Symbol">(</a><a id="11631" href="Data.Nat.Solver.html#8862" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p +ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env + ⟦ q ⟧ₚ env" class="Function">sound-+ₚ</a> <a id="11640" class="Symbol">(</a><a id="11641" href="Data.Nat.Solver.html#11226" class="Bound">p</a> <a id="11643" href="Data.Nat.Solver.html#6292" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="11646" class="Symbol">(</a><a id="11647" href="Data.Nat.Solver.html#11236" class="Bound">q</a> <a id="11649" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="11653" href="Data.Nat.Solver.html#11242" class="Bound">s</a><a id="11654" class="Symbol">))</a> <a id="11657" class="Symbol">(</a><a id="11658" href="Data.Nat.Solver.html#11232" class="Bound">r</a> <a id="11660" href="Data.Nat.Solver.html#6336" data-type="Poly Nat n → Poly Nat (suc n) → Poly Nat (suc n)" class="Function Operator">*ₚ′</a> <a id="11664" href="Data.Nat.Solver.html#11236" class="Bound">q</a><a id="11665" class="Symbol">)</a> <a id="11667" class="Symbol">(</a><a id="11668" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="11671" href="1Lab.Reflection.html#1853" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="11673" href="Data.Nat.Solver.html#11251" class="Bound">env</a><a id="11676" class="Symbol">))</a> <a id="11679" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="11683" class="Symbol">(</a><a id="11684" href="Data.Nat.Solver.html#12836" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p*⟨qx+s⟩⟧</a> <a id="11695" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="11697" href="Data.Nat.Solver.html#12884" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r*q⟧</a><a id="11702" class="Symbol">)</a> <a id="11704" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11706" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="11709" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="11711" href="Data.Nat.Solver.html#12948" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="11715" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11717" href="Data.Nat.Solver.html#12997" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a>                        <a id="11744" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="11747" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="11751" class="Symbol">(λ</a> <a id="11754" href="Data.Nat.Solver.html#11754" class="Bound">ϕ</a> <a id="11756" href="Data.Nat.Solver.html#11756" class="Bound">ψ</a> <a id="11758" class="Symbol">→</a> <a id="11760" class="Symbol">(</a><a id="11761" href="Data.Nat.Solver.html#11754" class="Bound">ϕ</a> <a id="11763" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="11765" href="Data.Nat.Solver.html#11756" class="Bound">ψ</a><a id="11766" class="Symbol">)</a> <a id="11768" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11770" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="11773" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="11775" href="Data.Nat.Solver.html#12948" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="11779" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11781" href="Data.Nat.Solver.html#12997" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="11784" class="Symbol">)</a> <a id="11786" class="Symbol">(</a><a id="11787" href="Data.Nat.Solver.html#10135" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p *ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env * ⟦ q ⟧ₚ env" class="Function">sound-*ₚ</a> <a id="11796" href="Data.Nat.Solver.html#11226" class="Bound">p</a> <a id="11798" class="Symbol">(</a><a id="11799" href="Data.Nat.Solver.html#11236" class="Bound">q</a> <a id="11801" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="11805" href="Data.Nat.Solver.html#11242" class="Bound">s</a><a id="11806" class="Symbol">)</a> <a id="11808" class="Symbol">(</a><a id="11809" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="11812" href="1Lab.Reflection.html#1853" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="11814" href="Data.Nat.Solver.html#11251" class="Bound">env</a><a id="11817" class="Symbol">))</a> <a id="11820" class="Symbol">(</a><a id="11821" href="Data.Nat.Solver.html#10227" data-type="(p : Poly Nat n) (q : Poly Nat (suc n)) (x₀ : Nat)
(env : Vec Nat n) →
⟦ p *ₚ′ q ⟧ₚ (x₀ ∷ env) ≡ ⟦ p ⟧ₚ env * ⟦ q ⟧ₚ (x₀ ∷ env)" class="Function">sound-*ₚ′</a> <a id="11831" href="Data.Nat.Solver.html#11232" class="Bound">r</a> <a id="11833" href="Data.Nat.Solver.html#11236" class="Bound">q</a> <a id="11835" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="11838" href="Data.Nat.Solver.html#11251" class="Bound">env</a><a id="11841" class="Symbol">)</a> <a id="11843" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="11847" class="Symbol">(</a><a id="11848" href="Data.Nat.Solver.html#12920" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="11852" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11854" class="Symbol">(</a><a id="11855" href="Data.Nat.Solver.html#12969" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="11859" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11861" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="11864" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="11866" href="Data.Nat.Solver.html#12997" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="11869" class="Symbol">)</a> <a id="11871" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="11873" href="Data.Nat.Solver.html#12948" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="11877" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11879" href="Data.Nat.Solver.html#12969" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a><a id="11882" class="Symbol">)</a> <a id="11884" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11886" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="11889" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="11891" href="Data.Nat.Solver.html#12948" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="11895" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11897" href="Data.Nat.Solver.html#12997" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a>        <a id="11908" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="11911" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="11914" class="Symbol">(λ</a> <a id="11917" href="Data.Nat.Solver.html#11917" class="Bound">ϕ</a> <a id="11919" class="Symbol">→</a> <a id="11921" href="Data.Nat.Solver.html#11917" class="Bound">ϕ</a> <a id="11923" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="11925" href="Data.Nat.Solver.html#12948" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="11929" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11931" href="Data.Nat.Solver.html#12997" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="11934" class="Symbol">)</a> <a id="11936" class="Symbol">(</a><a id="11937" href="Data.Nat.Properties.html#1218" data-type="(x y z : Nat) → (x + y) * z ≡ x * z + y * z" class="Function">*-distrib-+r</a> <a id="11950" class="Symbol">(</a><a id="11951" href="Data.Nat.Solver.html#12920" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="11955" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11957" class="Symbol">(</a><a id="11958" href="Data.Nat.Solver.html#12969" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="11962" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11964" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="11967" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="11969" href="Data.Nat.Solver.html#12997" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="11972" class="Symbol">))</a> <a id="11975" class="Symbol">(</a><a id="11976" href="Data.Nat.Solver.html#12948" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="11980" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="11982" href="Data.Nat.Solver.html#12969" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a><a id="11985" class="Symbol">)</a> <a id="11987" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a><a id="11989" class="Symbol">)</a> <a id="11991" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="11995" href="Data.Nat.Solver.html#12920" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="11999" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12001" class="Symbol">(</a><a id="12002" href="Data.Nat.Solver.html#12969" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12006" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12008" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="12011" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12013" href="Data.Nat.Solver.html#12997" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12016" class="Symbol">)</a> <a id="12018" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12020" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="12023" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12025" href="Data.Nat.Solver.html#12948" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12029" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12031" href="Data.Nat.Solver.html#12969" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12035" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12037" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="12040" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12042" href="Data.Nat.Solver.html#12948" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12046" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12048" href="Data.Nat.Solver.html#12997" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a>     <a id="12056" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="12059" href="Data.Nat.Properties.html#553" data-type="(x y z : Nat) → x + y + z ≡ x + (y + z)" class="Function">+-associative</a> <a id="12073" class="Symbol">(</a><a id="12074" href="Data.Nat.Solver.html#12920" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="12078" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12080" class="Symbol">(</a><a id="12081" href="Data.Nat.Solver.html#12969" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12085" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12087" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="12090" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12092" href="Data.Nat.Solver.html#12997" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12095" class="Symbol">)</a> <a id="12097" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12099" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a><a id="12101" class="Symbol">)</a> <a id="12103" class="Symbol">(</a><a id="12104" href="Data.Nat.Solver.html#12948" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12108" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12110" href="Data.Nat.Solver.html#12969" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12114" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12116" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a><a id="12118" class="Symbol">)</a> <a id="12120" class="Symbol">(</a><a id="12121" href="Data.Nat.Solver.html#12948" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12125" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12127" href="Data.Nat.Solver.html#12997" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12130" class="Symbol">)</a> <a id="12132" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="12136" href="Data.Nat.Solver.html#12920" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="12140" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12142" class="Symbol">(</a><a id="12143" href="Data.Nat.Solver.html#12969" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12147" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12149" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="12152" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12154" href="Data.Nat.Solver.html#12997" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12157" class="Symbol">)</a> <a id="12159" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12161" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="12164" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12166" class="Symbol">(</a><a id="12167" href="Data.Nat.Solver.html#12948" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12171" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12173" href="Data.Nat.Solver.html#12969" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12177" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12179" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="12182" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12184" href="Data.Nat.Solver.html#12948" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12188" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12190" href="Data.Nat.Solver.html#12997" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12193" class="Symbol">)</a>   <a id="12197" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="12200" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="12203" class="Symbol">(λ</a> <a id="12206" href="Data.Nat.Solver.html#12206" class="Bound">ϕ</a> <a id="12208" class="Symbol">→</a>  <a id="12211" href="Data.Nat.Solver.html#12920" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="12215" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12217" class="Symbol">(</a><a id="12218" href="Data.Nat.Solver.html#12969" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12222" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12224" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="12227" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12229" href="Data.Nat.Solver.html#12997" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12232" class="Symbol">)</a> <a id="12234" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12236" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="12239" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12241" class="Symbol">(</a><a id="12242" href="Data.Nat.Solver.html#12206" class="Bound">ϕ</a> <a id="12244" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12246" href="Data.Nat.Solver.html#12948" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12250" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12252" href="Data.Nat.Solver.html#12997" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12255" class="Symbol">))</a> <a id="12258" class="Symbol">(</a><a id="12259" href="Data.Nat.Properties.html#2667" data-type="(x y z : Nat) → x * y * z ≡ x * (y * z)" class="Function">*-associative</a> <a id="12273" href="Data.Nat.Solver.html#12948" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12277" href="Data.Nat.Solver.html#12969" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12281" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a><a id="12283" class="Symbol">)</a> <a id="12285" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="12289" href="Data.Nat.Solver.html#12920" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="12293" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12295" class="Symbol">(</a><a id="12296" href="Data.Nat.Solver.html#12969" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12300" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12302" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="12305" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12307" href="Data.Nat.Solver.html#12997" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12310" class="Symbol">)</a> <a id="12312" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12314" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="12317" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12319" class="Symbol">(</a><a id="12320" href="Data.Nat.Solver.html#12948" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12324" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12326" class="Symbol">(</a><a id="12327" href="Data.Nat.Solver.html#12969" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12331" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12333" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a><a id="12335" class="Symbol">)</a> <a id="12337" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12339" href="Data.Nat.Solver.html#12948" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12343" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12345" href="Data.Nat.Solver.html#12997" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12348" class="Symbol">)</a> <a id="12350" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="12354" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="12357" class="Symbol">(λ</a> <a id="12360" href="Data.Nat.Solver.html#12360" class="Bound">ϕ</a> <a id="12362" class="Symbol">→</a> <a id="12364" href="Data.Nat.Solver.html#12920" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="12368" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12370" class="Symbol">(</a><a id="12371" href="Data.Nat.Solver.html#12969" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12375" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12377" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="12380" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12382" href="Data.Nat.Solver.html#12997" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12385" class="Symbol">)</a> <a id="12387" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12389" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="12392" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12394" href="Data.Nat.Solver.html#12360" class="Bound">ϕ</a><a id="12395" class="Symbol">)</a> <a id="12397" class="Symbol">(</a><a id="12398" href="Data.Nat.Properties.html#2414" data-type="(x y z : Nat) → z * (x + y) ≡ z * x + z * y" class="Function">*-distrib-+l</a> <a id="12411" class="Symbol">(</a><a id="12412" href="Data.Nat.Solver.html#12969" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12416" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12418" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a><a id="12420" class="Symbol">)</a> <a id="12422" href="Data.Nat.Solver.html#12997" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a> <a id="12426" href="Data.Nat.Solver.html#12948" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a><a id="12429" class="Symbol">)</a> <a id="12431" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
  <a id="12435" href="Data.Nat.Solver.html#12920" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="12439" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12441" class="Symbol">(</a><a id="12442" href="Data.Nat.Solver.html#12969" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12446" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12448" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="12451" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12453" href="Data.Nat.Solver.html#12997" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12456" class="Symbol">)</a> <a id="12458" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12460" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="12463" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12465" href="Data.Nat.Solver.html#12948" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12469" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12471" class="Symbol">(</a><a id="12472" href="Data.Nat.Solver.html#12969" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12476" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12478" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="12481" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12483" href="Data.Nat.Solver.html#12997" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12486" class="Symbol">)</a>         <a id="12496" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="12499" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="12502" class="Symbol">(λ</a> <a id="12505" href="Data.Nat.Solver.html#12505" class="Bound">ϕ</a> <a id="12507" class="Symbol">→</a> <a id="12509" href="Data.Nat.Solver.html#12505" class="Bound">ϕ</a> <a id="12511" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12513" href="Data.Nat.Solver.html#12948" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12517" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12519" class="Symbol">(</a><a id="12520" href="Data.Nat.Solver.html#12969" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12524" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12526" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="12529" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12531" href="Data.Nat.Solver.html#12997" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12534" class="Symbol">))</a> <a id="12537" class="Symbol">(</a><a id="12538" href="Data.Nat.Solver.html#3627" data-type="(x y z : Nat) → x * y * z ≡ x * z * y" class="Function">commute-last</a> <a id="12551" href="Data.Nat.Solver.html#12920" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="12555" class="Symbol">(</a><a id="12556" href="Data.Nat.Solver.html#12969" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12560" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12562" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="12565" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12567" href="Data.Nat.Solver.html#12997" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12570" class="Symbol">)</a> <a id="12572" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a><a id="12574" class="Symbol">)</a> <a id="12576" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="12580" href="Data.Nat.Solver.html#12920" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="12584" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12586" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="12589" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12591" class="Symbol">(</a><a id="12592" href="Data.Nat.Solver.html#12969" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12596" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12598" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="12601" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12603" href="Data.Nat.Solver.html#12997" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12606" class="Symbol">)</a> <a id="12608" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12610" href="Data.Nat.Solver.html#12948" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12614" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12616" class="Symbol">(</a><a id="12617" href="Data.Nat.Solver.html#12969" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12621" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12623" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="12626" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12628" href="Data.Nat.Solver.html#12997" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12631" class="Symbol">)</a>         <a id="12641" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="12645" href="Data.Nat.Properties.html#1218" data-type="(x y z : Nat) → (x + y) * z ≡ x * z + y * z" class="Function">*-distrib-+r</a> <a id="12658" class="Symbol">(</a><a id="12659" href="Data.Nat.Solver.html#12920" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="12663" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12665" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a><a id="12667" class="Symbol">)</a> <a id="12669" href="Data.Nat.Solver.html#12948" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12673" class="Symbol">(</a><a id="12674" href="Data.Nat.Solver.html#12969" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12678" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12680" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="12683" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12685" href="Data.Nat.Solver.html#12997" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12688" class="Symbol">)</a> <a id="12690" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
  <a id="12694" class="Symbol">(</a><a id="12695" href="Data.Nat.Solver.html#12920" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="12699" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12701" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="12704" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12706" href="Data.Nat.Solver.html#12948" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a><a id="12709" class="Symbol">)</a> <a id="12711" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12713" class="Symbol">(</a><a id="12714" href="Data.Nat.Solver.html#12969" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12718" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="12720" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="12723" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="12725" href="Data.Nat.Solver.html#12997" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a><a id="12728" class="Symbol">)</a>                          <a id="12755" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
  <a id="12759" class="Keyword">where</a>
    <a id="12769" href="Data.Nat.Solver.html#12769" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p*⟨qx+s⟩+r*q⟧</a> <a id="12784" class="Symbol">=</a> <a id="12786" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="12788" class="Symbol">(</a><a id="12789" href="Data.Nat.Solver.html#11226" class="Bound">p</a> <a id="12791" href="Data.Nat.Solver.html#6292" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="12794" class="Symbol">(</a><a id="12795" href="Data.Nat.Solver.html#11236" class="Bound">q</a> <a id="12797" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="12801" href="Data.Nat.Solver.html#11242" class="Bound">s</a><a id="12802" class="Symbol">))</a> <a id="12805" href="Data.Nat.Solver.html#5870" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="12808" class="Symbol">(</a><a id="12809" href="Data.Nat.Solver.html#11232" class="Bound">r</a> <a id="12811" href="Data.Nat.Solver.html#6336" data-type="Poly Nat n → Poly Nat (suc n) → Poly Nat (suc n)" class="Function Operator">*ₚ′</a> <a id="12815" href="Data.Nat.Solver.html#11236" class="Bound">q</a><a id="12816" class="Symbol">)</a> <a id="12818" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="12821" class="Symbol">(</a><a id="12822" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="12825" href="1Lab.Reflection.html#1853" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="12827" href="Data.Nat.Solver.html#11251" class="Bound">env</a><a id="12830" class="Symbol">)</a>
    <a id="12836" href="Data.Nat.Solver.html#12836" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p*⟨qx+s⟩⟧</a> <a id="12847" class="Symbol">=</a> <a id="12849" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="12851" href="Data.Nat.Solver.html#11226" class="Bound">p</a> <a id="12853" href="Data.Nat.Solver.html#6292" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="12856" class="Symbol">(</a><a id="12857" href="Data.Nat.Solver.html#11236" class="Bound">q</a> <a id="12859" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="12863" href="Data.Nat.Solver.html#11242" class="Bound">s</a><a id="12864" class="Symbol">)</a> <a id="12866" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="12869" class="Symbol">(</a><a id="12870" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="12873" href="1Lab.Reflection.html#1853" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="12875" href="Data.Nat.Solver.html#11251" class="Bound">env</a><a id="12878" class="Symbol">)</a>
    <a id="12884" href="Data.Nat.Solver.html#12884" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r*q⟧</a> <a id="12890" class="Symbol">=</a> <a id="12892" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="12894" href="Data.Nat.Solver.html#11232" class="Bound">r</a> <a id="12896" href="Data.Nat.Solver.html#6336" data-type="Poly Nat n → Poly Nat (suc n) → Poly Nat (suc n)" class="Function Operator">*ₚ′</a> <a id="12900" href="Data.Nat.Solver.html#11236" class="Bound">q</a> <a id="12902" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="12905" class="Symbol">(</a><a id="12906" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="12909" href="1Lab.Reflection.html#1853" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="12911" href="Data.Nat.Solver.html#11251" class="Bound">env</a><a id="12914" class="Symbol">)</a>
    <a id="12920" href="Data.Nat.Solver.html#12920" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="12924" class="Symbol">=</a> <a id="12926" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="12928" href="Data.Nat.Solver.html#11226" class="Bound">p</a> <a id="12930" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="12933" class="Symbol">(</a><a id="12934" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="12937" href="1Lab.Reflection.html#1853" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="12939" href="Data.Nat.Solver.html#11251" class="Bound">env</a><a id="12942" class="Symbol">)</a>
    <a id="12948" href="Data.Nat.Solver.html#12948" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="12952" class="Symbol">=</a> <a id="12954" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="12956" href="Data.Nat.Solver.html#11232" class="Bound">r</a> <a id="12958" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="12961" href="Data.Nat.Solver.html#11251" class="Bound">env</a>
    <a id="12969" href="Data.Nat.Solver.html#12969" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="12973" class="Symbol">=</a> <a id="12975" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="12977" href="Data.Nat.Solver.html#11236" class="Bound">q</a> <a id="12979" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="12982" class="Symbol">(</a><a id="12983" href="Data.Nat.Solver.html#11246" class="Bound">x₀</a> <a id="12986" href="1Lab.Reflection.html#1853" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="12988" href="Data.Nat.Solver.html#11251" class="Bound">env</a><a id="12991" class="Symbol">)</a>
    <a id="12997" href="Data.Nat.Solver.html#12997" data-type="(p : Poly Nat (suc n)) (r : Poly Nat n) (q : Poly Nat (suc n))
(s : Poly Nat n) (x₀ : Nat) (env : Vec Nat n) →
Nat" class="Function">⟦s⟧</a> <a id="13001" class="Symbol">=</a> <a id="13003" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="13005" href="Data.Nat.Solver.html#11242" class="Bound">s</a> <a id="13007" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="13010" href="Data.Nat.Solver.html#11251" class="Bound">env</a>
</pre>
<p>As a nice pallate cleanser, the proofs for heterogeneous multiplication are nowhere near as bad.</p>
<pre class="Agda"><a id="13125" href="Data.Nat.Solver.html#10227" data-type="(p : Poly Nat n) (q : Poly Nat (suc n)) (x₀ : Nat)
(env : Vec Nat n) →
⟦ p *ₚ′ q ⟧ₚ (x₀ ∷ env) ≡ ⟦ p ⟧ₚ env * ⟦ q ⟧ₚ (x₀ ∷ env)" class="Function">sound-*ₚ′</a> <a id="13135" href="Data.Nat.Solver.html#13135" class="Bound">p</a> <a id="13137" href="Data.Nat.Solver.html#2100" data-type="Poly A (suc n)" class="InductiveConstructor">zerop</a> <a id="13143" href="Data.Nat.Solver.html#13143" class="Bound">x₀</a> <a id="13146" href="Data.Nat.Solver.html#13146" class="Bound">env</a> <a id="13150" class="Symbol">=</a> <a id="13152" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="13156" class="Symbol">(</a><a id="13157" href="Data.Nat.Properties.html#2122" data-type="(x : Nat) → x * 0 ≡ 0" class="Function">*-zeror</a> <a id="13165" class="Symbol">(</a><a id="13166" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="13168" href="Data.Nat.Solver.html#13135" class="Bound">p</a> <a id="13170" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="13173" href="Data.Nat.Solver.html#13146" class="Bound">env</a><a id="13176" class="Symbol">))</a>
<a id="13179" href="Data.Nat.Solver.html#10227" data-type="(p : Poly Nat n) (q : Poly Nat (suc n)) (x₀ : Nat)
(env : Vec Nat n) →
⟦ p *ₚ′ q ⟧ₚ (x₀ ∷ env) ≡ ⟦ p ⟧ₚ env * ⟦ q ⟧ₚ (x₀ ∷ env)" class="Function">sound-*ₚ′</a> <a id="13189" href="Data.Nat.Solver.html#13189" class="Bound">r</a> <a id="13191" class="Symbol">(</a><a id="13192" href="Data.Nat.Solver.html#13192" class="Bound">p</a> <a id="13194" href="Data.Nat.Solver.html#2854" data-type="Poly A (suc n) → Poly A n → Poly A (suc n)" class="InductiveConstructor Operator">*X+</a> <a id="13198" href="Data.Nat.Solver.html#13198" class="Bound">q</a><a id="13199" class="Symbol">)</a> <a id="13201" href="Data.Nat.Solver.html#13201" class="Bound">x₀</a> <a id="13204" href="Data.Nat.Solver.html#13204" class="Bound">env</a> <a id="13208" class="Symbol">=</a>
  <a id="13212" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="13214" href="Data.Nat.Solver.html#13189" class="Bound">r</a> <a id="13216" href="Data.Nat.Solver.html#6336" data-type="Poly Nat n → Poly Nat (suc n) → Poly Nat (suc n)" class="Function Operator">*ₚ′</a> <a id="13220" href="Data.Nat.Solver.html#13192" class="Bound">p</a> <a id="13222" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="13225" class="Symbol">(</a><a id="13226" href="Data.Nat.Solver.html#13201" class="Bound">x₀</a> <a id="13229" href="1Lab.Reflection.html#1853" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="13231" href="Data.Nat.Solver.html#13204" class="Bound">env</a><a id="13234" class="Symbol">)</a> <a id="13236" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13238" href="Data.Nat.Solver.html#13201" class="Bound">x₀</a> <a id="13241" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="13243" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="13245" href="Data.Nat.Solver.html#13189" class="Bound">r</a> <a id="13247" href="Data.Nat.Solver.html#6292" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="13250" href="Data.Nat.Solver.html#13198" class="Bound">q</a> <a id="13252" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="13255" href="Data.Nat.Solver.html#13204" class="Bound">env</a> <a id="13259" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a>  <a id="13263" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="13267" class="Symbol">(λ</a> <a id="13270" href="Data.Nat.Solver.html#13270" class="Bound">ϕ</a> <a id="13272" href="Data.Nat.Solver.html#13272" class="Bound">ψ</a> <a id="13274" class="Symbol">→</a> <a id="13276" href="Data.Nat.Solver.html#13270" class="Bound">ϕ</a> <a id="13278" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13280" href="Data.Nat.Solver.html#13201" class="Bound">x₀</a> <a id="13283" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="13285" href="Data.Nat.Solver.html#13272" class="Bound">ψ</a><a id="13286" class="Symbol">)</a> <a id="13288" class="Symbol">(</a><a id="13289" href="Data.Nat.Solver.html#10227" data-type="(p : Poly Nat n) (q : Poly Nat (suc n)) (x₀ : Nat)
(env : Vec Nat n) →
⟦ p *ₚ′ q ⟧ₚ (x₀ ∷ env) ≡ ⟦ p ⟧ₚ env * ⟦ q ⟧ₚ (x₀ ∷ env)" class="Function">sound-*ₚ′</a> <a id="13299" href="Data.Nat.Solver.html#13189" class="Bound">r</a> <a id="13301" href="Data.Nat.Solver.html#13192" class="Bound">p</a> <a id="13303" href="Data.Nat.Solver.html#13201" class="Bound">x₀</a> <a id="13306" href="Data.Nat.Solver.html#13204" class="Bound">env</a><a id="13309" class="Symbol">)</a> <a id="13311" class="Symbol">(</a><a id="13312" href="Data.Nat.Solver.html#10135" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p *ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env * ⟦ q ⟧ₚ env" class="Function">sound-*ₚ</a> <a id="13321" href="Data.Nat.Solver.html#13189" class="Bound">r</a> <a id="13323" href="Data.Nat.Solver.html#13198" class="Bound">q</a> <a id="13325" href="Data.Nat.Solver.html#13204" class="Bound">env</a><a id="13328" class="Symbol">)</a> <a id="13330" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="13334" href="Data.Nat.Solver.html#13589" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="13338" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13340" href="Data.Nat.Solver.html#13610" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="13344" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13346" href="Data.Nat.Solver.html#13201" class="Bound">x₀</a> <a id="13349" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="13351" href="Data.Nat.Solver.html#13589" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="13355" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13357" href="Data.Nat.Solver.html#13638" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a>                     <a id="13381" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="13384" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="13387" class="Symbol">(λ</a> <a id="13390" href="Data.Nat.Solver.html#13390" class="Bound">ϕ</a> <a id="13392" class="Symbol">→</a> <a id="13394" href="Data.Nat.Solver.html#13390" class="Bound">ϕ</a> <a id="13396" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="13398" href="Data.Nat.Solver.html#13589" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="13402" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13404" href="Data.Nat.Solver.html#13638" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a><a id="13407" class="Symbol">)</a> <a id="13409" class="Symbol">(</a><a id="13410" href="Data.Nat.Properties.html#2667" data-type="(x y z : Nat) → x * y * z ≡ x * (y * z)" class="Function">*-associative</a> <a id="13424" href="Data.Nat.Solver.html#13589" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="13428" href="Data.Nat.Solver.html#13610" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="13432" href="Data.Nat.Solver.html#13201" class="Bound">x₀</a><a id="13434" class="Symbol">)</a> <a id="13436" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="13440" href="Data.Nat.Solver.html#13589" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="13444" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13446" class="Symbol">(</a><a id="13447" href="Data.Nat.Solver.html#13610" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="13451" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13453" href="Data.Nat.Solver.html#13201" class="Bound">x₀</a><a id="13455" class="Symbol">)</a> <a id="13457" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="13459" href="Data.Nat.Solver.html#13589" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="13463" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13465" href="Data.Nat.Solver.html#13638" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a>                   <a id="13487" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="13491" href="Data.Nat.Properties.html#2414" data-type="(x y z : Nat) → z * (x + y) ≡ z * x + z * y" class="Function">*-distrib-+l</a>  <a id="13505" class="Symbol">(</a><a id="13506" href="Data.Nat.Solver.html#13610" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="13510" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13512" href="Data.Nat.Solver.html#13201" class="Bound">x₀</a><a id="13514" class="Symbol">)</a> <a id="13516" href="Data.Nat.Solver.html#13638" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="13520" href="Data.Nat.Solver.html#13589" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="13524" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
  <a id="13528" href="Data.Nat.Solver.html#13589" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="13532" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13534" class="Symbol">(</a><a id="13535" href="Data.Nat.Solver.html#13610" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="13539" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="13541" href="Data.Nat.Solver.html#13201" class="Bound">x₀</a> <a id="13544" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="13546" href="Data.Nat.Solver.html#13638" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a><a id="13549" class="Symbol">)</a>                         <a id="13575" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
  <a id="13579" class="Keyword">where</a>
    <a id="13589" href="Data.Nat.Solver.html#13589" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦r⟧</a> <a id="13593" class="Symbol">=</a> <a id="13595" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="13597" href="Data.Nat.Solver.html#13189" class="Bound">r</a> <a id="13599" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="13602" href="Data.Nat.Solver.html#13204" class="Bound">env</a>
    <a id="13610" href="Data.Nat.Solver.html#13610" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦p⟧</a> <a id="13614" class="Symbol">=</a> <a id="13616" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="13618" href="Data.Nat.Solver.html#13192" class="Bound">p</a> <a id="13620" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="13623" class="Symbol">(</a><a id="13624" href="Data.Nat.Solver.html#13201" class="Bound">x₀</a> <a id="13627" href="1Lab.Reflection.html#1853" data-type="A → Vec A n → Vec A (suc n)" class="InductiveConstructor Operator">∷</a> <a id="13629" href="Data.Nat.Solver.html#13204" class="Bound">env</a><a id="13632" class="Symbol">)</a>
    <a id="13638" href="Data.Nat.Solver.html#13638" data-type="(r : Poly Nat n) (p : Poly Nat (suc n)) (q : Poly Nat n) (x₀ : Nat)
(env : Vec Nat n) →
Nat" class="Function">⟦q⟧</a> <a id="13642" class="Symbol">=</a> <a id="13644" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="13646" href="Data.Nat.Solver.html#13198" class="Bound">q</a> <a id="13648" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="13651" href="Data.Nat.Solver.html#13204" class="Bound">env</a>
</pre>
<p>This concludes phase one of the solver.</p>
<h2 id="evaluation-into-polynomials"><a href="#evaluation-into-polynomials" class="header-link">Evaluation into Polynomials<span class="header-link-emoji">🔗</span></a></h2>
<p>Now that we’ve gotten the first phase of the solver done, let’s move on to expressions in the language of natural numbers. Our first move shall be defining expressions in the equational theory of natural numbers.</p>
<p>However, there is an efficiency problem we need to take care of here. If we naively expand out <span class="Agda"><a href="Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a></span> and <span class="Agda"><a href="Agda.Builtin.Nat.html#528" class="Primitive Operator">_*_</a></span> during reflection, we could end up in a situation where we need to contend with a <em>huge</em> amount of <span class="Agda"><a href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a></span> constructors when large literals get involved. Therefore, we prevent reduction of such functions, but this means this phase of the solver needs to be aware of nat literals.</p>
<p>With that in mind, let’s define our expressions. Note that things that the solver is unable to deal with (for instance, functions that aren’t <span class="Agda"><a href="Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a></span> or <span class="Agda"><a href="Agda.Builtin.Nat.html#528" class="Primitive Operator">_*_</a></span>) are represented as variables, and will be replaced during evaluation.</p>
<pre class="Agda"><a id="14609" class="Keyword">data</a> <a id="Expr"></a><a id="14614" href="Data.Nat.Solver.html#14614" data-type="Nat → Type" class="Datatype">Expr</a> <a id="14619" class="Symbol">:</a> <a id="14621" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="14625" class="Symbol">→</a> <a id="14627" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="14632" class="Keyword">where</a>
  <a id="Expr.‵_"></a><a id="14640" href="Data.Nat.Solver.html#14640" data-type="Fin n → Expr n" class="InductiveConstructor Operator">‵_</a>   <a id="14645" class="Symbol">:</a> <a id="14647" class="Symbol">∀</a> <a id="14649" class="Symbol">{</a><a id="14650" href="Data.Nat.Solver.html#14650" class="Bound">n</a><a id="14651" class="Symbol">}</a> <a id="14653" class="Symbol">→</a> <a id="14655" href="Data.Fin.Base.html#498" data-type="Nat → Type" class="Datatype">Fin</a> <a id="14659" href="Data.Nat.Solver.html#14650" class="Bound">n</a> <a id="14661" class="Symbol">→</a> <a id="14663" href="Data.Nat.Solver.html#14614" data-type="Nat → Type" class="Datatype">Expr</a> <a id="14668" href="Data.Nat.Solver.html#14650" class="Bound">n</a>
  <a id="Expr.‵0"></a><a id="14672" href="Data.Nat.Solver.html#14672" data-type="Expr n" class="InductiveConstructor">‵0</a>   <a id="14677" class="Symbol">:</a> <a id="14679" class="Symbol">∀</a> <a id="14681" class="Symbol">{</a><a id="14682" href="Data.Nat.Solver.html#14682" class="Bound">n</a><a id="14683" class="Symbol">}</a> <a id="14685" class="Symbol">→</a> <a id="14687" href="Data.Nat.Solver.html#14614" data-type="Nat → Type" class="Datatype">Expr</a> <a id="14692" href="Data.Nat.Solver.html#14682" class="Bound">n</a>
  <a id="Expr.‵1+_"></a><a id="14696" href="Data.Nat.Solver.html#14696" data-type="Expr n → Expr n" class="InductiveConstructor Operator">‵1+_</a> <a id="14701" class="Symbol">:</a> <a id="14703" class="Symbol">∀</a> <a id="14705" class="Symbol">{</a><a id="14706" href="Data.Nat.Solver.html#14706" class="Bound">n</a><a id="14707" class="Symbol">}</a> <a id="14709" class="Symbol">→</a> <a id="14711" href="Data.Nat.Solver.html#14614" data-type="Nat → Type" class="Datatype">Expr</a> <a id="14716" href="Data.Nat.Solver.html#14706" class="Bound">n</a> <a id="14718" class="Symbol">→</a> <a id="14720" href="Data.Nat.Solver.html#14614" data-type="Nat → Type" class="Datatype">Expr</a> <a id="14725" href="Data.Nat.Solver.html#14706" class="Bound">n</a>
  <a id="Expr.‵lit"></a><a id="14729" href="Data.Nat.Solver.html#14729" data-type="Nat → Expr n" class="InductiveConstructor">‵lit</a> <a id="14734" class="Symbol">:</a> <a id="14736" class="Symbol">∀</a> <a id="14738" class="Symbol">{</a><a id="14739" href="Data.Nat.Solver.html#14739" class="Bound">n</a><a id="14740" class="Symbol">}</a> <a id="14742" class="Symbol">→</a> <a id="14744" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="14748" class="Symbol">→</a> <a id="14750" href="Data.Nat.Solver.html#14614" data-type="Nat → Type" class="Datatype">Expr</a> <a id="14755" href="Data.Nat.Solver.html#14739" class="Bound">n</a>
  <a id="Expr._‵+_"></a><a id="14759" href="Data.Nat.Solver.html#14759" data-type="Expr n → Expr n → Expr n" class="InductiveConstructor Operator">_‵+_</a> <a id="14764" class="Symbol">:</a> <a id="14766" class="Symbol">∀</a> <a id="14768" class="Symbol">{</a><a id="14769" href="Data.Nat.Solver.html#14769" class="Bound">n</a><a id="14770" class="Symbol">}</a> <a id="14772" class="Symbol">→</a> <a id="14774" href="Data.Nat.Solver.html#14614" data-type="Nat → Type" class="Datatype">Expr</a> <a id="14779" href="Data.Nat.Solver.html#14769" class="Bound">n</a> <a id="14781" class="Symbol">→</a> <a id="14783" href="Data.Nat.Solver.html#14614" data-type="Nat → Type" class="Datatype">Expr</a> <a id="14788" href="Data.Nat.Solver.html#14769" class="Bound">n</a> <a id="14790" class="Symbol">→</a> <a id="14792" href="Data.Nat.Solver.html#14614" data-type="Nat → Type" class="Datatype">Expr</a> <a id="14797" href="Data.Nat.Solver.html#14769" class="Bound">n</a>
  <a id="Expr._‵*_"></a><a id="14801" href="Data.Nat.Solver.html#14801" data-type="Expr n → Expr n → Expr n" class="InductiveConstructor Operator">_‵*_</a> <a id="14806" class="Symbol">:</a> <a id="14808" class="Symbol">∀</a> <a id="14810" class="Symbol">{</a><a id="14811" href="Data.Nat.Solver.html#14811" class="Bound">n</a><a id="14812" class="Symbol">}</a> <a id="14814" class="Symbol">→</a> <a id="14816" href="Data.Nat.Solver.html#14614" data-type="Nat → Type" class="Datatype">Expr</a> <a id="14821" href="Data.Nat.Solver.html#14811" class="Bound">n</a> <a id="14823" class="Symbol">→</a> <a id="14825" href="Data.Nat.Solver.html#14614" data-type="Nat → Type" class="Datatype">Expr</a> <a id="14830" href="Data.Nat.Solver.html#14811" class="Bound">n</a> <a id="14832" class="Symbol">→</a> <a id="14834" href="Data.Nat.Solver.html#14614" data-type="Nat → Type" class="Datatype">Expr</a> <a id="14839" href="Data.Nat.Solver.html#14811" class="Bound">n</a>
</pre>
<p>We also define an interpretation of expressions into functions <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">N</mi><mi>n</mi></msup><mo>→</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}^n \to \mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord"><span class="mord mathbb">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span>.</span></p>
<pre class="Agda"><a id="⟦_⟧ₑ"></a><a id="14950" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦_⟧ₑ</a> <a id="14955" class="Symbol">:</a> <a id="14957" href="Data.Nat.Solver.html#14614" data-type="Nat → Type" class="Datatype">Expr</a> <a id="14962" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a> <a id="14964" class="Symbol">→</a> <a id="14966" href="1Lab.Reflection.html#1791" data-type="Type ℓ → Nat → Type ℓ" class="Datatype">Vec</a> <a id="14970" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="14974" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a> <a id="14976" class="Symbol">→</a> <a id="14978" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a>
<a id="14982" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="14984" href="Data.Nat.Solver.html#14640" data-type="Fin n → Expr n" class="InductiveConstructor Operator">‵</a> <a id="14986" href="Data.Nat.Solver.html#14986" class="Bound">i</a> <a id="14988" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="14991" href="Data.Nat.Solver.html#14991" class="Bound">env</a> <a id="14995" class="Symbol">=</a> <a id="14997" href="Data.Nat.Solver.html#3009" data-type="Vec A n → Fin n → A" class="Function">lookup</a> <a id="15004" href="Data.Nat.Solver.html#14991" class="Bound">env</a> <a id="15008" href="Data.Nat.Solver.html#14986" class="Bound">i</a>
<a id="15010" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="15012" href="Data.Nat.Solver.html#14672" data-type="Expr n" class="InductiveConstructor">‵0</a> <a id="15015" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="15018" href="Data.Nat.Solver.html#15018" class="Bound">env</a> <a id="15022" class="Symbol">=</a> <a id="15024" class="Number">0</a>
<a id="15026" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="15028" href="Data.Nat.Solver.html#14696" data-type="Expr n → Expr n" class="InductiveConstructor Operator">‵1+</a> <a id="15032" href="Data.Nat.Solver.html#15032" class="Bound">e</a> <a id="15034" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="15037" href="Data.Nat.Solver.html#15037" class="Bound">env</a> <a id="15041" class="Symbol">=</a> <a id="15043" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="15047" class="Symbol">(</a><a id="15048" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="15050" href="Data.Nat.Solver.html#15032" class="Bound">e</a> <a id="15052" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="15055" href="Data.Nat.Solver.html#15037" class="Bound">env</a><a id="15058" class="Symbol">)</a>
<a id="15060" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="15062" href="Data.Nat.Solver.html#14729" data-type="Nat → Expr n" class="InductiveConstructor">‵lit</a> <a id="15067" href="Data.Nat.Solver.html#15067" class="Bound">k</a> <a id="15069" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="15072" href="Data.Nat.Solver.html#15072" class="Bound">env</a> <a id="15076" class="Symbol">=</a> <a id="15078" href="Data.Nat.Solver.html#15067" class="Bound">k</a>
<a id="15080" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="15082" href="Data.Nat.Solver.html#15082" class="Bound">e1</a> <a id="15085" href="Data.Nat.Solver.html#14759" data-type="Expr n → Expr n → Expr n" class="InductiveConstructor Operator">‵+</a> <a id="15088" href="Data.Nat.Solver.html#15088" class="Bound">e2</a> <a id="15091" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="15094" href="Data.Nat.Solver.html#15094" class="Bound">env</a> <a id="15098" class="Symbol">=</a> <a id="15100" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="15102" href="Data.Nat.Solver.html#15082" class="Bound">e1</a> <a id="15105" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="15108" href="Data.Nat.Solver.html#15094" class="Bound">env</a> <a id="15112" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="15114" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="15116" href="Data.Nat.Solver.html#15088" class="Bound">e2</a> <a id="15119" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="15122" href="Data.Nat.Solver.html#15094" class="Bound">env</a>
<a id="15126" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="15128" href="Data.Nat.Solver.html#15128" class="Bound">e1</a> <a id="15131" href="Data.Nat.Solver.html#14801" data-type="Expr n → Expr n → Expr n" class="InductiveConstructor Operator">‵*</a> <a id="15134" href="Data.Nat.Solver.html#15134" class="Bound">e2</a> <a id="15137" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="15140" href="Data.Nat.Solver.html#15140" class="Bound">env</a> <a id="15144" class="Symbol">=</a> <a id="15146" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="15148" href="Data.Nat.Solver.html#15128" class="Bound">e1</a> <a id="15151" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="15154" href="Data.Nat.Solver.html#15140" class="Bound">env</a> <a id="15158" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="15160" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="15162" href="Data.Nat.Solver.html#15134" class="Bound">e2</a> <a id="15165" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="15168" href="Data.Nat.Solver.html#15140" class="Bound">env</a>
</pre>
<p>We also define an evaluation of expressions into polynomials. The only thing to note here is the evaluation of quoted <span class="Agda"><a href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a></span> constructors as polynomial addition. This is somewhat inneficient, but in practice we rarely have too many <span class="Agda"><a href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a></span> constructors to deal with, as we handle literals separately.</p>
<pre class="Agda"><a id="↓_"></a><a id="15498" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓_</a> <a id="15501" class="Symbol">:</a> <a id="15503" href="Data.Nat.Solver.html#14614" data-type="Nat → Type" class="Datatype">Expr</a> <a id="15508" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a> <a id="15510" class="Symbol">→</a> <a id="15512" href="Data.Nat.Solver.html#1583" data-type="Type a → Nat → Type a" class="Datatype">Poly</a> <a id="15517" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="15521" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a>
<a id="15523" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="15525" class="Symbol">(</a><a id="15526" href="Data.Nat.Solver.html#14640" data-type="Fin n → Expr n" class="InductiveConstructor Operator">‵</a> <a id="15528" href="Data.Nat.Solver.html#15528" class="Bound">i</a><a id="15529" class="Symbol">)</a> <a id="15531" class="Symbol">=</a> <a id="15533" href="Data.Nat.Solver.html#5606" data-type="Fin n → Poly Nat n" class="Function Operator">X[</a> <a id="15536" href="Data.Nat.Solver.html#15528" class="Bound">i</a> <a id="15538" href="Data.Nat.Solver.html#5606" data-type="Fin n → Poly Nat n" class="Function Operator">]</a>
<a id="15540" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="15542" href="Data.Nat.Solver.html#14672" data-type="Expr n" class="InductiveConstructor">‵0</a> <a id="15545" class="Symbol">=</a> <a id="15547" href="Data.Nat.Solver.html#5120" data-type="Poly Nat n" class="Function">0ₚ</a>
<a id="15550" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="15552" class="Symbol">(</a><a id="15553" href="Data.Nat.Solver.html#14696" data-type="Expr n → Expr n" class="InductiveConstructor Operator">‵1+</a> <a id="15557" href="Data.Nat.Solver.html#15557" class="Bound">e</a><a id="15558" class="Symbol">)</a> <a id="15560" class="Symbol">=</a> <a id="15562" href="Data.Nat.Solver.html#5317" data-type="Nat → Poly Nat n" class="Function">constₚ</a> <a id="15569" class="Number">1</a> <a id="15571" href="Data.Nat.Solver.html#5870" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="15574" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="15576" href="Data.Nat.Solver.html#15557" class="Bound">e</a>
<a id="15578" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="15580" href="Data.Nat.Solver.html#14729" data-type="Nat → Expr n" class="InductiveConstructor">‵lit</a> <a id="15585" href="Data.Nat.Solver.html#15585" class="Bound">k</a> <a id="15587" class="Symbol">=</a> <a id="15589" href="Data.Nat.Solver.html#5317" data-type="Nat → Poly Nat n" class="Function">constₚ</a> <a id="15596" href="Data.Nat.Solver.html#15585" class="Bound">k</a>
<a id="15598" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="15600" class="Symbol">(</a><a id="15601" href="Data.Nat.Solver.html#15601" class="Bound">e₁</a> <a id="15604" href="Data.Nat.Solver.html#14759" data-type="Expr n → Expr n → Expr n" class="InductiveConstructor Operator">‵+</a> <a id="15607" href="Data.Nat.Solver.html#15607" class="Bound">e₂</a><a id="15609" class="Symbol">)</a> <a id="15611" class="Symbol">=</a> <a id="15613" class="Symbol">(</a><a id="15614" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="15616" href="Data.Nat.Solver.html#15601" class="Bound">e₁</a><a id="15618" class="Symbol">)</a> <a id="15620" href="Data.Nat.Solver.html#5870" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="15623" class="Symbol">(</a><a id="15624" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="15626" href="Data.Nat.Solver.html#15607" class="Bound">e₂</a><a id="15628" class="Symbol">)</a>
<a id="15630" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="15632" class="Symbol">(</a><a id="15633" href="Data.Nat.Solver.html#15633" class="Bound">e₁</a> <a id="15636" href="Data.Nat.Solver.html#14801" data-type="Expr n → Expr n → Expr n" class="InductiveConstructor Operator">‵*</a> <a id="15639" href="Data.Nat.Solver.html#15639" class="Bound">e₂</a><a id="15641" class="Symbol">)</a> <a id="15643" class="Symbol">=</a> <a id="15645" class="Symbol">(</a><a id="15646" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="15648" href="Data.Nat.Solver.html#15633" class="Bound">e₁</a><a id="15650" class="Symbol">)</a> <a id="15652" href="Data.Nat.Solver.html#6292" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="15655" class="Symbol">(</a><a id="15656" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="15658" href="Data.Nat.Solver.html#15639" class="Bound">e₂</a><a id="15660" class="Symbol">)</a>
</pre>
<h3 id="soundness-of-evaluation"><a href="#soundness-of-evaluation" class="header-link">Soundness of Evaluation<span class="header-link-emoji">🔗</span></a></h3>
<p>With all of that machinery in place, our final proof shall be to show that evaluating an expression into a polynomial has the same semantics as the original expression. Luckily, most of legwork is done already, and we can sit back and enjoy the fruits of our labor.</p>
<pre class="Agda"><a id="sound"></a><a id="15971" href="Data.Nat.Solver.html#15971" data-type="(e : Expr n) (env : Vec Nat n) → ⟦ ↓ e ⟧ₚ env ≡ ⟦ e ⟧ₑ env" class="Function">sound</a> <a id="15977" class="Symbol">:</a> <a id="15979" class="Symbol">∀</a> <a id="15981" href="Data.Nat.Solver.html#15981" class="Bound">e</a> <a id="15983" class="Symbol">→</a> <a id="15985" class="Symbol">(</a><a id="15986" href="Data.Nat.Solver.html#15986" class="Bound">env</a> <a id="15990" class="Symbol">:</a> <a id="15992" href="1Lab.Reflection.html#1791" data-type="Type ℓ → Nat → Type ℓ" class="Datatype">Vec</a> <a id="15996" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="16000" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a><a id="16001" class="Symbol">)</a> <a id="16003" class="Symbol">→</a> <a id="16005" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="16007" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16009" href="Data.Nat.Solver.html#15981" class="Bound">e</a> <a id="16011" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="16014" href="Data.Nat.Solver.html#15986" class="Bound">env</a> <a id="16018" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="16020" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="16022" href="Data.Nat.Solver.html#15981" class="Bound">e</a> <a id="16024" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="16027" href="Data.Nat.Solver.html#15986" class="Bound">env</a>
<a id="16031" href="Data.Nat.Solver.html#15971" data-type="(e : Expr n) (env : Vec Nat n) → ⟦ ↓ e ⟧ₚ env ≡ ⟦ e ⟧ₑ env" class="Function">sound</a> <a id="16037" class="Symbol">(</a><a id="16038" href="Data.Nat.Solver.html#14640" data-type="Fin n → Expr n" class="InductiveConstructor Operator">‵</a> <a id="16040" href="Data.Nat.Solver.html#16040" class="Bound">i</a><a id="16041" class="Symbol">)</a> <a id="16043" href="Data.Nat.Solver.html#16043" class="Bound">env</a> <a id="16047" class="Symbol">=</a> <a id="16049" href="Data.Nat.Solver.html#8365" data-type="(i : Fin n) (env : Vec Nat n) → ⟦ X[ i ] ⟧ₚ env ≡ lookup env i" class="Function Operator">sound-X[</a> <a id="16058" href="Data.Nat.Solver.html#16040" class="Bound">i</a> <a id="16060" href="Data.Nat.Solver.html#8365" data-type="(i : Fin n) (env : Vec Nat n) → ⟦ X[ i ] ⟧ₚ env ≡ lookup env i" class="Function Operator">]</a> <a id="16062" href="Data.Nat.Solver.html#16043" class="Bound">env</a>
<a id="16066" href="Data.Nat.Solver.html#15971" data-type="(e : Expr n) (env : Vec Nat n) → ⟦ ↓ e ⟧ₚ env ≡ ⟦ e ⟧ₑ env" class="Function">sound</a> <a id="16072" href="Data.Nat.Solver.html#14672" data-type="Expr n" class="InductiveConstructor">‵0</a> <a id="16075" href="Data.Nat.Solver.html#16075" class="Bound">env</a> <a id="16079" class="Symbol">=</a> <a id="16081" href="Data.Nat.Solver.html#7984" data-type="(env : Vec Nat n) → ⟦ 0ₚ ⟧ₚ env ≡ 0" class="Function">sound-0ₚ</a> <a id="16090" href="Data.Nat.Solver.html#16075" class="Bound">env</a>
<a id="16094" href="Data.Nat.Solver.html#15971" data-type="(e : Expr n) (env : Vec Nat n) → ⟦ ↓ e ⟧ₚ env ≡ ⟦ e ⟧ₑ env" class="Function">sound</a> <a id="16100" class="Symbol">(</a><a id="16101" href="Data.Nat.Solver.html#14696" data-type="Expr n → Expr n" class="InductiveConstructor Operator">‵1+</a> <a id="16105" href="Data.Nat.Solver.html#16105" class="Bound">e</a><a id="16106" class="Symbol">)</a> <a id="16108" href="Data.Nat.Solver.html#16108" class="Bound">env</a> <a id="16112" class="Symbol">=</a>
  <a id="16116" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="16118" href="Data.Nat.Solver.html#5317" data-type="Nat → Poly Nat n" class="Function">constₚ</a> <a id="16125" class="Number">1</a> <a id="16127" href="Data.Nat.Solver.html#5870" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="16130" class="Symbol">(</a><a id="16131" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16133" href="Data.Nat.Solver.html#16105" class="Bound">e</a><a id="16134" class="Symbol">)</a> <a id="16136" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="16139" href="Data.Nat.Solver.html#16108" class="Bound">env</a>       <a id="16149" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="16152" href="Data.Nat.Solver.html#8862" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p +ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env + ⟦ q ⟧ₚ env" class="Function">sound-+ₚ</a> <a id="16161" class="Symbol">(</a><a id="16162" href="Data.Nat.Solver.html#5317" data-type="Nat → Poly Nat n" class="Function">constₚ</a> <a id="16169" class="Number">1</a><a id="16170" class="Symbol">)</a> <a id="16172" class="Symbol">(</a><a id="16173" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16175" href="Data.Nat.Solver.html#16105" class="Bound">e</a><a id="16176" class="Symbol">)</a> <a id="16178" href="Data.Nat.Solver.html#16108" class="Bound">env</a> <a id="16182" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="16186" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="16188" href="Data.Nat.Solver.html#5317" data-type="Nat → Poly Nat n" class="Function">constₚ</a> <a id="16195" class="Number">1</a> <a id="16197" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="16200" href="Data.Nat.Solver.html#16108" class="Bound">env</a> <a id="16204" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="16206" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="16208" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16210" href="Data.Nat.Solver.html#16105" class="Bound">e</a> <a id="16212" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="16215" href="Data.Nat.Solver.html#16108" class="Bound">env</a> <a id="16219" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="16222" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="16225" class="Symbol">(λ</a> <a id="16228" href="Data.Nat.Solver.html#16228" class="Bound">ϕ</a> <a id="16230" class="Symbol">→</a> <a id="16232" href="Data.Nat.Solver.html#16228" class="Bound">ϕ</a> <a id="16234" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="16236" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="16238" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16240" href="Data.Nat.Solver.html#16105" class="Bound">e</a> <a id="16242" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="16245" href="Data.Nat.Solver.html#16108" class="Bound">env</a> <a id="16249" class="Symbol">)</a> <a id="16251" class="Symbol">(</a><a id="16252" href="Data.Nat.Solver.html#8136" data-type="(c : Nat) (env : Vec Nat n) → ⟦ constₚ c ⟧ₚ env ≡ c" class="Function">sound-constₚ</a> <a id="16265" class="Number">1</a> <a id="16267" href="Data.Nat.Solver.html#16108" class="Bound">env</a><a id="16270" class="Symbol">)</a> <a id="16272" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="16276" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="16280" class="Symbol">(</a><a id="16281" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="16283" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16285" href="Data.Nat.Solver.html#16105" class="Bound">e</a> <a id="16287" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="16290" href="Data.Nat.Solver.html#16108" class="Bound">env</a><a id="16293" class="Symbol">)</a>               <a id="16309" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="16312" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="16315" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="16319" class="Symbol">(</a><a id="16320" href="Data.Nat.Solver.html#15971" data-type="(e : Expr n) (env : Vec Nat n) → ⟦ ↓ e ⟧ₚ env ≡ ⟦ e ⟧ₑ env" class="Function">sound</a> <a id="16326" href="Data.Nat.Solver.html#16105" class="Bound">e</a> <a id="16328" href="Data.Nat.Solver.html#16108" class="Bound">env</a><a id="16331" class="Symbol">)</a> <a id="16333" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="16337" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="16341" class="Symbol">(</a><a id="16342" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="16344" href="Data.Nat.Solver.html#16105" class="Bound">e</a> <a id="16346" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="16349" href="Data.Nat.Solver.html#16108" class="Bound">env</a><a id="16352" class="Symbol">)</a> <a id="16354" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
<a id="16356" href="Data.Nat.Solver.html#15971" data-type="(e : Expr n) (env : Vec Nat n) → ⟦ ↓ e ⟧ₚ env ≡ ⟦ e ⟧ₑ env" class="Function">sound</a> <a id="16362" class="Symbol">(</a><a id="16363" href="Data.Nat.Solver.html#14729" data-type="Nat → Expr n" class="InductiveConstructor">‵lit</a> <a id="16368" href="Data.Nat.Solver.html#16368" class="Bound">k</a><a id="16369" class="Symbol">)</a> <a id="16371" href="Data.Nat.Solver.html#16371" class="Bound">env</a> <a id="16375" class="Symbol">=</a> <a id="16377" href="Data.Nat.Solver.html#8136" data-type="(c : Nat) (env : Vec Nat n) → ⟦ constₚ c ⟧ₚ env ≡ c" class="Function">sound-constₚ</a> <a id="16390" href="Data.Nat.Solver.html#16368" class="Bound">k</a> <a id="16392" href="Data.Nat.Solver.html#16371" class="Bound">env</a>
<a id="16396" href="Data.Nat.Solver.html#15971" data-type="(e : Expr n) (env : Vec Nat n) → ⟦ ↓ e ⟧ₚ env ≡ ⟦ e ⟧ₑ env" class="Function">sound</a> <a id="16402" class="Symbol">(</a><a id="16403" href="Data.Nat.Solver.html#16403" class="Bound">e₁</a> <a id="16406" href="Data.Nat.Solver.html#14759" data-type="Expr n → Expr n → Expr n" class="InductiveConstructor Operator">‵+</a> <a id="16409" href="Data.Nat.Solver.html#16409" class="Bound">e₂</a><a id="16411" class="Symbol">)</a> <a id="16413" href="Data.Nat.Solver.html#16413" class="Bound">env</a> <a id="16417" class="Symbol">=</a>
  <a id="16421" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="16423" class="Symbol">(</a><a id="16424" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16426" href="Data.Nat.Solver.html#16403" class="Bound">e₁</a><a id="16428" class="Symbol">)</a> <a id="16430" href="Data.Nat.Solver.html#5870" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">+ₚ</a> <a id="16433" class="Symbol">(</a><a id="16434" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16436" href="Data.Nat.Solver.html#16409" class="Bound">e₂</a><a id="16438" class="Symbol">)</a> <a id="16440" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="16443" href="Data.Nat.Solver.html#16413" class="Bound">env</a>     <a id="16451" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="16454" href="Data.Nat.Solver.html#8862" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p +ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env + ⟦ q ⟧ₚ env" class="Function">sound-+ₚ</a> <a id="16463" class="Symbol">(</a><a id="16464" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16466" href="Data.Nat.Solver.html#16403" class="Bound">e₁</a><a id="16468" class="Symbol">)</a> <a id="16470" class="Symbol">(</a><a id="16471" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16473" href="Data.Nat.Solver.html#16409" class="Bound">e₂</a><a id="16475" class="Symbol">)</a> <a id="16477" href="Data.Nat.Solver.html#16413" class="Bound">env</a> <a id="16481" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="16485" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="16487" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16489" href="Data.Nat.Solver.html#16403" class="Bound">e₁</a> <a id="16492" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="16495" href="Data.Nat.Solver.html#16413" class="Bound">env</a> <a id="16499" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="16501" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="16503" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16505" href="Data.Nat.Solver.html#16409" class="Bound">e₂</a> <a id="16508" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="16511" href="Data.Nat.Solver.html#16413" class="Bound">env</a> <a id="16515" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="16518" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="16522" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">_+_</a> <a id="16526" class="Symbol">(</a><a id="16527" href="Data.Nat.Solver.html#15971" data-type="(e : Expr n) (env : Vec Nat n) → ⟦ ↓ e ⟧ₚ env ≡ ⟦ e ⟧ₑ env" class="Function">sound</a> <a id="16533" href="Data.Nat.Solver.html#16403" class="Bound">e₁</a> <a id="16536" href="Data.Nat.Solver.html#16413" class="Bound">env</a><a id="16539" class="Symbol">)</a> <a id="16541" class="Symbol">(</a><a id="16542" href="Data.Nat.Solver.html#15971" data-type="(e : Expr n) (env : Vec Nat n) → ⟦ ↓ e ⟧ₚ env ≡ ⟦ e ⟧ₑ env" class="Function">sound</a> <a id="16548" href="Data.Nat.Solver.html#16409" class="Bound">e₂</a> <a id="16551" href="Data.Nat.Solver.html#16413" class="Bound">env</a><a id="16554" class="Symbol">)</a> <a id="16556" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="16560" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="16562" href="Data.Nat.Solver.html#16403" class="Bound">e₁</a> <a id="16565" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="16568" href="Data.Nat.Solver.html#16413" class="Bound">env</a> <a id="16572" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="16574" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="16576" href="Data.Nat.Solver.html#16409" class="Bound">e₂</a> <a id="16579" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="16582" href="Data.Nat.Solver.html#16413" class="Bound">env</a>     <a id="16590" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
<a id="16592" href="Data.Nat.Solver.html#15971" data-type="(e : Expr n) (env : Vec Nat n) → ⟦ ↓ e ⟧ₚ env ≡ ⟦ e ⟧ₑ env" class="Function">sound</a> <a id="16598" class="Symbol">(</a><a id="16599" href="Data.Nat.Solver.html#16599" class="Bound">e₁</a> <a id="16602" href="Data.Nat.Solver.html#14801" data-type="Expr n → Expr n → Expr n" class="InductiveConstructor Operator">‵*</a> <a id="16605" href="Data.Nat.Solver.html#16605" class="Bound">e₂</a><a id="16607" class="Symbol">)</a> <a id="16609" href="Data.Nat.Solver.html#16609" class="Bound">env</a> <a id="16613" class="Symbol">=</a>
  <a id="16617" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="16619" class="Symbol">(</a><a id="16620" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16622" href="Data.Nat.Solver.html#16599" class="Bound">e₁</a><a id="16624" class="Symbol">)</a> <a id="16626" href="Data.Nat.Solver.html#6292" data-type="Poly Nat n → Poly Nat n → Poly Nat n" class="Function Operator">*ₚ</a> <a id="16629" class="Symbol">(</a><a id="16630" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16632" href="Data.Nat.Solver.html#16605" class="Bound">e₂</a><a id="16634" class="Symbol">)</a> <a id="16636" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="16639" href="Data.Nat.Solver.html#16609" class="Bound">env</a>     <a id="16647" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="16650" href="Data.Nat.Solver.html#10135" data-type="(p q : Poly Nat n) (env : Vec Nat n) →
⟦ p *ₚ q ⟧ₚ env ≡ ⟦ p ⟧ₚ env * ⟦ q ⟧ₚ env" class="Function">sound-*ₚ</a> <a id="16659" class="Symbol">(</a><a id="16660" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16662" href="Data.Nat.Solver.html#16599" class="Bound">e₁</a><a id="16664" class="Symbol">)</a> <a id="16666" class="Symbol">(</a><a id="16667" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16669" href="Data.Nat.Solver.html#16605" class="Bound">e₂</a><a id="16671" class="Symbol">)</a> <a id="16673" href="Data.Nat.Solver.html#16609" class="Bound">env</a> <a id="16677" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="16681" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="16683" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16685" href="Data.Nat.Solver.html#16599" class="Bound">e₁</a> <a id="16688" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="16691" href="Data.Nat.Solver.html#16609" class="Bound">env</a> <a id="16695" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="16697" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="16699" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="16701" href="Data.Nat.Solver.html#16605" class="Bound">e₂</a> <a id="16704" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="16707" href="Data.Nat.Solver.html#16609" class="Bound">env</a> <a id="16711" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="16714" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="16718" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">_*_</a> <a id="16722" class="Symbol">(</a><a id="16723" href="Data.Nat.Solver.html#15971" data-type="(e : Expr n) (env : Vec Nat n) → ⟦ ↓ e ⟧ₚ env ≡ ⟦ e ⟧ₑ env" class="Function">sound</a> <a id="16729" href="Data.Nat.Solver.html#16599" class="Bound">e₁</a> <a id="16732" href="Data.Nat.Solver.html#16609" class="Bound">env</a><a id="16735" class="Symbol">)</a> <a id="16737" class="Symbol">(</a><a id="16738" href="Data.Nat.Solver.html#15971" data-type="(e : Expr n) (env : Vec Nat n) → ⟦ ↓ e ⟧ₚ env ≡ ⟦ e ⟧ₑ env" class="Function">sound</a> <a id="16744" href="Data.Nat.Solver.html#16605" class="Bound">e₂</a> <a id="16747" href="Data.Nat.Solver.html#16609" class="Bound">env</a><a id="16750" class="Symbol">)</a> <a id="16752" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="16756" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="16758" href="Data.Nat.Solver.html#16599" class="Bound">e₁</a> <a id="16761" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="16764" href="Data.Nat.Solver.html#16609" class="Bound">env</a> <a id="16768" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="16770" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="16772" href="Data.Nat.Solver.html#16605" class="Bound">e₂</a> <a id="16775" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="16778" href="Data.Nat.Solver.html#16609" class="Bound">env</a>     <a id="16786" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

</pre>
<p>Now, all we need to do is expose an interface for the reflection portion of the solver. The <code>abstract</code> here is VERY IMPORTANT, as it prevents the proof from unfolding into an enourmous term that kills our compile times.</p>
<pre class="Agda"><a id="17023" class="Keyword">abstract</a>
  <a id="solve"></a><a id="17034" href="Data.Nat.Solver.html#17034" data-type="(e₁ e₂ : Expr n) (env : Vec Nat n) →
⟦ ↓ e₁ ⟧ₚ env ≡ ⟦ ↓ e₂ ⟧ₚ env → ⟦ e₁ ⟧ₑ env ≡ ⟦ e₂ ⟧ₑ env" class="Function">solve</a> <a id="17040" class="Symbol">:</a> <a id="17042" class="Symbol">∀</a> <a id="17044" href="Data.Nat.Solver.html#17044" class="Bound">e₁</a> <a id="17047" href="Data.Nat.Solver.html#17047" class="Bound">e₂</a> <a id="17050" class="Symbol">→</a> <a id="17052" class="Symbol">(</a><a id="17053" href="Data.Nat.Solver.html#17053" class="Bound">env</a> <a id="17057" class="Symbol">:</a> <a id="17059" href="1Lab.Reflection.html#1791" data-type="Type ℓ → Nat → Type ℓ" class="Datatype">Vec</a> <a id="17063" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="17067" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a><a id="17068" class="Symbol">)</a>
             <a id="17083" class="Symbol">→</a> <a id="17085" class="Symbol">(</a><a id="17086" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="17088" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="17090" href="Data.Nat.Solver.html#17044" class="Bound">e₁</a> <a id="17093" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="17096" href="Data.Nat.Solver.html#17053" class="Bound">env</a> <a id="17100" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="17102" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="17104" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="17106" href="Data.Nat.Solver.html#17047" class="Bound">e₂</a> <a id="17109" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="17112" href="Data.Nat.Solver.html#17053" class="Bound">env</a><a id="17115" class="Symbol">)</a>
             <a id="17130" class="Symbol">→</a> <a id="17132" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="17134" href="Data.Nat.Solver.html#17044" class="Bound">e₁</a> <a id="17137" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="17140" href="Data.Nat.Solver.html#17053" class="Bound">env</a> <a id="17144" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="17146" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="17148" href="Data.Nat.Solver.html#17047" class="Bound">e₂</a> <a id="17151" href="Data.Nat.Solver.html#14950" data-type="Expr n → Vec Nat n → Nat" class="Function Operator">⟧ₑ</a> <a id="17154" href="Data.Nat.Solver.html#17053" class="Bound">env</a>
  <a id="17160" href="Data.Nat.Solver.html#17034" data-type="(e₁ e₂ : Expr n) (env : Vec Nat n) →
⟦ ↓ e₁ ⟧ₚ env ≡ ⟦ ↓ e₂ ⟧ₚ env → ⟦ e₁ ⟧ₑ env ≡ ⟦ e₂ ⟧ₑ env" class="Function">solve</a> <a id="17166" href="Data.Nat.Solver.html#17166" class="Bound">e₁</a> <a id="17169" href="Data.Nat.Solver.html#17169" class="Bound">e₂</a> <a id="17172" href="Data.Nat.Solver.html#17172" class="Bound">env</a> <a id="17176" href="Data.Nat.Solver.html#17176" class="Bound">p</a> <a id="17178" class="Symbol">=</a> <a id="17180" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="17184" class="Symbol">(</a><a id="17185" href="Data.Nat.Solver.html#15971" data-type="(e : Expr n) (env : Vec Nat n) → ⟦ ↓ e ⟧ₚ env ≡ ⟦ e ⟧ₑ env" class="Function">sound</a> <a id="17191" href="Data.Nat.Solver.html#17166" class="Bound">e₁</a> <a id="17194" href="Data.Nat.Solver.html#17172" class="Bound">env</a><a id="17197" class="Symbol">)</a> <a id="17199" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="17201" href="Data.Nat.Solver.html#17176" class="Bound">p</a> <a id="17203" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="17205" class="Symbol">(</a><a id="17206" href="Data.Nat.Solver.html#15971" data-type="(e : Expr n) (env : Vec Nat n) → ⟦ ↓ e ⟧ₚ env ≡ ⟦ e ⟧ₑ env" class="Function">sound</a> <a id="17212" href="Data.Nat.Solver.html#17169" class="Bound">e₂</a> <a id="17215" href="Data.Nat.Solver.html#17172" class="Bound">env</a><a id="17218" class="Symbol">)</a>
</pre>
<p>We also expose a function for “simplifying” expressions. In reality this will almost always make the term more complicated, but it’s useful for debugging purposes.</p>
<pre class="Agda"><a id="expand"></a><a id="17398" href="Data.Nat.Solver.html#17398" data-type="Expr n → Vec Nat n → Nat" class="Function">expand</a> <a id="17405" class="Symbol">:</a> <a id="17407" class="Symbol">(</a><a id="17408" href="Data.Nat.Solver.html#17408" class="Bound">e</a> <a id="17410" class="Symbol">:</a> <a id="17412" href="Data.Nat.Solver.html#14614" data-type="Nat → Type" class="Datatype">Expr</a> <a id="17417" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a><a id="17418" class="Symbol">)</a> <a id="17420" class="Symbol">→</a> <a id="17422" class="Symbol">(</a><a id="17423" href="Data.Nat.Solver.html#17423" class="Bound">env</a> <a id="17427" class="Symbol">:</a> <a id="17429" href="1Lab.Reflection.html#1791" data-type="Type ℓ → Nat → Type ℓ" class="Datatype">Vec</a> <a id="17433" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="17437" href="Data.Nat.Solver.html#3000" class="Generalizable">n</a><a id="17438" class="Symbol">)</a> <a id="17440" class="Symbol">→</a> <a id="17442" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a>
<a id="17446" href="Data.Nat.Solver.html#17398" data-type="Expr n → Vec Nat n → Nat" class="Function">expand</a> <a id="17453" href="Data.Nat.Solver.html#17453" class="Bound">e</a> <a id="17455" href="Data.Nat.Solver.html#17455" class="Bound">env</a> <a id="17459" class="Symbol">=</a> <a id="17461" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟦</a> <a id="17463" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓</a> <a id="17465" href="Data.Nat.Solver.html#17453" class="Bound">e</a> <a id="17467" href="Data.Nat.Solver.html#7579" data-type="Poly Nat n → Vec Nat n → Nat" class="Function Operator">⟧ₚ</a> <a id="17470" href="Data.Nat.Solver.html#17455" class="Bound">env</a>
</pre>
<h2 id="reflection"><a href="#reflection" class="header-link">Reflection<span class="header-link-emoji">🔗</span></a></h2>
<p>Now, for the <em>truly</em> difficult part: the reflection interface. We begin by defining some pattern synonyms for expressions we want to reflect into our <span class="Agda"><a href="Data.Nat.Solver.html#14614" class="Datatype">Expr</a></span> type.</p>
<pre class="Agda"><a id="17673" class="Keyword">private</a>  
  <a id="17685" class="Keyword">pattern</a> <a id="nat-lit"></a><a id="17693" href="Data.Nat.Solver.html#17693" class="InductiveConstructor">nat-lit</a> <a id="17701" href="Data.Nat.Solver.html#17762" class="Bound">n</a> <a id="17703" class="Symbol">=</a>
    <a id="17709" href="Agda.Builtin.Reflection.html#4903" data-type="Name → List (Arg Term) → Term" class="InductiveConstructor">def</a> <a id="17713" class="Symbol">(</a><a id="17714" class="Keyword">quote</a> <a id="17720" href="Agda.Builtin.FromNat.html#282" data-type="(r : Number A) (n : Nat) ⦃ _ : Constraint r n ⦄ → A" class="Field">Number.fromNat</a><a id="17734" class="Symbol">)</a> <a id="17736" class="Symbol">(_</a> <a id="17739" href="1Lab.Reflection.html#1329" class="InductiveConstructor Operator">h∷</a> <a id="17742" class="Symbol">_</a> <a id="17744" href="1Lab.Reflection.html#1329" class="InductiveConstructor Operator">h∷</a> <a id="17747" class="Symbol">_</a> <a id="17749" href="1Lab.Reflection.html#1248" class="InductiveConstructor Operator">v∷</a> <a id="17752" class="Symbol">(</a><a id="17753" class="InductiveConstructor">lit</a> <a id="17757" class="Symbol">(</a><a id="17758" href="Agda.Builtin.Reflection.html#4114" data-type="Nat → Literal" class="InductiveConstructor">nat</a> <a id="17762" href="Data.Nat.Solver.html#17762" class="Bound">n</a><a id="17763" class="Symbol">))</a> <a id="17766" href="1Lab.Reflection.html#1248" class="InductiveConstructor Operator">v∷</a> <a id="17769" class="Symbol">_)</a>
  <a id="17774" class="Keyword">pattern</a> <a id="″zero″"></a><a id="17782" href="Data.Nat.Solver.html#17782" class="InductiveConstructor">″zero″</a> <a id="17789" class="Symbol">=</a>
    <a id="17795" class="InductiveConstructor">con</a> <a id="17799" class="Symbol">(</a><a id="17800" class="Keyword">quote</a> <a id="17806" href="Agda.Builtin.Nat.html#210" data-type="Nat" class="InductiveConstructor">zero</a><a id="17810" class="Symbol">)</a> <a id="17812" class="InductiveConstructor">[]</a>
  <a id="17817" class="Keyword">pattern</a> <a id="″suc″"></a><a id="17825" href="Data.Nat.Solver.html#17825" class="InductiveConstructor">″suc″</a> <a id="17831" href="Data.Nat.Solver.html#17856" class="Bound">x</a> <a id="17833" class="Symbol">=</a>
    <a id="17839" class="InductiveConstructor">con</a> <a id="17843" class="Symbol">(</a><a id="17844" class="Keyword">quote</a> <a id="17850" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a><a id="17853" class="Symbol">)</a> <a id="17855" class="Symbol">(</a><a id="17856" href="Data.Nat.Solver.html#17856" class="Bound">x</a> <a id="17858" href="1Lab.Reflection.html#1248" class="InductiveConstructor Operator">v∷</a> <a id="17861" class="InductiveConstructor">[]</a><a id="17863" class="Symbol">)</a>
  <a id="17867" class="Keyword">pattern</a> <a id="_″+″_"></a><a id="17875" href="Data.Nat.Solver.html#17875" class="InductiveConstructor Operator">_″+″_</a> <a id="17881" href="Data.Nat.Solver.html#17908" class="Bound">x</a> <a id="17883" href="Data.Nat.Solver.html#17913" class="Bound">y</a> <a id="17885" class="Symbol">=</a>
    <a id="17891" href="Agda.Builtin.Reflection.html#4903" data-type="Name → List (Arg Term) → Term" class="InductiveConstructor">def</a> <a id="17895" class="Symbol">(</a><a id="17896" class="Keyword">quote</a> <a id="17902" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">_+_</a><a id="17905" class="Symbol">)</a> <a id="17907" class="Symbol">(</a><a id="17908" href="Data.Nat.Solver.html#17908" class="Bound">x</a> <a id="17910" href="1Lab.Reflection.html#1248" class="InductiveConstructor Operator">v∷</a> <a id="17913" href="Data.Nat.Solver.html#17913" class="Bound">y</a> <a id="17915" href="1Lab.Reflection.html#1248" class="InductiveConstructor Operator">v∷</a> <a id="17918" class="Symbol">_)</a>
  <a id="17923" class="Keyword">pattern</a> <a id="_″*″_"></a><a id="17931" href="Data.Nat.Solver.html#17931" class="InductiveConstructor Operator">_″*″_</a> <a id="17937" href="Data.Nat.Solver.html#17964" class="Bound">x</a> <a id="17939" href="Data.Nat.Solver.html#17969" class="Bound">y</a> <a id="17941" class="Symbol">=</a>
    <a id="17947" href="Agda.Builtin.Reflection.html#4903" data-type="Name → List (Arg Term) → Term" class="InductiveConstructor">def</a> <a id="17951" class="Symbol">(</a><a id="17952" class="Keyword">quote</a> <a id="17958" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">_*_</a><a id="17961" class="Symbol">)</a> <a id="17963" class="Symbol">(</a><a id="17964" href="Data.Nat.Solver.html#17964" class="Bound">x</a> <a id="17966" href="1Lab.Reflection.html#1248" class="InductiveConstructor Operator">v∷</a> <a id="17969" href="Data.Nat.Solver.html#17969" class="Bound">y</a> <a id="17971" href="1Lab.Reflection.html#1248" class="InductiveConstructor Operator">v∷</a> <a id="17974" class="Symbol">_)</a>
</pre>
<p>Next, we construct quoted a <span class="Agda"><a href="Data.Nat.Solver.html#14614" class="Datatype">Expr</a></span> from a term, replacing any unknown <span class="Agda"><a href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a></span> nodes with variables. This uses the <code>Variable</code> interface for managing the <code>Fin</code> variables and the environment. A discussion of the internals of this is out of scope of this solver; we have already looked into the abyss too deeply.</p>
<pre class="Agda"><a id="18313" class="Keyword">private</a>
  <a id="build-expr"></a><a id="18323" href="Data.Nat.Solver.html#18323" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="Function">build-expr</a> <a id="18334" class="Symbol">:</a> <a id="18336" href="1Lab.Reflection.Variables.html#1713" data-type="(A : Type a) → Type a" class="Record">Variables</a> <a id="18346" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="18350" class="Symbol">→</a> <a id="18352" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a> <a id="18357" class="Symbol">→</a> <a id="18359" href="Agda.Builtin.Reflection.html#8218" data-type="Type a → Type a" class="Postulate">TC</a> <a id="18362" class="Symbol">(</a><a id="18363" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a> <a id="18368" href="1Lab.Type.html#1846" data-type="Type a → Type b → Type (a ⊔ b)" class="Function Operator">×</a> <a id="18370" href="1Lab.Reflection.Variables.html#1713" data-type="(A : Type a) → Type a" class="Record">Variables</a> <a id="18380" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a><a id="18383" class="Symbol">)</a>
  <a id="18387" href="Data.Nat.Solver.html#18323" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="Function">build-expr</a> <a id="18398" href="Data.Nat.Solver.html#18398" class="Bound">vs</a> <a id="18401" class="Symbol">(</a><a id="18402" href="Data.Nat.Solver.html#17693" class="InductiveConstructor">nat-lit</a> <a id="18410" href="Data.Nat.Solver.html#18410" class="Bound">n</a><a id="18411" class="Symbol">)</a> <a id="18413" class="Symbol">=</a> <a id="18415" class="Keyword">do</a>
    <a id="18422" href="Data.Nat.Solver.html#18422" class="Bound">‵n</a> <a id="18425" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="18427" href="Agda.Builtin.Reflection.html#8705" data-type="A → TC Term" class="Postulate">quoteTC</a> <a id="18435" href="Data.Nat.Solver.html#18410" class="Bound">n</a>
    <a id="18441" href="Agda.Builtin.Reflection.html#8261" data-type="A → TC A" class="Postulate">returnTC</a> <a id="18450" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="18452" href="Agda.Builtin.Reflection.html#4846" data-type="Name → List (Arg Term) → Term" class="InductiveConstructor">con</a> <a id="18456" class="Symbol">(</a><a id="18457" class="Keyword">quote</a> <a id="18463" href="Data.Nat.Solver.html#14729" data-type="Nat → Expr n" class="InductiveConstructor">‵lit</a><a id="18467" class="Symbol">)</a> <a id="18469" class="Symbol">(</a><a id="18470" href="Data.Nat.Solver.html#18422" class="Bound">‵n</a> <a id="18473" href="1Lab.Reflection.html#1248" class="InductiveConstructor Operator">v∷</a> <a id="18476" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a><a id="18478" class="Symbol">)</a> <a id="18480" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="18482" href="Data.Nat.Solver.html#18398" class="Bound">vs</a>
  <a id="18487" href="Data.Nat.Solver.html#18323" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="Function">build-expr</a> <a id="18498" href="Data.Nat.Solver.html#18498" class="Bound">vs</a> <a id="18501" href="Data.Nat.Solver.html#17782" class="InductiveConstructor">″zero″</a> <a id="18508" class="Symbol">=</a> <a id="18510" class="Keyword">do</a>
    <a id="18517" href="Agda.Builtin.Reflection.html#8261" data-type="A → TC A" class="Postulate">returnTC</a> <a id="18526" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="18528" href="Agda.Builtin.Reflection.html#4846" data-type="Name → List (Arg Term) → Term" class="InductiveConstructor">con</a> <a id="18532" class="Symbol">(</a><a id="18533" class="Keyword">quote</a> <a id="18539" href="Data.Nat.Solver.html#14672" data-type="Expr n" class="InductiveConstructor">‵0</a><a id="18541" class="Symbol">)</a> <a id="18543" class="Symbol">(</a><a id="18544" href="Agda.Builtin.Reflection.html#5246" data-type="Term" class="InductiveConstructor">unknown</a> <a id="18552" href="1Lab.Reflection.html#1329" class="InductiveConstructor Operator">h∷</a> <a id="18555" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a><a id="18557" class="Symbol">)</a> <a id="18559" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="18561" href="Data.Nat.Solver.html#18498" class="Bound">vs</a>
  <a id="18566" href="Data.Nat.Solver.html#18323" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="Function">build-expr</a> <a id="18577" href="Data.Nat.Solver.html#18577" class="Bound">vs</a> <a id="18580" class="Symbol">(</a><a id="18581" href="Data.Nat.Solver.html#17825" class="InductiveConstructor">″suc″</a> <a id="18587" href="Data.Nat.Solver.html#18587" class="Bound">t</a><a id="18588" class="Symbol">)</a> <a id="18590" class="Symbol">=</a> <a id="18592" class="Keyword">do</a>
    <a id="18599" href="Data.Nat.Solver.html#18599" class="Bound">e</a> <a id="18601" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="18603" href="Data.Nat.Solver.html#18603" class="Bound">vs</a> <a id="18606" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="18608" href="Data.Nat.Solver.html#18323" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="Function">build-expr</a> <a id="18619" href="Data.Nat.Solver.html#18577" class="Bound">vs</a> <a id="18622" href="Data.Nat.Solver.html#18587" class="Bound">t</a>
    <a id="18628" href="Agda.Builtin.Reflection.html#8261" data-type="A → TC A" class="Postulate">returnTC</a> <a id="18637" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="18639" href="Agda.Builtin.Reflection.html#4846" data-type="Name → List (Arg Term) → Term" class="InductiveConstructor">con</a> <a id="18643" class="Symbol">(</a><a id="18644" class="Keyword">quote</a> <a id="18650" href="Data.Nat.Solver.html#14696" data-type="Expr n → Expr n" class="InductiveConstructor Operator">‵1+_</a><a id="18654" class="Symbol">)</a> <a id="18656" class="Symbol">(</a><a id="18657" href="Agda.Builtin.Reflection.html#5246" data-type="Term" class="InductiveConstructor">unknown</a> <a id="18665" href="1Lab.Reflection.html#1329" class="InductiveConstructor Operator">h∷</a> <a id="18668" href="Data.Nat.Solver.html#18599" class="Bound">e</a> <a id="18670" href="1Lab.Reflection.html#1248" class="InductiveConstructor Operator">v∷</a> <a id="18673" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a><a id="18675" class="Symbol">)</a> <a id="18677" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="18679" href="Data.Nat.Solver.html#18603" class="Bound">vs</a>
  <a id="18684" href="Data.Nat.Solver.html#18323" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="Function">build-expr</a> <a id="18695" href="Data.Nat.Solver.html#18695" class="Bound">vs</a> <a id="18698" class="Symbol">(</a><a id="18699" href="Data.Nat.Solver.html#18699" class="Bound">t₁</a> <a id="18702" href="Data.Nat.Solver.html#17875" class="InductiveConstructor Operator">″+″</a> <a id="18706" href="Data.Nat.Solver.html#18706" class="Bound">t₂</a><a id="18708" class="Symbol">)</a> <a id="18710" class="Symbol">=</a> <a id="18712" class="Keyword">do</a>
    <a id="18719" href="Data.Nat.Solver.html#18719" class="Bound">e₁</a> <a id="18722" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="18724" href="Data.Nat.Solver.html#18724" class="Bound">vs</a> <a id="18727" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="18729" href="Data.Nat.Solver.html#18323" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="Function">build-expr</a> <a id="18740" href="Data.Nat.Solver.html#18695" class="Bound">vs</a> <a id="18743" href="Data.Nat.Solver.html#18699" class="Bound">t₁</a>
    <a id="18750" href="Data.Nat.Solver.html#18750" class="Bound">e₂</a> <a id="18753" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="18755" href="Data.Nat.Solver.html#18755" class="Bound">vs</a> <a id="18758" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="18760" href="Data.Nat.Solver.html#18323" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="Function">build-expr</a> <a id="18771" href="Data.Nat.Solver.html#18724" class="Bound">vs</a> <a id="18774" href="Data.Nat.Solver.html#18706" class="Bound">t₂</a>
    <a id="18781" href="Agda.Builtin.Reflection.html#8261" data-type="A → TC A" class="Postulate">returnTC</a> <a id="18790" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="18792" href="Agda.Builtin.Reflection.html#4846" data-type="Name → List (Arg Term) → Term" class="InductiveConstructor">con</a> <a id="18796" class="Symbol">(</a><a id="18797" class="Keyword">quote</a> <a id="18803" href="Data.Nat.Solver.html#14759" data-type="Expr n → Expr n → Expr n" class="InductiveConstructor Operator">_‵+_</a><a id="18807" class="Symbol">)</a> <a id="18809" class="Symbol">(</a><a id="18810" href="Agda.Builtin.Reflection.html#5246" data-type="Term" class="InductiveConstructor">unknown</a> <a id="18818" href="1Lab.Reflection.html#1329" class="InductiveConstructor Operator">h∷</a> <a id="18821" href="Data.Nat.Solver.html#18719" class="Bound">e₁</a> <a id="18824" href="1Lab.Reflection.html#1248" class="InductiveConstructor Operator">v∷</a> <a id="18827" href="Data.Nat.Solver.html#18750" class="Bound">e₂</a> <a id="18830" href="1Lab.Reflection.html#1248" class="InductiveConstructor Operator">v∷</a> <a id="18833" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a><a id="18835" class="Symbol">)</a> <a id="18837" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="18839" href="Data.Nat.Solver.html#18755" class="Bound">vs</a>
  <a id="18844" href="Data.Nat.Solver.html#18323" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="Function">build-expr</a> <a id="18855" href="Data.Nat.Solver.html#18855" class="Bound">vs</a> <a id="18858" class="Symbol">(</a><a id="18859" href="Data.Nat.Solver.html#18859" class="Bound">t₁</a> <a id="18862" href="Data.Nat.Solver.html#17931" class="InductiveConstructor Operator">″*″</a> <a id="18866" href="Data.Nat.Solver.html#18866" class="Bound">t₂</a><a id="18868" class="Symbol">)</a> <a id="18870" class="Symbol">=</a> <a id="18872" class="Keyword">do</a>
    <a id="18879" href="Data.Nat.Solver.html#18879" class="Bound">e₁</a> <a id="18882" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="18884" href="Data.Nat.Solver.html#18884" class="Bound">vs</a> <a id="18887" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="18889" href="Data.Nat.Solver.html#18323" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="Function">build-expr</a> <a id="18900" href="Data.Nat.Solver.html#18855" class="Bound">vs</a> <a id="18903" href="Data.Nat.Solver.html#18859" class="Bound">t₁</a>
    <a id="18910" href="Data.Nat.Solver.html#18910" class="Bound">e₂</a> <a id="18913" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="18915" href="Data.Nat.Solver.html#18915" class="Bound">vs</a> <a id="18918" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="18920" href="Data.Nat.Solver.html#18323" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="Function">build-expr</a> <a id="18931" href="Data.Nat.Solver.html#18884" class="Bound">vs</a> <a id="18934" href="Data.Nat.Solver.html#18866" class="Bound">t₂</a>
    <a id="18941" href="Agda.Builtin.Reflection.html#8261" data-type="A → TC A" class="Postulate">returnTC</a> <a id="18950" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="18952" href="Agda.Builtin.Reflection.html#4846" data-type="Name → List (Arg Term) → Term" class="InductiveConstructor">con</a> <a id="18956" class="Symbol">(</a><a id="18957" class="Keyword">quote</a> <a id="18963" href="Data.Nat.Solver.html#14801" data-type="Expr n → Expr n → Expr n" class="InductiveConstructor Operator">_‵*_</a><a id="18967" class="Symbol">)</a> <a id="18969" class="Symbol">(</a><a id="18970" href="Agda.Builtin.Reflection.html#5246" data-type="Term" class="InductiveConstructor">unknown</a> <a id="18978" href="1Lab.Reflection.html#1329" class="InductiveConstructor Operator">h∷</a> <a id="18981" href="Data.Nat.Solver.html#18879" class="Bound">e₁</a> <a id="18984" href="1Lab.Reflection.html#1248" class="InductiveConstructor Operator">v∷</a> <a id="18987" href="Data.Nat.Solver.html#18910" class="Bound">e₂</a> <a id="18990" href="1Lab.Reflection.html#1248" class="InductiveConstructor Operator">v∷</a> <a id="18993" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a><a id="18995" class="Symbol">)</a> <a id="18997" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="18999" href="Data.Nat.Solver.html#18915" class="Bound">vs</a>
  <a id="19004" href="Data.Nat.Solver.html#18323" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="CatchallClause Function">build-expr</a><a id="19014" class="CatchallClause"> </a><a id="19015" href="Data.Nat.Solver.html#19015" class="CatchallClause Bound">vs</a><a id="19017" class="CatchallClause"> </a><a id="19018" href="Data.Nat.Solver.html#19018" class="CatchallClause Bound">tm</a> <a id="19021" class="Symbol">=</a> <a id="19023" class="Keyword">do</a>
    <a id="19030" class="Symbol">(</a><a id="19031" href="Data.Nat.Solver.html#19031" class="Bound">v</a> <a id="19033" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19035" href="Data.Nat.Solver.html#19035" class="Bound">vs′</a><a id="19038" class="Symbol">)</a> <a id="19040" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="19042" href="1Lab.Reflection.Variables.html#2967" data-type="Variables A → Term → TC (Term × Variables A)" class="Function">bind-var</a> <a id="19051" href="Data.Nat.Solver.html#19015" class="Bound">vs</a> <a id="19054" href="Data.Nat.Solver.html#19018" class="Bound">tm</a> 
    <a id="19062" href="Agda.Builtin.Reflection.html#8261" data-type="A → TC A" class="Postulate">returnTC</a> <a id="19071" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="19073" href="Agda.Builtin.Reflection.html#4846" data-type="Name → List (Arg Term) → Term" class="InductiveConstructor">con</a> <a id="19077" class="Symbol">(</a><a id="19078" class="Keyword">quote</a> <a id="19084" href="Data.Nat.Solver.html#14640" data-type="Fin n → Expr n" class="InductiveConstructor Operator">‵_</a><a id="19086" class="Symbol">)</a> <a id="19088" class="Symbol">(</a><a id="19089" href="Data.Nat.Solver.html#19031" class="Bound">v</a> <a id="19091" href="1Lab.Reflection.html#1248" class="InductiveConstructor Operator">v∷</a> <a id="19094" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a><a id="19096" class="Symbol">)</a> <a id="19098" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19100" href="Data.Nat.Solver.html#19035" class="Bound">vs′</a>
</pre>
<p>Next, a quick helper for getting the endpoints of an equality.</p>
<pre class="Agda"><a id="19181" class="Keyword">private</a>
  <a id="getBoundary"></a><a id="19191" href="Data.Nat.Solver.html#19191" data-type="Term → TC (Maybe (Term × Term))" class="Function">getBoundary</a> <a id="19203" class="Symbol">:</a> <a id="19205" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a> <a id="19210" class="Symbol">→</a> <a id="19212" href="Agda.Builtin.Reflection.html#8218" data-type="Type a → Type a" class="Postulate">TC</a> <a id="19215" class="Symbol">(</a><a id="19216" href="Agda.Builtin.Maybe.html#136" data-type="Type a → Type a" class="Datatype">Maybe</a> <a id="19222" class="Symbol">(</a><a id="19223" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a> <a id="19228" href="1Lab.Type.html#1846" data-type="Type a → Type b → Type (a ⊔ b)" class="Function Operator">×</a> <a id="19230" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a><a id="19234" class="Symbol">))</a>
  <a id="19239" href="Data.Nat.Solver.html#19191" data-type="Term → TC (Maybe (Term × Term))" class="Function">getBoundary</a> <a id="19251" href="Data.Nat.Solver.html#19251" class="Bound">tm</a><a id="19253" class="Symbol">@(</a><a id="19255" href="Agda.Builtin.Reflection.html#4903" data-type="Name → List (Arg Term) → Term" class="InductiveConstructor">def</a> <a id="19259" class="Symbol">(</a><a id="19260" class="Keyword">quote</a> <a id="19266" href="Agda.Builtin.Cubical.Path.html#190" data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" class="Postulate">PathP</a><a id="19271" class="Symbol">)</a> <a id="19273" class="Symbol">(_</a> <a id="19276" href="1Lab.Reflection.html#1329" class="InductiveConstructor Operator">h∷</a> <a id="19279" href="Data.Nat.Solver.html#19279" class="Bound">T</a> <a id="19281" href="1Lab.Reflection.html#1248" class="InductiveConstructor Operator">v∷</a> <a id="19284" href="Data.Nat.Solver.html#19284" class="Bound">x</a> <a id="19286" href="1Lab.Reflection.html#1248" class="InductiveConstructor Operator">v∷</a> <a id="19289" href="Data.Nat.Solver.html#19289" class="Bound">y</a> <a id="19291" href="1Lab.Reflection.html#1248" class="InductiveConstructor Operator">v∷</a> <a id="19294" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a><a id="19296" class="Symbol">))</a> <a id="19299" class="Symbol">=</a> <a id="19301" class="Keyword">do</a>
    <a id="19308" href="Agda.Builtin.Reflection.html#8391" data-type="Term → Term → TC ⊤" class="Postulate">unify</a> <a id="19314" href="Data.Nat.Solver.html#19251" class="Bound">tm</a> <a id="19317" class="Symbol">(</a><a id="19318" href="Agda.Builtin.Reflection.html#4903" data-type="Name → List (Arg Term) → Term" class="InductiveConstructor">def</a> <a id="19322" class="Symbol">(</a><a id="19323" class="Keyword">quote</a> <a id="19329" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">_≡_</a><a id="19332" class="Symbol">)</a> <a id="19334" class="Symbol">(</a><a id="19335" href="Data.Nat.Solver.html#19284" class="Bound">x</a> <a id="19337" href="1Lab.Reflection.html#1248" class="InductiveConstructor Operator">v∷</a> <a id="19340" href="Data.Nat.Solver.html#19289" class="Bound">y</a> <a id="19342" href="1Lab.Reflection.html#1248" class="InductiveConstructor Operator">v∷</a> <a id="19345" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a><a id="19347" class="Symbol">))</a>
    <a id="19354" href="Agda.Builtin.Reflection.html#8261" data-type="A → TC A" class="Postulate">returnTC</a> <a id="19363" class="Symbol">(</a><a id="19364" href="Agda.Builtin.Maybe.html#174" data-type="A → Maybe A" class="InductiveConstructor">just</a> <a id="19369" class="Symbol">(</a><a id="19370" href="Data.Nat.Solver.html#19284" class="Bound">x</a> <a id="19372" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="19374" href="Data.Nat.Solver.html#19289" class="Bound">y</a><a id="19375" class="Symbol">))</a>
  <a id="19380" href="Data.Nat.Solver.html#19191" data-type="Term → TC (Maybe (Term × Term))" class="Function">getBoundary</a> <a id="19392" class="Symbol">(</a><a id="19393" href="Agda.Builtin.Reflection.html#5196" data-type="Meta → List (Arg Term) → Term" class="InductiveConstructor">meta</a> <a id="19398" href="Data.Nat.Solver.html#19398" class="Bound">m</a> <a id="19400" class="Symbol">_)</a> <a id="19403" class="Symbol">=</a> <a id="19405" href="Agda.Builtin.Reflection.html#9287" data-type="Meta → TC A" class="Postulate">blockOnMeta</a> <a id="19417" href="Data.Nat.Solver.html#19398" class="Bound">m</a>
  <a id="19421" href="Data.Nat.Solver.html#19191" data-type="Term → TC (Maybe (Term × Term))" class="CatchallClause Function">getBoundary</a><a id="19432" class="CatchallClause"> </a><a id="19433" class="CatchallClause Symbol">_</a> <a id="19435" class="Symbol">=</a> <a id="19437" href="Agda.Builtin.Reflection.html#8261" data-type="A → TC A" class="Postulate">returnTC</a> <a id="19446" href="Agda.Builtin.Maybe.html#195" data-type="Maybe A" class="InductiveConstructor">nothing</a>
</pre>
<p>Next, let’s define the quoted forms of some terms that we will use to interface with the solver.</p>
<pre class="Agda"><a id="19565" class="Keyword">private</a>
  <a id="″expand″"></a><a id="19575" href="Data.Nat.Solver.html#19575" data-type="Term → Term → Term" class="Function">″expand″</a> <a id="19584" class="Symbol">:</a> <a id="19586" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a> <a id="19591" class="Symbol">→</a> <a id="19593" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a> <a id="19598" class="Symbol">→</a> <a id="19600" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a>
  <a id="19607" href="Data.Nat.Solver.html#19575" data-type="Term → Term → Term" class="Function">″expand″</a> <a id="19616" href="Data.Nat.Solver.html#19616" class="Bound">e</a> <a id="19618" href="Data.Nat.Solver.html#19618" class="Bound">env</a> <a id="19622" class="Symbol">=</a> <a id="19624" href="Agda.Builtin.Reflection.html#4903" data-type="Name → List (Arg Term) → Term" class="InductiveConstructor">def</a> <a id="19628" class="Symbol">(</a><a id="19629" class="Keyword">quote</a> <a id="19635" href="Data.Nat.Solver.html#17398" data-type="Expr n → Vec Nat n → Nat" class="Function">expand</a><a id="19641" class="Symbol">)</a> <a id="19643" class="Symbol">(</a><a id="19644" href="Agda.Builtin.Reflection.html#5246" data-type="Term" class="InductiveConstructor">unknown</a> <a id="19652" href="1Lab.Reflection.html#1329" class="InductiveConstructor Operator">h∷</a> <a id="19655" href="Data.Nat.Solver.html#19616" class="Bound">e</a> <a id="19657" href="1Lab.Reflection.html#1248" class="InductiveConstructor Operator">v∷</a> <a id="19660" href="Data.Nat.Solver.html#19618" class="Bound">env</a> <a id="19664" href="1Lab.Reflection.html#1248" class="InductiveConstructor Operator">v∷</a> <a id="19667" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a><a id="19669" class="Symbol">)</a>
  
  <a id="″solve″"></a><a id="19676" href="Data.Nat.Solver.html#19676" data-type="Term → Term → Term → Term" class="Function">″solve″</a> <a id="19684" class="Symbol">:</a> <a id="19686" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a> <a id="19691" class="Symbol">→</a> <a id="19693" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a> <a id="19698" class="Symbol">→</a> <a id="19700" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a> <a id="19705" class="Symbol">→</a> <a id="19707" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a>
  <a id="19714" href="Data.Nat.Solver.html#19676" data-type="Term → Term → Term → Term" class="Function">″solve″</a> <a id="19722" href="Data.Nat.Solver.html#19722" class="Bound">lhs</a> <a id="19726" href="Data.Nat.Solver.html#19726" class="Bound">rhs</a> <a id="19730" href="Data.Nat.Solver.html#19730" class="Bound">env</a> <a id="19734" class="Symbol">=</a>
    <a id="19740" href="Agda.Builtin.Reflection.html#4903" data-type="Name → List (Arg Term) → Term" class="InductiveConstructor">def</a> <a id="19744" class="Symbol">(</a><a id="19745" class="Keyword">quote</a> <a id="19751" href="Data.Nat.Solver.html#17034" data-type="(e₁ e₂ : Expr n) (env : Vec Nat n) →
⟦ ↓ e₁ ⟧ₚ env ≡ ⟦ ↓ e₂ ⟧ₚ env → ⟦ e₁ ⟧ₑ env ≡ ⟦ e₂ ⟧ₑ env" class="Function">solve</a><a id="19756" class="Symbol">)</a>
        <a id="19766" class="Symbol">(</a><a id="19767" href="Agda.Builtin.Reflection.html#5246" data-type="Term" class="InductiveConstructor">unknown</a> <a id="19775" href="1Lab.Reflection.html#1329" class="InductiveConstructor Operator">h∷</a> <a id="19778" href="Data.Nat.Solver.html#19722" class="Bound">lhs</a> <a id="19782" href="1Lab.Reflection.html#1248" class="InductiveConstructor Operator">v∷</a> <a id="19785" href="Data.Nat.Solver.html#19726" class="Bound">rhs</a> <a id="19789" href="1Lab.Reflection.html#1248" class="InductiveConstructor Operator">v∷</a> <a id="19792" href="Data.Nat.Solver.html#19730" class="Bound">env</a> <a id="19796" href="1Lab.Reflection.html#1248" class="InductiveConstructor Operator">v∷</a> <a id="19799" href="Agda.Builtin.Reflection.html#4903" data-type="Name → List (Arg Term) → Term" class="InductiveConstructor">def</a> <a id="19803" class="Symbol">(</a><a id="19804" class="Keyword">quote</a> <a id="19810" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="19814" class="Symbol">)</a> <a id="19816" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a> <a id="19819" href="1Lab.Reflection.html#1248" class="InductiveConstructor Operator">v∷</a> <a id="19822" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a><a id="19824" class="Symbol">)</a>
</pre>
<h3 id="the-actual-macros"><a href="#the-actual-macros" class="header-link">The Actual Macros<span class="header-link-emoji">🔗</span></a></h3>
<p>Now, the actual reflection API calls. In order to keep drawing this file out, we start by defining some useful debugging macros. As we noted a looong time ago, we don’t want to unfold the <span class="Agda"><a href="Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a></span> or <span class="Agda"><a href="Agda.Builtin.Nat.html#528" class="Primitive Operator">_*_</a></span> functions, so let’s make a list of those names so that we can call <span class="Agda"><a href="Agda.Builtin.Reflection.html#10217" class="Postulate">dontReduceDefs</a></span> more easily.</p>
<pre class="Agda"><a id="20185" class="Keyword">private</a>
  <a id="dont-reduce"></a><a id="20195" href="Data.Nat.Solver.html#20195" data-type="List Name" class="Function">dont-reduce</a> <a id="20207" class="Symbol">:</a> <a id="20209" href="Agda.Builtin.List.html#148" data-type="Type a → Type a" class="Datatype">List</a> <a id="20214" href="Agda.Builtin.Reflection.html#489" data-type="Type" class="Postulate">Name</a>
  <a id="20221" href="Data.Nat.Solver.html#20195" data-type="List Name" class="Function">dont-reduce</a> <a id="20233" class="Symbol">=</a> <a id="20235" class="Keyword">quote</a> <a id="20241" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">_+_</a> <a id="20245" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a> <a id="20247" class="Keyword">quote</a> <a id="20253" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">_*_</a> <a id="20257" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a> <a id="20259" class="Keyword">quote</a> <a id="20265" href="Agda.Builtin.FromNat.html#282" data-type="(r : Number A) (n : Nat) ⦃ _ : Constraint r n ⦄ → A" class="Field">Number.fromNat</a> <a id="20280" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a> <a id="20282" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a>
</pre>
<p>The <code>repr!</code> macro prints out a bunch of information about a given expression of type <code>Nat</code>. This is <em>very</em> useful when we are debugging.</p>
<pre class="Agda"><a id="repr-macro"></a><a id="20436" href="Data.Nat.Solver.html#20436" data-type="Nat → Term → TC ⊤" class="Function">repr-macro</a> <a id="20447" class="Symbol">:</a> <a id="20449" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="20453" class="Symbol">→</a> <a id="20455" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a> <a id="20460" class="Symbol">→</a> <a id="20462" href="Agda.Builtin.Reflection.html#8218" data-type="Type a → Type a" class="Postulate">TC</a> <a id="20465" href="Agda.Builtin.Unit.html#164" data-type="Type" class="Record">⊤</a>
<a id="20467" href="Data.Nat.Solver.html#20436" data-type="Nat → Term → TC ⊤" class="Function">repr-macro</a> <a id="20478" href="Data.Nat.Solver.html#20478" class="Bound">n</a> <a id="20480" href="Data.Nat.Solver.html#20480" class="Bound">hole</a> <a id="20485" class="Symbol">=</a>
  <a id="20489" href="Agda.Builtin.Reflection.html#9555" data-type="Bool → TC A → TC A" class="Postulate">withNormalisation</a> <a id="20507" href="Agda.Builtin.Bool.html#182" data-type="Bool" class="InductiveConstructor">false</a> <a id="20513" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a>
  <a id="20517" href="Agda.Builtin.Reflection.html#10217" data-type="List Name → TC A → TC A" class="Postulate">dontReduceDefs</a> <a id="20532" href="Data.Nat.Solver.html#20195" data-type="List Name" class="Function">dont-reduce</a> <a id="20544" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="20546" class="Keyword">do</a>
  <a id="20551" href="Data.Nat.Solver.html#20551" class="Bound">tm</a> <a id="20554" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="20556" href="Agda.Builtin.Reflection.html#8705" data-type="A → TC Term" class="Postulate">quoteTC</a> <a id="20564" href="Data.Nat.Solver.html#20478" class="Bound">n</a>
  <a id="20568" href="Data.Nat.Solver.html#20568" class="Bound">e</a> <a id="20570" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="20572" href="Data.Nat.Solver.html#20572" class="Bound">vs</a> <a id="20575" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="20577" href="Data.Nat.Solver.html#18323" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="Function">build-expr</a> <a id="20588" href="1Lab.Reflection.Variables.html#2026" data-type="Variables A" class="Function">empty-vars</a> <a id="20599" href="Data.Nat.Solver.html#20551" class="Bound">tm</a>
  <a id="20604" href="Data.Nat.Solver.html#20604" class="Bound">size</a> <a id="20609" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="20611" href="Data.Nat.Solver.html#20611" class="Bound">env</a> <a id="20615" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="20617" href="1Lab.Reflection.Variables.html#3280" data-type="Variables A → TC (Term × Term)" class="Function">environment</a> <a id="20629" href="Data.Nat.Solver.html#20572" class="Bound">vs</a>
  <a id="20634" href="Data.Nat.Solver.html#20634" class="Bound">repr</a> <a id="20639" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="20641" href="Agda.Builtin.Reflection.html#8573" data-type="Term → TC Term" class="Postulate">normalise</a> <a id="20651" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="20653" href="Agda.Builtin.Reflection.html#4903" data-type="Name → List (Arg Term) → Term" class="InductiveConstructor">def</a> <a id="20657" class="Symbol">(</a><a id="20658" class="Keyword">quote</a> <a id="20664" href="Data.Nat.Solver.html#15498" data-type="Expr n → Poly Nat n" class="Function Operator">↓_</a><a id="20666" class="Symbol">)</a> <a id="20668" class="Symbol">(</a><a id="20669" href="Data.Nat.Solver.html#20604" class="Bound">size</a> <a id="20674" href="1Lab.Reflection.html#1329" class="InductiveConstructor Operator">h∷</a> <a id="20677" href="Data.Nat.Solver.html#20568" class="Bound">e</a> <a id="20679" href="1Lab.Reflection.html#1248" class="InductiveConstructor Operator">v∷</a> <a id="20682" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a><a id="20684" class="Symbol">)</a>
  <a id="20688" href="Agda.Builtin.Reflection.html#8431" data-type="List ErrorPart → TC A" class="Postulate">typeError</a> <a id="20698" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="20700" href="Agda.Builtin.Reflection.html#7917" data-type="String → ErrorPart" class="InductiveConstructor">strErr</a> <a id="20707" class="String">&quot;The expression\n  &quot;</a> <a id="20728" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a>
                <a id="20746" href="Agda.Builtin.Reflection.html#7948" data-type="Term → ErrorPart" class="InductiveConstructor">termErr</a> <a id="20754" href="Data.Nat.Solver.html#20551" class="Bound">tm</a> <a id="20757" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a>
              <a id="20773" href="Agda.Builtin.Reflection.html#7917" data-type="String → ErrorPart" class="InductiveConstructor">strErr</a> <a id="20780" class="String">&quot;\nIs represented by the expression\n  &quot;</a> <a id="20821" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a>
                <a id="20839" href="Agda.Builtin.Reflection.html#7948" data-type="Term → ErrorPart" class="InductiveConstructor">termErr</a> <a id="20847" href="Data.Nat.Solver.html#20568" class="Bound">e</a> <a id="20849" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a>
              <a id="20865" href="Agda.Builtin.Reflection.html#7917" data-type="String → ErrorPart" class="InductiveConstructor">strErr</a> <a id="20872" class="String">&quot;\nAnd the polynomial\n  &quot;</a> <a id="20899" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a>
                <a id="20917" href="Agda.Builtin.Reflection.html#7948" data-type="Term → ErrorPart" class="InductiveConstructor">termErr</a> <a id="20925" href="Data.Nat.Solver.html#20634" class="Bound">repr</a> <a id="20930" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a>
              <a id="20946" href="Agda.Builtin.Reflection.html#7917" data-type="String → ErrorPart" class="InductiveConstructor">strErr</a> <a id="20953" class="String">&quot;\nThe environment is\n  &quot;</a> <a id="20980" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a>
                <a id="20998" href="Agda.Builtin.Reflection.html#7948" data-type="Term → ErrorPart" class="InductiveConstructor">termErr</a> <a id="21006" href="Data.Nat.Solver.html#20611" class="Bound">env</a> <a id="21010" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a> <a id="21012" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a>
<a id="21015" class="Keyword">macro</a>
  <a id="repr!"></a><a id="21023" href="Data.Nat.Solver.html#21023" data-type="Nat → Term → TC ⊤" class="Function">repr!</a> <a id="21029" class="Symbol">:</a> <a id="21031" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="21035" class="Symbol">→</a> <a id="21037" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a> <a id="21042" class="Symbol">→</a> <a id="21044" href="Agda.Builtin.Reflection.html#8218" data-type="Type a → Type a" class="Postulate">TC</a> <a id="21047" href="Agda.Builtin.Unit.html#164" data-type="Type" class="Record">⊤</a>
  <a id="21051" href="Data.Nat.Solver.html#21023" data-type="Nat → Term → TC ⊤" class="Function">repr!</a> <a id="21057" href="Data.Nat.Solver.html#21057" class="Bound">n</a> <a id="21059" class="Symbol">=</a> <a id="21061" href="Data.Nat.Solver.html#20436" data-type="Nat → Term → TC ⊤" class="Function">repr-macro</a> <a id="21072" href="Data.Nat.Solver.html#21057" class="Bound">n</a>
</pre>
<p>Slightly more useful is the <code>expand!</code> macro. This takes in a natural number, and will fill in the hole with it’s expanded form. This is intended to be used with the <code>agda2-elaborate-give</code> command in Emacs, which is bound to <code>C-c RET</code> by default.</p>
<pre class="Agda"><a id="expand-macro"></a><a id="21334" href="Data.Nat.Solver.html#21334" data-type="Nat → Term → TC ⊤" class="Function">expand-macro</a> <a id="21347" class="Symbol">:</a> <a id="21349" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="21353" class="Symbol">→</a> <a id="21355" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a> <a id="21360" class="Symbol">→</a> <a id="21362" href="Agda.Builtin.Reflection.html#8218" data-type="Type a → Type a" class="Postulate">TC</a> <a id="21365" href="Agda.Builtin.Unit.html#164" data-type="Type" class="Record">⊤</a>
<a id="21367" href="Data.Nat.Solver.html#21334" data-type="Nat → Term → TC ⊤" class="Function">expand-macro</a> <a id="21380" href="Data.Nat.Solver.html#21380" class="Bound">n</a> <a id="21382" href="Data.Nat.Solver.html#21382" class="Bound">hole</a> <a id="21387" class="Symbol">=</a>
  <a id="21391" href="Agda.Builtin.Reflection.html#9555" data-type="Bool → TC A → TC A" class="Postulate">withNormalisation</a> <a id="21409" href="Agda.Builtin.Bool.html#182" data-type="Bool" class="InductiveConstructor">false</a> <a id="21415" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a>
  <a id="21419" href="Agda.Builtin.Reflection.html#10217" data-type="List Name → TC A → TC A" class="Postulate">dontReduceDefs</a> <a id="21434" href="Data.Nat.Solver.html#20195" data-type="List Name" class="Function">dont-reduce</a> <a id="21446" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="21448" class="Keyword">do</a>
  <a id="21453" href="Data.Nat.Solver.html#21453" class="Bound">tm</a> <a id="21456" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="21458" href="Agda.Builtin.Reflection.html#8705" data-type="A → TC Term" class="Postulate">quoteTC</a> <a id="21466" href="Data.Nat.Solver.html#21380" class="Bound">n</a>
  <a id="21470" href="Data.Nat.Solver.html#21470" class="Bound">e</a> <a id="21472" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="21474" href="Data.Nat.Solver.html#21474" class="Bound">vs</a> <a id="21477" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="21479" href="Data.Nat.Solver.html#18323" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="Function">build-expr</a> <a id="21490" href="1Lab.Reflection.Variables.html#2026" data-type="Variables A" class="Function">empty-vars</a> <a id="21501" href="Data.Nat.Solver.html#21453" class="Bound">tm</a>
  <a id="21506" href="Data.Nat.Solver.html#21506" class="Bound">size</a> <a id="21511" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="21513" href="Data.Nat.Solver.html#21513" class="Bound">env</a> <a id="21517" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="21519" href="1Lab.Reflection.Variables.html#3280" data-type="Variables A → TC (Term × Term)" class="Function">environment</a> <a id="21531" href="Data.Nat.Solver.html#21474" class="Bound">vs</a>
  <a id="21536" href="Data.Nat.Solver.html#21536" class="Bound">expanded</a> <a id="21545" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="21547" href="Agda.Builtin.Reflection.html#8609" data-type="Term → TC Term" class="Postulate">reduce</a> <a id="21554" class="Symbol">(</a><a id="21555" href="Data.Nat.Solver.html#19575" data-type="Term → Term → Term" class="Function">″expand″</a> <a id="21564" href="Data.Nat.Solver.html#21470" class="Bound">e</a> <a id="21566" href="Data.Nat.Solver.html#21513" class="Bound">env</a><a id="21569" class="Symbol">)</a>
  <a id="21573" href="Agda.Builtin.Reflection.html#8391" data-type="Term → Term → TC ⊤" class="Postulate">unify</a> <a id="21579" href="Data.Nat.Solver.html#21382" class="Bound">hole</a> <a id="21584" href="Data.Nat.Solver.html#21536" class="Bound">expanded</a>

<a id="21594" class="Keyword">macro</a>
  <a id="expand!"></a><a id="21602" href="Data.Nat.Solver.html#21602" data-type="Nat → Term → TC ⊤" class="Function">expand!</a> <a id="21610" class="Symbol">:</a> <a id="21612" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="21616" class="Symbol">→</a> <a id="21618" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a> <a id="21623" class="Symbol">→</a> <a id="21625" href="Agda.Builtin.Reflection.html#8218" data-type="Type a → Type a" class="Postulate">TC</a> <a id="21628" href="Agda.Builtin.Unit.html#164" data-type="Type" class="Record">⊤</a>
  <a id="21632" href="Data.Nat.Solver.html#21602" data-type="Nat → Term → TC ⊤" class="Function">expand!</a> <a id="21640" href="Data.Nat.Solver.html#21640" class="Bound">n</a> <a id="21642" class="Symbol">=</a> <a id="21644" href="Data.Nat.Solver.html#21334" data-type="Nat → Term → TC ⊤" class="Function">expand-macro</a> <a id="21657" href="Data.Nat.Solver.html#21640" class="Bound">n</a>
</pre>
<p>Now, finally we have reached the summit. The <code>solve!</code> macro allows us to automatically solve equations involving natural numbers.</p>
<pre class="Agda"><a id="solve-macro"></a><a id="21803" href="Data.Nat.Solver.html#21803" data-type="Term → TC ⊤" class="Function">solve-macro</a> <a id="21815" class="Symbol">:</a> <a id="21817" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a> <a id="21822" class="Symbol">→</a> <a id="21824" href="Agda.Builtin.Reflection.html#8218" data-type="Type a → Type a" class="Postulate">TC</a> <a id="21827" href="Agda.Builtin.Unit.html#164" data-type="Type" class="Record">⊤</a>
<a id="21829" href="Data.Nat.Solver.html#21803" data-type="Term → TC ⊤" class="Function">solve-macro</a> <a id="21841" href="Data.Nat.Solver.html#21841" class="Bound">hole</a> <a id="21846" class="Symbol">=</a>
  <a id="21850" href="Agda.Builtin.Reflection.html#9555" data-type="Bool → TC A → TC A" class="Postulate">withNormalisation</a> <a id="21868" href="Agda.Builtin.Bool.html#182" data-type="Bool" class="InductiveConstructor">false</a> <a id="21874" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a>
  <a id="21878" href="Agda.Builtin.Reflection.html#10217" data-type="List Name → TC A → TC A" class="Postulate">dontReduceDefs</a> <a id="21893" href="Data.Nat.Solver.html#20195" data-type="List Name" class="Function">dont-reduce</a> <a id="21905" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="21907" class="Keyword">do</a>
  <a id="21912" href="Data.Nat.Solver.html#21912" class="Bound">goal</a> <a id="21917" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="21919" href="Agda.Builtin.Reflection.html#8494" data-type="Term → TC Type" class="Postulate">inferType</a> <a id="21929" href="Data.Nat.Solver.html#21841" class="Bound">hole</a> <a id="21934" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">&gt;&gt;=</a> <a id="21938" href="Agda.Builtin.Reflection.html#8609" data-type="Term → TC Term" class="Postulate">reduce</a>

  <a id="21948" href="Agda.Builtin.Maybe.html#174" data-type="A → Maybe A" class="InductiveConstructor">just</a> <a id="21953" class="Symbol">(</a><a id="21954" href="Data.Nat.Solver.html#21954" class="Bound">lhs</a> <a id="21958" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="21960" href="Data.Nat.Solver.html#21960" class="Bound">rhs</a><a id="21963" class="Symbol">)</a> <a id="21965" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="21967" href="Data.Nat.Solver.html#19191" data-type="Term → TC (Maybe (Term × Term))" class="Function">getBoundary</a> <a id="21979" href="Data.Nat.Solver.html#21912" class="Bound">goal</a>
    <a id="21988" class="Keyword">where</a> <a id="21994" href="Agda.Builtin.Maybe.html#195" data-type="Maybe A" class="InductiveConstructor">nothing</a> <a id="22002" class="Symbol">→</a> <a id="22004" href="Agda.Builtin.Reflection.html#8431" data-type="List ErrorPart → TC A" class="Postulate">typeError</a> <a id="22014" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="22016" href="Agda.Builtin.Reflection.html#7917" data-type="String → ErrorPart" class="InductiveConstructor">strErr</a> <a id="22023" class="String">&quot;Can&#39;t determine boundary: &quot;</a> <a id="22052" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a>
                                <a id="22086" href="Agda.Builtin.Reflection.html#7948" data-type="Term → ErrorPart" class="InductiveConstructor">termErr</a> <a id="22094" href="Data.Nat.Solver.html#21912" class="Bound">goal</a> <a id="22099" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a> <a id="22101" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a>
  <a id="22106" href="Data.Nat.Solver.html#22106" class="Bound">elhs</a> <a id="22111" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="22113" href="Data.Nat.Solver.html#22113" class="Bound">vs</a> <a id="22116" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="22118" href="Data.Nat.Solver.html#18323" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="Function">build-expr</a> <a id="22129" href="1Lab.Reflection.Variables.html#2026" data-type="Variables A" class="Function">empty-vars</a> <a id="22140" href="Data.Nat.Solver.html#21954" class="Bound">lhs</a>
  <a id="22146" href="Data.Nat.Solver.html#22146" class="Bound">erhs</a> <a id="22151" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="22153" href="Data.Nat.Solver.html#22153" class="Bound">vs</a> <a id="22156" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="22158" href="Data.Nat.Solver.html#18323" data-type="Variables Nat → Term → TC (Term × Variables Nat)" class="Function">build-expr</a> <a id="22169" href="Data.Nat.Solver.html#22113" class="Bound">vs</a> <a id="22172" href="Data.Nat.Solver.html#21960" class="Bound">rhs</a>
  <a id="22178" href="Data.Nat.Solver.html#22178" class="Bound">size</a> <a id="22183" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="22185" href="Data.Nat.Solver.html#22185" class="Bound">env</a> <a id="22189" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="22191" href="1Lab.Reflection.Variables.html#3280" data-type="Variables A → TC (Term × Term)" class="Function">environment</a> <a id="22203" href="Data.Nat.Solver.html#22153" class="Bound">vs</a>
  <a id="22208" class="Symbol">(</a><a id="22209" href="Agda.Builtin.Reflection.html#10373" data-type="TC A → TC A" class="Postulate">noConstraints</a> <a id="22223" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="22225" href="Agda.Builtin.Reflection.html#8391" data-type="Term → Term → TC ⊤" class="Postulate">unify</a> <a id="22231" href="Data.Nat.Solver.html#21841" class="Bound">hole</a> <a id="22236" class="Symbol">(</a><a id="22237" href="Data.Nat.Solver.html#19676" data-type="Term → Term → Term → Term" class="Function">″solve″</a> <a id="22245" href="Data.Nat.Solver.html#22106" class="Bound">elhs</a> <a id="22250" href="Data.Nat.Solver.html#22146" class="Bound">erhs</a> <a id="22255" href="Data.Nat.Solver.html#22185" class="Bound">env</a><a id="22258" class="Symbol">))</a> <a id="22261" href="Agda.Builtin.Reflection.html#8645" data-type="TC A → TC A → TC A" class="Postulate Operator">&lt;|&gt;</a> <a id="22265" class="Keyword">do</a>
    <a id="22272" href="Data.Nat.Solver.html#22272" class="Bound">nf-lhs</a> <a id="22279" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="22281" href="Agda.Builtin.Reflection.html#8573" data-type="Term → TC Term" class="Postulate">normalise</a> <a id="22291" class="Symbol">(</a><a id="22292" href="Data.Nat.Solver.html#19575" data-type="Term → Term → Term" class="Function">″expand″</a> <a id="22301" href="Data.Nat.Solver.html#22106" class="Bound">elhs</a> <a id="22306" href="Data.Nat.Solver.html#22185" class="Bound">env</a><a id="22309" class="Symbol">)</a>
    <a id="22315" href="Data.Nat.Solver.html#22315" class="Bound">nf-rhs</a> <a id="22322" href="Agda.Builtin.Reflection.html#8311" data-type="TC A → (A → TC B₁) → TC B₁" class="Postulate Operator">←</a> <a id="22324" href="Agda.Builtin.Reflection.html#8573" data-type="Term → TC Term" class="Postulate">normalise</a> <a id="22334" class="Symbol">(</a><a id="22335" href="Data.Nat.Solver.html#19575" data-type="Term → Term → Term" class="Function">″expand″</a> <a id="22344" href="Data.Nat.Solver.html#22146" class="Bound">erhs</a> <a id="22349" href="Data.Nat.Solver.html#22185" class="Bound">env</a><a id="22352" class="Symbol">)</a>
    <a id="22358" href="Agda.Builtin.Reflection.html#8431" data-type="List ErrorPart → TC A" class="Postulate">typeError</a> <a id="22368" class="Symbol">(</a><a id="22369" href="Agda.Builtin.Reflection.html#7917" data-type="String → ErrorPart" class="InductiveConstructor">strErr</a> <a id="22376" class="String">&quot;Could not solve the following goal:\n  &quot;</a> <a id="22418" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a>
                 <a id="22437" href="Agda.Builtin.Reflection.html#7948" data-type="Term → ErrorPart" class="InductiveConstructor">termErr</a> <a id="22445" href="Data.Nat.Solver.html#21954" class="Bound">lhs</a> <a id="22449" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a> <a id="22451" href="Agda.Builtin.Reflection.html#7917" data-type="String → ErrorPart" class="InductiveConstructor">strErr</a> <a id="22458" class="String">&quot; ≡ &quot;</a> <a id="22464" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a> <a id="22466" href="Agda.Builtin.Reflection.html#7948" data-type="Term → ErrorPart" class="InductiveConstructor">termErr</a> <a id="22474" href="Data.Nat.Solver.html#21960" class="Bound">rhs</a> <a id="22478" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a>
               <a id="22495" href="Agda.Builtin.Reflection.html#7917" data-type="String → ErrorPart" class="InductiveConstructor">strErr</a> <a id="22502" class="String">&quot;\nComputed normal forms:\n  LHS: &quot;</a> <a id="22538" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a>
                 <a id="22557" href="Agda.Builtin.Reflection.html#7948" data-type="Term → ErrorPart" class="InductiveConstructor">termErr</a> <a id="22565" href="Data.Nat.Solver.html#22272" class="Bound">nf-lhs</a> <a id="22572" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a>
               <a id="22589" href="Agda.Builtin.Reflection.html#7917" data-type="String → ErrorPart" class="InductiveConstructor">strErr</a> <a id="22596" class="String">&quot;\n  RHS: &quot;</a> <a id="22608" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a>
                 <a id="22627" href="Agda.Builtin.Reflection.html#7948" data-type="Term → ErrorPart" class="InductiveConstructor">termErr</a> <a id="22635" href="Data.Nat.Solver.html#22315" class="Bound">nf-rhs</a> <a id="22642" href="Agda.Builtin.List.html#200" data-type="A → List A → List A" class="InductiveConstructor Operator">∷</a> <a id="22644" href="Agda.Builtin.List.html#185" data-type="List A" class="InductiveConstructor">[]</a><a id="22646" class="Symbol">)</a>

<a id="22649" class="Keyword">macro</a>
  <a id="solve!"></a><a id="22657" href="Data.Nat.Solver.html#22657" data-type="Term → TC ⊤" class="Function">solve!</a> <a id="22664" class="Symbol">:</a> <a id="22666" href="Agda.Builtin.Reflection.html#4688" data-type="Type" class="Datatype">Term</a> <a id="22671" class="Symbol">→</a> <a id="22673" href="Agda.Builtin.Reflection.html#8218" data-type="Type a → Type a" class="Postulate">TC</a> <a id="22676" href="Agda.Builtin.Unit.html#164" data-type="Type" class="Record">⊤</a>
  <a id="22680" href="Data.Nat.Solver.html#22657" data-type="Term → TC ⊤" class="Function">solve!</a> <a id="22687" class="Symbol">=</a> <a id="22689" href="Data.Nat.Solver.html#21803" data-type="Term → TC ⊤" class="Function">solve-macro</a>
</pre>
<h1 id="examples"><a href="#examples" class="header-link">Examples<span class="header-link-emoji">🔗</span></a></h1>
<p>Congratulations! We now have a solver. Let’s marvel at all of our hard work for a moment.</p>
<pre class="Agda"><a id="22817" class="Keyword">private</a>
  <a id="wow-good-job"></a><a id="22827" href="Data.Nat.Solver.html#22827" class="Function">wow-good-job</a> <a id="22840" class="Symbol">:</a> <a id="22842" class="Symbol">∀</a> <a id="22844" href="Data.Nat.Solver.html#22844" class="Bound">x</a> <a id="22846" href="Data.Nat.Solver.html#22846" class="Bound">y</a> <a id="22848" href="Data.Nat.Solver.html#22848" class="Bound">z</a>
                 <a id="22867" class="Symbol">→</a> <a id="22869" class="Symbol">(</a><a id="22870" href="Data.Nat.Solver.html#22844" class="Bound">x</a> <a id="22872" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="22874" class="Number">5</a> <a id="22876" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="22878" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="22882" href="Data.Nat.Solver.html#22846" class="Bound">y</a><a id="22883" class="Symbol">)</a> <a id="22885" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="22887" href="Data.Nat.Solver.html#22848" class="Bound">z</a> <a id="22889" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="22891" href="Data.Nat.Solver.html#22848" class="Bound">z</a> <a id="22893" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="22895" class="Number">5</a> <a id="22897" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="22899" href="Data.Nat.Solver.html#22844" class="Bound">x</a> <a id="22901" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="22903" href="Data.Nat.Solver.html#22848" class="Bound">z</a> <a id="22905" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="22907" href="Data.Nat.Solver.html#22848" class="Bound">z</a> <a id="22909" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="22911" href="Data.Nat.Solver.html#22848" class="Bound">z</a> <a id="22913" href="Agda.Builtin.Nat.html#528" data-type="Nat → Nat → Nat" class="Primitive Operator">*</a> <a id="22915" href="Data.Nat.Solver.html#22846" class="Bound">y</a> 
  <a id="22920" href="Data.Nat.Solver.html#22827" class="Function">wow-good-job</a> <a id="22933" href="Data.Nat.Solver.html#22933" class="Bound">x</a> <a id="22935" href="Data.Nat.Solver.html#22935" class="Bound">y</a> <a id="22937" href="Data.Nat.Solver.html#22937" class="Bound">z</a> <a id="22939" class="Symbol">=</a> <a id="22941" href="Data.Nat.Solver.html#22657" data-type="Term → TC ⊤" class="Macro">solve!</a>
</pre>
<p>Thus concludes our journey. There is still room for improvement, however. A sparse representation would be much more efficient, but these proofs are already quite difficult to begin with. For the brave, here is what a sparse representation might look like.</p>
<pre class="Agda"><a id="23219" class="Keyword">private</a>
  <a id="23229" class="Keyword">data</a> <a id="SparsePoly"></a><a id="23234" href="Data.Nat.Solver.html#23234" class="Datatype">SparsePoly</a> <a id="23245" class="Symbol">{</a><a id="23246" href="Data.Nat.Solver.html#23246" class="Bound">a</a><a id="23247" class="Symbol">}</a> <a id="23249" class="Symbol">(</a><a id="23250" href="Data.Nat.Solver.html#23250" class="Bound">A</a> <a id="23252" class="Symbol">:</a> <a id="23254" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23259" href="Data.Nat.Solver.html#23246" class="Bound">a</a><a id="23260" class="Symbol">)</a> <a id="23262" class="Symbol">:</a> <a id="23264" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="23268" class="Symbol">→</a> <a id="23270" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23275" href="Data.Nat.Solver.html#23246" class="Bound">a</a> <a id="23277" class="Keyword">where</a>
    <a id="SparsePoly.const-sparse"></a><a id="23287" href="Data.Nat.Solver.html#23287" class="InductiveConstructor">const-sparse</a> <a id="23300" class="Symbol">:</a> <a id="23302" class="Symbol">∀</a> <a id="23304" class="Symbol">{</a><a id="23305" href="Data.Nat.Solver.html#23305" class="Bound">n</a><a id="23306" class="Symbol">}</a> <a id="23308" class="Symbol">→</a> <a id="23310" href="Data.Nat.Solver.html#23250" class="Bound">A</a> <a id="23312" class="Symbol">→</a> <a id="23314" href="Data.Nat.Solver.html#23234" class="Datatype">SparsePoly</a> <a id="23325" href="Data.Nat.Solver.html#23250" class="Bound">A</a> <a id="23327" href="Data.Nat.Solver.html#23305" class="Bound">n</a>
    <a id="SparsePoly.shift"></a><a id="23333" href="Data.Nat.Solver.html#23333" class="InductiveConstructor">shift</a>        <a id="23346" class="Symbol">:</a> <a id="23348" class="Symbol">∀</a> <a id="23350" class="Symbol">{</a><a id="23351" href="Data.Nat.Solver.html#23351" class="Bound">n</a><a id="23352" class="Symbol">}</a> <a id="23354" class="Symbol">→</a> <a id="23356" class="Symbol">(</a><a id="23357" href="Data.Nat.Solver.html#23357" class="Bound">j</a> <a id="23359" class="Symbol">:</a> <a id="23361" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a><a id="23364" class="Symbol">)</a> <a id="23366" class="Symbol">→</a> <a id="23368" href="Data.Nat.Solver.html#23234" class="Datatype">SparsePoly</a> <a id="23379" href="Data.Nat.Solver.html#23250" class="Bound">A</a> <a id="23381" href="Data.Nat.Solver.html#23351" class="Bound">n</a>
                   <a id="23402" class="Symbol">→</a> <a id="23404" href="Data.Nat.Solver.html#23234" class="Datatype">SparsePoly</a> <a id="23415" href="Data.Nat.Solver.html#23250" class="Bound">A</a> <a id="23417" class="Symbol">(</a><a id="23418" href="Data.Nat.Solver.html#23357" class="Bound">j</a> <a id="23420" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="23422" href="Data.Nat.Solver.html#23351" class="Bound">n</a><a id="23423" class="Symbol">)</a>
    <a id="SparsePoly._*X^_+_"></a><a id="23429" href="Data.Nat.Solver.html#23429" class="InductiveConstructor Operator">_*X^_+_</a>      <a id="23442" class="Symbol">:</a> <a id="23444" class="Symbol">∀</a> <a id="23446" class="Symbol">{</a><a id="23447" href="Data.Nat.Solver.html#23447" class="Bound">n</a><a id="23448" class="Symbol">}</a> <a id="23450" class="Symbol">→</a> <a id="23452" href="Data.Nat.Solver.html#23234" class="Datatype">SparsePoly</a> <a id="23463" href="Data.Nat.Solver.html#23250" class="Bound">A</a> <a id="23465" class="Symbol">(</a><a id="23466" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="23470" href="Data.Nat.Solver.html#23447" class="Bound">n</a><a id="23471" class="Symbol">)</a> <a id="23473" class="Symbol">→</a> <a id="23475" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="23479" class="Symbol">→</a> <a id="23481" href="Data.Nat.Solver.html#23234" class="Datatype">SparsePoly</a> <a id="23492" href="Data.Nat.Solver.html#23250" class="Bound">A</a> <a id="23494" href="Data.Nat.Solver.html#23447" class="Bound">n</a>
                   <a id="23515" class="Symbol">→</a> <a id="23517" href="Data.Nat.Solver.html#23234" class="Datatype">SparsePoly</a> <a id="23528" href="Data.Nat.Solver.html#23250" class="Bound">A</a> <a id="23530" class="Symbol">(</a><a id="23531" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="23535" href="Data.Nat.Solver.html#23447" class="Bound">n</a><a id="23536" class="Symbol">)</a>
</pre>
  </article>
</div>
</main>
</body>
</html>
