<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>Data.Int - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Data.Int - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="Data.Int - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script defer src="/main.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

  <!-- Google font embeds -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&amp;family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">Data.Int</a>
              </h3>

      <!-- Cube logo -->
      <a id="logo" href="/">
        <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />
      </a>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#integers"><a href="#integers" class="header-link">Integers<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#h-level"><a href="#h-level" class="header-link">h-level<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#recursion"><a href="#recursion" class="header-link">Recursion<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#algebra"><a href="#algebra" class="header-link">Algebra<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#successors"><a href="#successors" class="header-link">Successors<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#addition"><a href="#addition" class="header-link">Addition<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#inverses"><a href="#inverses" class="header-link">Inverses<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>

        <!-- Sidebar footnotes control -->
        <span class="inline-footnotes" style="display: none; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-fns" type="checkbox" class="inline-footnotes" id="sidebar-fns">
          <label for="sidebar-fns">Inline Footnotes</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
        <div class="search-form search-form-proxy" role="form">
          <input id="search-box-proxy" type_="text" placeholder="Search..." autocomplete="off" tabindex="0"></input>
        </div>

              <a href="/">back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/f7f2562d667ff2d432988892adb4bb29e366787c/src/Data/Int.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao, Jonathan Coates and uni</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="/">back to index</a>
      </div>
      
      <!-- Navbar equations control -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>

      <!-- Navbar footnotes control -->
      <span class="inline-footnotes" style="display: none; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-fns" type="checkbox" class="inline-footnotes" id="navbar-fns">
        <label for="navbar-fns">Inline Footnotes</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="1Lab.HLevel.Retracts.html" class="Module">1Lab.HLevel.Retracts</a>
<a id="42" class="Keyword">open</a> <a id="47" class="Keyword">import</a> <a id="54" href="1Lab.Path.Groupoid.html" class="Module">1Lab.Path.Groupoid</a>
<a id="73" class="Keyword">open</a> <a id="78" class="Keyword">import</a> <a id="85" href="1Lab.HLevel.Sets.html" class="Module">1Lab.HLevel.Sets</a>
<a id="102" class="Keyword">open</a> <a id="107" class="Keyword">import</a> <a id="114" href="1Lab.Univalence.html" class="Module">1Lab.Univalence</a>
<a id="130" class="Keyword">open</a> <a id="135" class="Keyword">import</a> <a id="142" href="1Lab.Type.Dec.html" class="Module">1Lab.Type.Dec</a>
<a id="156" class="Keyword">open</a> <a id="161" class="Keyword">import</a> <a id="168" href="1Lab.HLevel.html" class="Module">1Lab.HLevel</a>
<a id="180" class="Keyword">open</a> <a id="185" class="Keyword">import</a> <a id="192" href="1Lab.Equiv.html" class="Module">1Lab.Equiv</a>
<a id="203" class="Keyword">open</a> <a id="208" class="Keyword">import</a> <a id="215" href="1Lab.Path.html" class="Module">1Lab.Path</a>
<a id="225" class="Keyword">open</a> <a id="230" class="Keyword">import</a> <a id="237" href="1Lab.Type.html" class="Module">1Lab.Type</a>

<a id="248" class="Keyword">open</a> <a id="253" class="Keyword">import</a> <a id="260" href="Data.Nat.html" class="Module">Data.Nat</a>

<a id="270" class="Keyword">module</a> <a id="277" href="Data.Int.html" class="Module">Data.Int</a> <a id="286" class="Keyword">where</a>
</pre>
<h1 id="integers"><a href="#integers" class="header-link">Integers<span class="header-link-emoji">🔗</span></a></h1>
<p>The <strong>integers</strong> are what you get when you complete the <a href="Algebra.Monoid.html#ℕ-+">additive monoid structure on the naturals</a> into a <a href="Algebra.Group.html">group</a>. In non-cubical Agda, a representation of the integers as a coproduct <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi><mo>∐</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\bb{N} \coprod \bb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">N</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∐</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathbb">N</span></span></span></span> with one of the factors offset (to avoid having two zeroes) is adopted. In Cubical Agda we can adopt a representation much closer to a “classical” construction of the integers:</p>
<pre class="Agda"><a id="802" class="Keyword">data</a> <a id="Int"></a><a id="807" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a> <a id="811" class="Symbol">:</a> <a id="813" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="818" class="Keyword">where</a>
  <a id="Int.diff"></a><a id="826" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="831" class="Symbol">:</a> <a id="833" class="Symbol">(</a><a id="834" href="Data.Int.html#834" class="Bound">x</a> <a id="836" href="Data.Int.html#836" class="Bound">y</a> <a id="838" class="Symbol">:</a> <a id="840" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a><a id="843" class="Symbol">)</a> <a id="845" class="Symbol">→</a> <a id="847" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a>
  <a id="Int.quot"></a><a id="853" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="858" class="Symbol">:</a> <a id="860" class="Symbol">(</a><a id="861" href="Data.Int.html#861" class="Bound">m</a> <a id="863" href="Data.Int.html#863" class="Bound">n</a> <a id="865" class="Symbol">:</a> <a id="867" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a><a id="870" class="Symbol">)</a> <a id="872" class="Symbol">→</a> <a id="874" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="879" href="Data.Int.html#861" class="Bound">m</a> <a id="881" href="Data.Int.html#863" class="Bound">n</a> <a id="883" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="885" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="890" class="Symbol">(</a><a id="891" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="895" href="Data.Int.html#861" class="Bound">m</a><a id="896" class="Symbol">)</a> <a id="898" class="Symbol">(</a><a id="899" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="903" href="Data.Int.html#863" class="Bound">n</a><a id="904" class="Symbol">)</a>
</pre>
<p>This is an alternative representation of the construction of integers as pairs <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mspace></mspace><mspace width="0.1111em"></mspace><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333em"></mspace><msup><mi mathvariant="double-struck">N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">(x , y)\colon \bb{N}^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord"><span class="mord mathbb">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a,b) = (c, d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span> iff <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>d</mi><mo>=</mo><mi>b</mi><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a + d = b + c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>:</span> An integer is an equivalence class of pairs of naturals, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span> is identified with <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>a</mi><mo separator="true">,</mo><mn>1</mn><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1 + a, 1 + b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>,</span> or, more type-theoretically, the integers are generated by the constructor <span class="Agda"><a href="Data.Int.html#826" class="InductiveConstructor">diff</a></span> which embeds a pair of naturals, and the path constructor <span class="Agda"><a href="Data.Int.html#853" class="InductiveConstructor">quot</a></span> which expresses that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span> = <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>a</mi><mo separator="true">,</mo><mn>1</mn><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1 + a, 1 + b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>.</span></p>
<p>This single generating path is enough to recover the “classical” quotient, which we do in steps. First, we… prove that that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n - n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> is <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>:</span></p>
<pre class="Agda"><a id="zeroes"></a><a id="1531" href="Data.Int.html#1531" data-type="(n : Nat) → diff 0 0 ≡ diff n n" class="Function">zeroes</a> <a id="1538" class="Symbol">:</a> <a id="1540" class="Symbol">(</a><a id="1541" href="Data.Int.html#1541" class="Bound">n</a> <a id="1543" class="Symbol">:</a> <a id="1545" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a><a id="1548" class="Symbol">)</a> <a id="1550" class="Symbol">→</a> <a id="1552" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="1557" class="Number">0</a> <a id="1559" class="Number">0</a> <a id="1561" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1563" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="1568" href="Data.Int.html#1541" class="Bound">n</a> <a id="1570" href="Data.Int.html#1541" class="Bound">n</a>
<a id="1572" href="Data.Int.html#1531" data-type="(n : Nat) → diff 0 0 ≡ diff n n" class="Function">zeroes</a> <a id="1579" href="Agda.Builtin.Nat.html#210" data-type="Nat" class="InductiveConstructor">zero</a> <a id="1584" class="Symbol">=</a> <a id="1586" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
<a id="1591" href="Data.Int.html#1531" data-type="(n : Nat) → diff 0 0 ≡ diff n n" class="Function">zeroes</a> <a id="1598" class="Symbol">(</a><a id="1599" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="1603" href="Data.Int.html#1603" class="Bound">n</a><a id="1604" class="Symbol">)</a> <a id="1606" class="Symbol">=</a> <a id="1608" href="Data.Int.html#1531" data-type="(n : Nat) → diff 0 0 ≡ diff n n" class="Function">zeroes</a> <a id="1615" href="Data.Int.html#1603" class="Bound">n</a> <a id="1617" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="1619" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="1624" class="Symbol">_</a> <a id="1626" class="Symbol">_</a>
</pre>
<p>Additionally, offsetting a difference by a fixed natural, as long as it’s done on both sides of the difference, does not change which integer is being represented: That is, considering all three naturals as integers, <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>−</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>a</mi><mo stretchy="false">)</mo><mo>−</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a - b) = (n + a) - (n + b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>.</span></p>
<pre class="Agda"><a id="cancel"></a><a id="1890" href="Data.Int.html#1890" data-type="(a b n : Nat) → diff a b ≡ diff (n + a) (n + b)" class="Function">cancel</a> <a id="1897" class="Symbol">:</a> <a id="1899" class="Symbol">(</a><a id="1900" href="Data.Int.html#1900" class="Bound">a</a> <a id="1902" href="Data.Int.html#1902" class="Bound">b</a> <a id="1904" href="Data.Int.html#1904" class="Bound">n</a> <a id="1906" class="Symbol">:</a> <a id="1908" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a><a id="1911" class="Symbol">)</a> <a id="1913" class="Symbol">→</a> <a id="1915" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="1920" href="Data.Int.html#1900" class="Bound">a</a> <a id="1922" href="Data.Int.html#1902" class="Bound">b</a> <a id="1924" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="1926" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="1931" class="Symbol">(</a><a id="1932" href="Data.Int.html#1904" class="Bound">n</a> <a id="1934" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="1936" href="Data.Int.html#1900" class="Bound">a</a><a id="1937" class="Symbol">)</a> <a id="1939" class="Symbol">(</a><a id="1940" href="Data.Int.html#1904" class="Bound">n</a> <a id="1942" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="1944" href="Data.Int.html#1902" class="Bound">b</a><a id="1945" class="Symbol">)</a>
<a id="1947" href="Data.Int.html#1890" data-type="(a b n : Nat) → diff a b ≡ diff (n + a) (n + b)" class="Function">cancel</a> <a id="1954" href="Data.Int.html#1954" class="Bound">a</a> <a id="1956" href="Data.Int.html#1956" class="Bound">b</a> <a id="1958" href="Agda.Builtin.Nat.html#210" data-type="Nat" class="InductiveConstructor">zero</a> <a id="1963" class="Symbol">=</a> <a id="1965" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
<a id="1970" href="Data.Int.html#1890" data-type="(a b n : Nat) → diff a b ≡ diff (n + a) (n + b)" class="Function">cancel</a> <a id="1977" href="Data.Int.html#1977" class="Bound">a</a> <a id="1979" href="Data.Int.html#1979" class="Bound">b</a> <a id="1981" class="Symbol">(</a><a id="1982" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="1986" href="Data.Int.html#1986" class="Bound">n</a><a id="1987" class="Symbol">)</a> <a id="1989" class="Symbol">=</a> <a id="1991" href="Data.Int.html#1890" data-type="(a b n : Nat) → diff a b ≡ diff (n + a) (n + b)" class="Function">cancel</a> <a id="1998" href="Data.Int.html#1977" class="Bound">a</a> <a id="2000" href="Data.Int.html#1979" class="Bound">b</a> <a id="2002" href="Data.Int.html#1986" class="Bound">n</a> <a id="2004" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="2006" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="2011" class="Symbol">_</a> <a id="2013" class="Symbol">_</a>
</pre>
<p>As a final pair of helper lemmas, we find that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> differ by an absolute value of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>,</span> then the values <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n - k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> are the same (as long as we fix the sign — hence the two lemmas). The generic situation of “differing by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>” is captured by fixing a natural number <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> and adding <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>,</span> because we have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mo>−</mo><mi>a</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">(a + b) - a = b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> and <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>−</mo><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a - (a + b) = -b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord mathnormal">b</span></span></span></span>.</span></p>
<pre class="Agda"><a id="offset-negative"></a><a id="2388" href="Data.Int.html#2388" data-type="(a b : Nat) → diff a (a + b) ≡ diff 0 b" class="Function">offset-negative</a> <a id="2404" class="Symbol">:</a> <a id="2406" class="Symbol">(</a><a id="2407" href="Data.Int.html#2407" class="Bound">a</a> <a id="2409" href="Data.Int.html#2409" class="Bound">b</a> <a id="2411" class="Symbol">:</a> <a id="2413" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a><a id="2416" class="Symbol">)</a> <a id="2418" class="Symbol">→</a> <a id="2420" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="2425" href="Data.Int.html#2407" class="Bound">a</a> <a id="2427" class="Symbol">(</a><a id="2428" href="Data.Int.html#2407" class="Bound">a</a> <a id="2430" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="2432" href="Data.Int.html#2409" class="Bound">b</a><a id="2433" class="Symbol">)</a> <a id="2435" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2437" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="2442" class="Number">0</a> <a id="2444" href="Data.Int.html#2409" class="Bound">b</a>
<a id="2446" href="Data.Int.html#2388" data-type="(a b : Nat) → diff a (a + b) ≡ diff 0 b" class="Function">offset-negative</a> <a id="2462" href="Agda.Builtin.Nat.html#210" data-type="Nat" class="InductiveConstructor">zero</a> <a id="2467" href="Data.Int.html#2467" class="Bound">b</a> <a id="2469" class="Symbol">=</a> <a id="2471" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
<a id="2476" href="Data.Int.html#2388" data-type="(a b : Nat) → diff a (a + b) ≡ diff 0 b" class="Function">offset-negative</a> <a id="2492" class="Symbol">(</a><a id="2493" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="2497" href="Data.Int.html#2497" class="Bound">a</a><a id="2498" class="Symbol">)</a> <a id="2500" href="Data.Int.html#2500" class="Bound">b</a> <a id="2502" class="Symbol">=</a>
  <a id="2506" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="2511" class="Symbol">(</a><a id="2512" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="2516" href="Data.Int.html#2497" class="Bound">a</a><a id="2517" class="Symbol">)</a> <a id="2519" class="Symbol">(</a><a id="2520" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="2524" class="Symbol">(</a><a id="2525" href="Data.Int.html#2497" class="Bound">a</a> <a id="2527" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="2529" href="Data.Int.html#2500" class="Bound">b</a><a id="2530" class="Symbol">))</a> <a id="2533" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="2536" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="2540" class="Symbol">(</a><a id="2541" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="2546" class="Symbol">_</a> <a id="2548" class="Symbol">_)</a> <a id="2551" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="2555" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="2560" href="Data.Int.html#2497" class="Bound">a</a> <a id="2562" class="Symbol">(</a><a id="2563" href="Data.Int.html#2497" class="Bound">a</a> <a id="2565" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="2567" href="Data.Int.html#2500" class="Bound">b</a><a id="2568" class="Symbol">)</a>             <a id="2582" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="2585" href="Data.Int.html#2388" data-type="(a b : Nat) → diff a (a + b) ≡ diff 0 b" class="Function">offset-negative</a> <a id="2601" href="Data.Int.html#2497" class="Bound">a</a> <a id="2603" href="Data.Int.html#2500" class="Bound">b</a> <a id="2605" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="2609" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="2614" class="Number">0</a> <a id="2616" href="Data.Int.html#2500" class="Bound">b</a>                   <a id="2636" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

<a id="offset-positive"></a><a id="2639" href="Data.Int.html#2639" data-type="(a b : Nat) → diff (a + b) a ≡ diff b 0" class="Function">offset-positive</a> <a id="2655" class="Symbol">:</a> <a id="2657" class="Symbol">(</a><a id="2658" href="Data.Int.html#2658" class="Bound">a</a> <a id="2660" href="Data.Int.html#2660" class="Bound">b</a> <a id="2662" class="Symbol">:</a> <a id="2664" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a><a id="2667" class="Symbol">)</a> <a id="2669" class="Symbol">→</a> <a id="2671" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="2676" class="Symbol">(</a><a id="2677" href="Data.Int.html#2658" class="Bound">a</a> <a id="2679" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="2681" href="Data.Int.html#2660" class="Bound">b</a><a id="2682" class="Symbol">)</a> <a id="2684" href="Data.Int.html#2658" class="Bound">a</a> <a id="2686" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="2688" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="2693" href="Data.Int.html#2660" class="Bound">b</a> <a id="2695" class="Number">0</a>
<a id="2697" href="Data.Int.html#2639" data-type="(a b : Nat) → diff (a + b) a ≡ diff b 0" class="Function">offset-positive</a> <a id="2713" href="Agda.Builtin.Nat.html#210" data-type="Nat" class="InductiveConstructor">zero</a> <a id="2718" href="Data.Int.html#2718" class="Bound">b</a> <a id="2720" class="Symbol">=</a> <a id="2722" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
<a id="2727" href="Data.Int.html#2639" data-type="(a b : Nat) → diff (a + b) a ≡ diff b 0" class="Function">offset-positive</a> <a id="2743" class="Symbol">(</a><a id="2744" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="2748" href="Data.Int.html#2748" class="Bound">a</a><a id="2749" class="Symbol">)</a> <a id="2751" href="Data.Int.html#2751" class="Bound">b</a> <a id="2753" class="Symbol">=</a>
  <a id="2757" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="2762" class="Symbol">(</a><a id="2763" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="2767" class="Symbol">(</a><a id="2768" href="Data.Int.html#2748" class="Bound">a</a> <a id="2770" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="2772" href="Data.Int.html#2751" class="Bound">b</a><a id="2773" class="Symbol">))</a> <a id="2776" class="Symbol">(</a><a id="2777" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="2781" href="Data.Int.html#2748" class="Bound">a</a><a id="2782" class="Symbol">)</a> <a id="2784" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="2787" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="2791" class="Symbol">(</a><a id="2792" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="2797" class="Symbol">_</a> <a id="2799" class="Symbol">_)</a> <a id="2802" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="2806" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="2811" class="Symbol">(</a><a id="2812" href="Data.Int.html#2748" class="Bound">a</a> <a id="2814" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="2816" href="Data.Int.html#2751" class="Bound">b</a><a id="2817" class="Symbol">)</a> <a id="2819" href="Data.Int.html#2748" class="Bound">a</a>             <a id="2833" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="2836" href="Data.Int.html#2639" data-type="(a b : Nat) → diff (a + b) a ≡ diff b 0" class="Function">offset-positive</a> <a id="2852" href="Data.Int.html#2748" class="Bound">a</a> <a id="2854" href="Data.Int.html#2751" class="Bound">b</a> <a id="2856" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="2860" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="2865" href="Data.Int.html#2751" class="Bound">b</a> <a id="2867" class="Number">0</a>                   <a id="2887" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
</pre>
<p>Those two are the last two lemmas we need to prove the “if” direction of “naturals are identified in the quotient iff they represent the same difference”: the construction <span class="Agda"><a href="Data.Int.html#3158" class="Function">same-difference</a></span> below packages everything together with a bow on the top.</p>
<pre class="Agda"><a id="same-difference"></a><a id="3158" href="Data.Int.html#3158" data-type="a + d ≡ b + c → diff a b ≡ diff c d" class="Function">same-difference</a> <a id="3174" class="Symbol">:</a> <a id="3176" class="Symbol">{</a><a id="3177" href="Data.Int.html#3177" class="Bound">a</a> <a id="3179" href="Data.Int.html#3179" class="Bound">b</a> <a id="3181" href="Data.Int.html#3181" class="Bound">c</a> <a id="3183" href="Data.Int.html#3183" class="Bound">d</a> <a id="3185" class="Symbol">:</a> <a id="3187" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a><a id="3190" class="Symbol">}</a> <a id="3192" class="Symbol">→</a> <a id="3194" href="Data.Int.html#3177" class="Bound">a</a> <a id="3196" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3198" href="Data.Int.html#3183" class="Bound">d</a> <a id="3200" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3202" href="Data.Int.html#3179" class="Bound">b</a> <a id="3204" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3206" href="Data.Int.html#3181" class="Bound">c</a> <a id="3208" class="Symbol">→</a> <a id="3210" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3215" href="Data.Int.html#3177" class="Bound">a</a> <a id="3217" href="Data.Int.html#3179" class="Bound">b</a> <a id="3219" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3221" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3226" href="Data.Int.html#3181" class="Bound">c</a> <a id="3228" href="Data.Int.html#3183" class="Bound">d</a>
<a id="3230" href="Data.Int.html#3158" data-type="a + d ≡ b + c → diff a b ≡ diff c d" class="Function">same-difference</a> <a id="3246" class="Symbol">{</a><a id="3247" href="Agda.Builtin.Nat.html#210" data-type="Nat" class="InductiveConstructor">zero</a><a id="3251" class="Symbol">}</a> <a id="3253" class="Symbol">{</a><a id="3254" href="Data.Int.html#3254" class="Bound">b</a><a id="3255" class="Symbol">}</a> <a id="3257" class="Symbol">{</a><a id="3258" href="Data.Int.html#3258" class="Bound">c</a><a id="3259" class="Symbol">}</a> <a id="3261" class="Symbol">{</a><a id="3262" href="Data.Int.html#3262" class="Bound">d</a><a id="3263" class="Symbol">}</a> <a id="3265" href="Data.Int.html#3265" class="Bound">path</a> <a id="3270" class="Symbol">=</a>
  <a id="3274" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="3278" class="Symbol">(</a> <a id="3280" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3285" href="Data.Int.html#3258" class="Bound">c</a> <a id="3287" href="Data.Int.html#3262" class="Bound">d</a>       <a id="3295" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3298" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="3302" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3307" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="3312" href="Data.Int.html#3265" class="Bound">path</a> <a id="3317" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
        <a id="3327" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3332" href="Data.Int.html#3258" class="Bound">c</a> <a id="3334" class="Symbol">(</a><a id="3335" href="Data.Int.html#3254" class="Bound">b</a> <a id="3337" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3339" href="Data.Int.html#3258" class="Bound">c</a><a id="3340" class="Symbol">)</a> <a id="3342" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3345" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="3349" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3354" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="3359" class="Symbol">(</a><a id="3360" href="Data.Nat.Properties.html#932" data-type="(x y : Nat) → x + y ≡ y + x" class="Function">+-commutative</a> <a id="3374" href="Data.Int.html#3254" class="Bound">b</a> <a id="3376" href="Data.Int.html#3258" class="Bound">c</a><a id="3377" class="Symbol">)</a> <a id="3379" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
        <a id="3389" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3394" href="Data.Int.html#3258" class="Bound">c</a> <a id="3396" class="Symbol">(</a><a id="3397" href="Data.Int.html#3258" class="Bound">c</a> <a id="3399" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3401" href="Data.Int.html#3254" class="Bound">b</a><a id="3402" class="Symbol">)</a> <a id="3404" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3407" href="Data.Int.html#2388" data-type="(a b : Nat) → diff a (a + b) ≡ diff 0 b" class="Function">offset-negative</a> <a id="3423" class="Symbol">_</a> <a id="3425" class="Symbol">_</a> <a id="3427" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
        <a id="3437" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3442" class="Number">0</a> <a id="3444" href="Data.Int.html#3254" class="Bound">b</a>       <a id="3452" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
      <a id="3460" class="Symbol">)</a>
<a id="3462" href="Data.Int.html#3158" data-type="a + d ≡ b + c → diff a b ≡ diff c d" class="Function">same-difference</a> <a id="3478" class="Symbol">{</a><a id="3479" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="3483" href="Data.Int.html#3483" class="Bound">a</a><a id="3484" class="Symbol">}</a> <a id="3486" class="Symbol">{</a><a id="3487" href="Agda.Builtin.Nat.html#210" data-type="Nat" class="InductiveConstructor">zero</a><a id="3491" class="Symbol">}</a> <a id="3493" class="Symbol">{</a><a id="3494" href="Data.Int.html#3494" class="Bound">c</a><a id="3495" class="Symbol">}</a> <a id="3497" class="Symbol">{</a><a id="3498" href="Data.Int.html#3498" class="Bound">d</a><a id="3499" class="Symbol">}</a> <a id="3501" href="Data.Int.html#3501" class="Bound">path</a> <a id="3506" class="Symbol">=</a>
  <a id="3510" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="3514" class="Symbol">(</a> <a id="3516" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3521" href="Data.Int.html#3494" class="Bound">c</a> <a id="3523" href="Data.Int.html#3498" class="Bound">d</a>             <a id="3537" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3540" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="3544" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3549" class="Symbol">(</a><a id="3550" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="3554" href="Data.Int.html#3501" class="Bound">path</a><a id="3558" class="Symbol">)</a> <a id="3560" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="3565" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
        <a id="3575" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3580" class="Symbol">(</a><a id="3581" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="3585" href="Data.Int.html#3483" class="Bound">a</a> <a id="3587" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3589" href="Data.Int.html#3498" class="Bound">d</a><a id="3590" class="Symbol">)</a> <a id="3592" href="Data.Int.html#3498" class="Bound">d</a>   <a id="3596" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3599" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="3603" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3608" class="Symbol">(</a><a id="3609" href="Data.Nat.Properties.html#932" data-type="(x y : Nat) → x + y ≡ y + x" class="Function">+-commutative</a> <a id="3623" class="Symbol">(</a><a id="3624" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="3628" href="Data.Int.html#3483" class="Bound">a</a><a id="3629" class="Symbol">)</a> <a id="3631" href="Data.Int.html#3498" class="Bound">d</a><a id="3632" class="Symbol">)</a> <a id="3634" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="3639" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
        <a id="3649" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3654" class="Symbol">(</a><a id="3655" href="Data.Int.html#3498" class="Bound">d</a> <a id="3657" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="3659" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="3663" href="Data.Int.html#3483" class="Bound">a</a><a id="3664" class="Symbol">)</a> <a id="3666" href="Data.Int.html#3498" class="Bound">d</a>   <a id="3670" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3673" href="Data.Int.html#2639" data-type="(a b : Nat) → diff (a + b) a ≡ diff b 0" class="Function">offset-positive</a> <a id="3689" class="Symbol">_</a> <a id="3691" class="Symbol">_</a> <a id="3693" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
        <a id="3703" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3708" class="Symbol">(</a><a id="3709" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="3713" href="Data.Int.html#3483" class="Bound">a</a><a id="3714" class="Symbol">)</a> <a id="3716" class="Number">0</a>       <a id="3724" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
      <a id="3732" class="Symbol">)</a>
<a id="3734" href="Data.Int.html#3158" data-type="a + d ≡ b + c → diff a b ≡ diff c d" class="Function">same-difference</a> <a id="3750" class="Symbol">{</a><a id="3751" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="3755" href="Data.Int.html#3755" class="Bound">a</a><a id="3756" class="Symbol">}</a> <a id="3758" class="Symbol">{</a><a id="3759" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="3763" href="Data.Int.html#3763" class="Bound">b</a><a id="3764" class="Symbol">}</a> <a id="3766" class="Symbol">{</a><a id="3767" href="Data.Int.html#3767" class="Bound">c</a><a id="3768" class="Symbol">}</a> <a id="3770" class="Symbol">{</a><a id="3771" href="Data.Int.html#3771" class="Bound">d</a><a id="3772" class="Symbol">}</a> <a id="3774" href="Data.Int.html#3774" class="Bound">path</a> <a id="3779" class="Symbol">=</a>
  <a id="3783" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3788" class="Symbol">(</a><a id="3789" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="3793" href="Data.Int.html#3755" class="Bound">a</a><a id="3794" class="Symbol">)</a> <a id="3796" class="Symbol">(</a><a id="3797" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="3801" href="Data.Int.html#3763" class="Bound">b</a><a id="3802" class="Symbol">)</a> <a id="3804" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3807" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="3811" class="Symbol">(</a><a id="3812" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="3817" class="Symbol">_</a> <a id="3819" class="Symbol">_)</a> <a id="3822" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="3826" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3831" href="Data.Int.html#3755" class="Bound">a</a> <a id="3833" href="Data.Int.html#3763" class="Bound">b</a>             <a id="3847" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="3850" href="Data.Int.html#3158" data-type="a + d ≡ b + c → diff a b ≡ diff c d" class="Function">same-difference</a> <a id="3866" class="Symbol">(</a><a id="3867" href="Data.Nat.Base.html#1635" data-type="suc x ≡ suc y → x ≡ y" class="Function">suc-inj</a> <a id="3875" href="Data.Int.html#3774" class="Bound">path</a><a id="3879" class="Symbol">)</a> <a id="3881" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
  <a id="3885" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="3890" href="Data.Int.html#3767" class="Bound">c</a> <a id="3892" href="Data.Int.html#3771" class="Bound">d</a>             <a id="3906" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
</pre>
<!--
<pre class="Agda"><a id="quot-diamond"></a><a id="3926" href="Data.Int.html#3926" data-type="(a b : Nat) →
Square (quot a b) (quot a b) (quot (suc a) (suc b))
(quot (suc a) (suc b))" class="Function">quot-diamond</a> <a id="3939" class="Symbol">:</a> <a id="3941" class="Symbol">(</a><a id="3942" href="Data.Int.html#3942" class="Bound">a</a> <a id="3944" href="Data.Int.html#3944" class="Bound">b</a> <a id="3946" class="Symbol">:</a> <a id="3948" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a><a id="3951" class="Symbol">)</a>
             <a id="3966" class="Symbol">→</a> <a id="3968" href="1Lab.Path.html#9409" data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" class="Function">Square</a> <a id="3975" class="Symbol">(</a><a id="3976" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="3981" href="Data.Int.html#3942" class="Bound">a</a> <a id="3983" href="Data.Int.html#3944" class="Bound">b</a><a id="3984" class="Symbol">)</a> <a id="3986" class="Symbol">(</a><a id="3987" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="3992" href="Data.Int.html#3942" class="Bound">a</a> <a id="3994" href="Data.Int.html#3944" class="Bound">b</a><a id="3995" class="Symbol">)</a>
                      <a id="4019" class="Symbol">(</a><a id="4020" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="4025" class="Symbol">(</a><a id="4026" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="4030" href="Data.Int.html#3942" class="Bound">a</a><a id="4031" class="Symbol">)</a> <a id="4033" class="Symbol">(</a><a id="4034" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="4038" href="Data.Int.html#3944" class="Bound">b</a><a id="4039" class="Symbol">))</a>
                      <a id="4064" class="Symbol">(</a><a id="4065" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="4070" class="Symbol">(</a><a id="4071" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="4075" href="Data.Int.html#3942" class="Bound">a</a><a id="4076" class="Symbol">)</a> <a id="4078" class="Symbol">(</a><a id="4079" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="4083" href="Data.Int.html#3944" class="Bound">b</a><a id="4084" class="Symbol">))</a>
<a id="4087" href="Data.Int.html#3926" data-type="(a b : Nat) →
Square (quot a b) (quot a b) (quot (suc a) (suc b))
(quot (suc a) (suc b))" class="Function">quot-diamond</a> <a id="4100" href="Data.Int.html#4100" class="Bound">a</a> <a id="4102" href="Data.Int.html#4102" class="Bound">b</a> <a id="4104" href="Data.Int.html#4104" class="Bound">i</a> <a id="4106" href="Data.Int.html#4106" class="Bound">j</a> <a id="4108" class="Symbol">=</a>
  <a id="4112" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="4118" class="Symbol">(λ</a> <a id="4121" href="Data.Int.html#4121" class="Bound">k</a> <a id="4123" class="Symbol">→</a> <a id="4125" class="Symbol">λ</a> <a id="4127" class="Symbol">{</a> <a id="4129" class="Symbol">(</a><a id="4130" href="Data.Int.html#4104" class="Bound">i</a> <a id="4132" class="Symbol">=</a> <a id="4134" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="4136" class="Symbol">)</a> <a id="4138" class="Symbol">→</a> <a id="4140" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="4145" href="Data.Int.html#4100" class="Bound">a</a> <a id="4147" href="Data.Int.html#4102" class="Bound">b</a> <a id="4149" href="Data.Int.html#4106" class="Bound">j</a>
                 <a id="4168" class="Symbol">;</a> <a id="4170" class="Symbol">(</a><a id="4171" href="Data.Int.html#4104" class="Bound">i</a> <a id="4173" class="Symbol">=</a> <a id="4175" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="4177" class="Symbol">)</a> <a id="4179" class="Symbol">→</a> <a id="4181" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="4186" class="Symbol">(</a><a id="4187" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="4191" href="Data.Int.html#4100" class="Bound">a</a><a id="4192" class="Symbol">)</a> <a id="4194" class="Symbol">(</a><a id="4195" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="4199" href="Data.Int.html#4102" class="Bound">b</a><a id="4200" class="Symbol">)</a> <a id="4202" class="Symbol">(</a><a id="4203" href="Data.Int.html#4106" class="Bound">j</a> <a id="4205" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="4207" href="Data.Int.html#4121" class="Bound">k</a><a id="4208" class="Symbol">)</a>
                 <a id="4227" class="Symbol">;</a> <a id="4229" class="Symbol">(</a><a id="4230" href="Data.Int.html#4106" class="Bound">j</a> <a id="4232" class="Symbol">=</a> <a id="4234" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="4236" class="Symbol">)</a> <a id="4238" class="Symbol">→</a> <a id="4240" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="4245" href="Data.Int.html#4100" class="Bound">a</a> <a id="4247" href="Data.Int.html#4102" class="Bound">b</a> <a id="4249" href="Data.Int.html#4104" class="Bound">i</a>
                 <a id="4268" class="Symbol">;</a> <a id="4270" class="Symbol">(</a><a id="4271" href="Data.Int.html#4106" class="Bound">j</a> <a id="4273" class="Symbol">=</a> <a id="4275" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="4277" class="Symbol">)</a> <a id="4279" class="Symbol">→</a> <a id="4281" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="4286" class="Symbol">(</a><a id="4287" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="4291" href="Data.Int.html#4100" class="Bound">a</a><a id="4292" class="Symbol">)</a> <a id="4294" class="Symbol">(</a><a id="4295" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="4299" href="Data.Int.html#4102" class="Bound">b</a><a id="4300" class="Symbol">)</a> <a id="4302" class="Symbol">(</a><a id="4303" href="Data.Int.html#4104" class="Bound">i</a> <a id="4305" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="4307" href="Data.Int.html#4121" class="Bound">k</a><a id="4308" class="Symbol">)</a>
                 <a id="4327" class="Symbol">})</a>
        <a id="4338" class="Symbol">(</a><a id="4339" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="4344" href="Data.Int.html#4100" class="Bound">a</a> <a id="4346" href="Data.Int.html#4102" class="Bound">b</a> <a id="4348" class="Symbol">(</a><a id="4349" href="Data.Int.html#4104" class="Bound">i</a> <a id="4351" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="4353" href="Data.Int.html#4106" class="Bound">j</a><a id="4354" class="Symbol">))</a>

<a id="quot-triangle"></a><a id="4358" href="Data.Int.html#4358" data-type="(a b : Nat) (i : I) → diff a b ≡ quot a b i" class="Function">quot-triangle</a> <a id="4372" class="Symbol">:</a> <a id="4374" class="Symbol">(</a><a id="4375" href="Data.Int.html#4375" class="Bound">a</a> <a id="4377" href="Data.Int.html#4377" class="Bound">b</a> <a id="4379" class="Symbol">:</a> <a id="4381" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a><a id="4384" class="Symbol">)</a> <a id="4386" class="Symbol">(</a><a id="4387" href="Data.Int.html#4387" class="Bound">i</a> <a id="4389" class="Symbol">:</a> <a id="4391" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="4392" class="Symbol">)</a> <a id="4394" class="Symbol">→</a> <a id="4396" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="4401" href="Data.Int.html#4375" class="Bound">a</a> <a id="4403" href="Data.Int.html#4377" class="Bound">b</a> <a id="4405" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="4407" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="4412" href="Data.Int.html#4375" class="Bound">a</a> <a id="4414" href="Data.Int.html#4377" class="Bound">b</a> <a id="4416" href="Data.Int.html#4387" class="Bound">i</a>
<a id="4418" href="Data.Int.html#4358" data-type="(a b : Nat) (i : I) → diff a b ≡ quot a b i" class="Function">quot-triangle</a> <a id="4432" href="Data.Int.html#4432" class="Bound">a</a> <a id="4434" href="Data.Int.html#4434" class="Bound">b</a> <a id="4436" href="Data.Int.html#4436" class="Bound">i</a> <a id="4438" href="Data.Int.html#4438" class="Bound">j</a> <a id="4440" class="Symbol">=</a> <a id="4442" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="4448" class="Symbol">(λ</a> <a id="4451" href="Data.Int.html#4451" class="Bound">k</a> <a id="4453" class="Symbol">→</a> <a id="4455" class="Symbol">λ</a>
  <a id="4459" class="Symbol">{</a> <a id="4461" class="Symbol">(</a><a id="4462" href="Data.Int.html#4436" class="Bound">i</a> <a id="4464" class="Symbol">=</a> <a id="4466" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="4468" class="Symbol">)</a> <a id="4470" class="Symbol">→</a> <a id="4472" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="4477" href="Data.Int.html#4432" class="Bound">a</a> <a id="4479" href="Data.Int.html#4434" class="Bound">b</a>
  <a id="4483" class="Symbol">;</a> <a id="4485" class="Symbol">(</a><a id="4486" href="Data.Int.html#4438" class="Bound">j</a> <a id="4488" class="Symbol">=</a> <a id="4490" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="4492" class="Symbol">)</a> <a id="4494" class="Symbol">→</a> <a id="4496" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="4501" href="Data.Int.html#4432" class="Bound">a</a> <a id="4503" href="Data.Int.html#4434" class="Bound">b</a>
  <a id="4507" class="Symbol">;</a> <a id="4509" class="Symbol">(</a><a id="4510" href="Data.Int.html#4438" class="Bound">j</a> <a id="4512" class="Symbol">=</a> <a id="4514" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="4516" class="Symbol">)</a> <a id="4518" class="Symbol">→</a> <a id="4520" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="4525" href="Data.Int.html#4432" class="Bound">a</a> <a id="4527" href="Data.Int.html#4434" class="Bound">b</a> <a id="4529" class="Symbol">(</a><a id="4530" href="Data.Int.html#4436" class="Bound">i</a> <a id="4532" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="4534" href="Data.Int.html#4451" class="Bound">k</a><a id="4535" class="Symbol">)</a>
  <a id="4539" class="Symbol">})</a> <a id="4542" class="Symbol">(</a><a id="4543" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="4548" href="Data.Int.html#4432" class="Bound">a</a> <a id="4550" href="Data.Int.html#4434" class="Bound">b</a><a id="4551" class="Symbol">)</a>
</pre>-->
<p>In the other direction, we must be clever: we use path induction, defining a type family <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi></mrow><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{Code}_{a,b}(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Code</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> such that the fibre of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi></mrow><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\id{Code}_{a,b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Code</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(c, d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span> is <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>d</mi><mo>=</mo><mi>b</mi><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a + d = b + c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>.</span> We can then use path induction to construct the map inverse to <span class="Agda"><a href="Data.Int.html#3158" class="Function">same-difference</a></span>. On the way, the first thing we establish is a pair of observations about equalities on the natural numbers: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>n</mi><mo>=</mo><mi>b</mi><mo>+</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">a + n = b + m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mn>1</mn><mo>+</mo><mi>n</mi><mo>=</mo><mi>b</mi><mo>+</mo><mn>1</mn><mo>+</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">a + 1 + n = b + 1 + m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> are equivalent conditions. This can be seen by commutativity and injectivity of the successor function, but below we prove it using equational reasoning, without appealing to commutativity.</p>
<pre class="Agda"><a id="5187" class="Keyword">module</a> <a id="ℤ-Path"></a><a id="5194" href="Data.Int.html#5194" class="Module">ℤ-Path</a> <a id="5201" class="Keyword">where</a>
  <a id="5209" class="Keyword">private</a>
    <a id="5221" class="Keyword">variable</a> <a id="5230" href="Data.Int.html#5230" class="Generalizable">a</a> <a id="5232" href="Data.Int.html#5232" class="Generalizable">b</a> <a id="5234" href="Data.Int.html#5234" class="Generalizable">m</a> <a id="5236" href="Data.Int.html#5236" class="Generalizable">n</a> <a id="5238" href="Data.Int.html#5238" class="Generalizable">c</a> <a id="5240" href="Data.Int.html#5240" class="Generalizable">d</a> <a id="5242" class="Symbol">:</a> <a id="5244" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a>
  <a id="ℤ-Path.encode-p-from"></a><a id="5250" href="Data.Int.html#5250" data-type="a + n ≡ b + m → a + suc n ≡ b + suc m" class="Function">encode-p-from</a> <a id="5264" class="Symbol">:</a> <a id="5266" class="Symbol">(</a><a id="5267" href="Data.Int.html#5230" class="Generalizable">a</a> <a id="5269" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="5271" href="Data.Int.html#5236" class="Generalizable">n</a> <a id="5273" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="5275" href="Data.Int.html#5232" class="Generalizable">b</a> <a id="5277" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="5279" href="Data.Int.html#5234" class="Generalizable">m</a><a id="5280" class="Symbol">)</a> <a id="5282" class="Symbol">→</a> <a id="5284" class="Symbol">(</a><a id="5285" href="Data.Int.html#5230" class="Generalizable">a</a> <a id="5287" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="5289" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="5293" href="Data.Int.html#5236" class="Generalizable">n</a> <a id="5295" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="5297" href="Data.Int.html#5232" class="Generalizable">b</a> <a id="5299" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="5301" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="5305" href="Data.Int.html#5234" class="Generalizable">m</a><a id="5306" class="Symbol">)</a>
  <a id="5310" href="Data.Int.html#5250" data-type="a + n ≡ b + m → a + suc n ≡ b + suc m" class="Function">encode-p-from</a> <a id="5324" class="Symbol">{</a><a id="5325" class="Argument">a</a> <a id="5327" class="Symbol">=</a> <a id="5329" href="Data.Int.html#5329" class="Bound">a</a><a id="5330" class="Symbol">}</a> <a id="5332" class="Symbol">{</a><a id="5333" href="Data.Int.html#5333" class="Bound">n</a><a id="5334" class="Symbol">}</a> <a id="5336" class="Symbol">{</a><a id="5337" href="Data.Int.html#5337" class="Bound">b</a><a id="5338" class="Symbol">}</a> <a id="5340" class="Symbol">{</a><a id="5341" href="Data.Int.html#5341" class="Bound">m</a><a id="5342" class="Symbol">}</a> <a id="5344" href="Data.Int.html#5344" class="Bound">p</a> <a id="5346" class="Symbol">=</a>
    <a id="5352" href="Data.Int.html#5329" class="Bound">a</a> <a id="5354" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="5356" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="5360" href="Data.Int.html#5333" class="Bound">n</a>   <a id="5364" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5367" href="Data.Nat.Properties.html#824" data-type="(x y : Nat) → x + suc y ≡ suc (x + y)" class="Function">+-sucr</a> <a id="5374" href="Data.Int.html#5329" class="Bound">a</a> <a id="5376" href="Data.Int.html#5333" class="Bound">n</a> <a id="5378" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
    <a id="5384" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="5388" class="Symbol">(</a><a id="5389" href="Data.Int.html#5329" class="Bound">a</a> <a id="5391" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="5393" href="Data.Int.html#5333" class="Bound">n</a><a id="5394" class="Symbol">)</a> <a id="5396" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5399" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="5402" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="5406" href="Data.Int.html#5344" class="Bound">p</a> <a id="5408" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
    <a id="5414" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="5418" class="Symbol">(</a><a id="5419" href="Data.Int.html#5337" class="Bound">b</a> <a id="5421" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="5423" href="Data.Int.html#5341" class="Bound">m</a><a id="5424" class="Symbol">)</a> <a id="5426" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">≡˘⟨</a> <a id="5430" href="Data.Nat.Properties.html#824" data-type="(x y : Nat) → x + suc y ≡ suc (x + y)" class="Function">+-sucr</a> <a id="5437" href="Data.Int.html#5337" class="Bound">b</a> <a id="5439" href="Data.Int.html#5341" class="Bound">m</a> <a id="5441" href="1Lab.Path.html#46783" data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" class="Function Operator">⟩</a>
    <a id="5447" href="Data.Int.html#5337" class="Bound">b</a> <a id="5449" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="5451" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="5455" href="Data.Int.html#5341" class="Bound">m</a>   <a id="5459" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

  <a id="ℤ-Path.encode-p-to"></a><a id="5464" href="Data.Int.html#5464" data-type="a + suc n ≡ b + suc m → a + n ≡ b + m" class="Function">encode-p-to</a> <a id="5476" class="Symbol">:</a> <a id="5478" class="Symbol">(</a><a id="5479" href="Data.Int.html#5230" class="Generalizable">a</a> <a id="5481" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="5483" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="5487" href="Data.Int.html#5236" class="Generalizable">n</a> <a id="5489" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="5491" href="Data.Int.html#5232" class="Generalizable">b</a> <a id="5493" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="5495" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="5499" href="Data.Int.html#5234" class="Generalizable">m</a><a id="5500" class="Symbol">)</a> <a id="5502" class="Symbol">→</a> <a id="5504" class="Symbol">(</a><a id="5505" href="Data.Int.html#5230" class="Generalizable">a</a> <a id="5507" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="5509" href="Data.Int.html#5236" class="Generalizable">n</a> <a id="5511" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="5513" href="Data.Int.html#5232" class="Generalizable">b</a> <a id="5515" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="5517" href="Data.Int.html#5234" class="Generalizable">m</a><a id="5518" class="Symbol">)</a>
  <a id="5522" href="Data.Int.html#5464" data-type="a + suc n ≡ b + suc m → a + n ≡ b + m" class="Function">encode-p-to</a> <a id="5534" class="Symbol">{</a><a id="5535" href="Data.Int.html#5535" class="Bound">a</a><a id="5536" class="Symbol">}</a> <a id="5538" class="Symbol">{</a><a id="5539" href="Data.Int.html#5539" class="Bound">n</a><a id="5540" class="Symbol">}</a> <a id="5542" class="Symbol">{</a><a id="5543" href="Data.Int.html#5543" class="Bound">b</a><a id="5544" class="Symbol">}</a> <a id="5546" class="Symbol">{</a><a id="5547" href="Data.Int.html#5547" class="Bound">m</a><a id="5548" class="Symbol">}</a> <a id="5550" href="Data.Int.html#5550" class="Bound">p</a> <a id="5552" class="Symbol">=</a> <a id="5554" href="Data.Nat.Base.html#1635" data-type="suc x ≡ suc y → x ≡ y" class="Function">suc-inj</a> <a id="5562" class="Symbol">(</a><a id="5563" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="5567" class="Symbol">(</a><a id="5568" href="Data.Nat.Properties.html#824" data-type="(x y : Nat) → x + suc y ≡ suc (x + y)" class="Function">+-sucr</a> <a id="5575" href="Data.Int.html#5535" class="Bound">a</a> <a id="5577" href="Data.Int.html#5539" class="Bound">n</a><a id="5578" class="Symbol">)</a> <a id="5580" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="5582" href="Data.Int.html#5550" class="Bound">p</a> <a id="5584" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="5586" href="Data.Nat.Properties.html#824" data-type="(x y : Nat) → x + suc y ≡ suc (x + y)" class="Function">+-sucr</a> <a id="5593" href="Data.Int.html#5543" class="Bound">b</a> <a id="5595" href="Data.Int.html#5547" class="Bound">m</a><a id="5596" class="Symbol">)</a>
</pre>
<p>We then define, fixing two natural numbers <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a, b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span></span></span></span>,</span> the family <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi></mrow><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{Code}_{a,b}(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Code</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> by recursion on the integer <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>.</span> Recall that we want the fibre over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">f</mi></mrow><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\id{diff}(c, d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.07778em;">diff</span></span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span> to be <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>d</mi><mo>=</mo><mi>b</mi><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a + d = b + c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>,</span> so that’s our pick. Now, the <span class="Agda"><a href="Data.Int.html#853" class="InductiveConstructor">quot</a></span> path constructor mandates that the fibre over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(c, d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span> be the same as that over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>c</mi><mo separator="true">,</mo><mn>1</mn><mo>+</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1 + c, 1 + d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span> — but this follows by propositional extensionality and the pair of observations above.</p>
<pre class="Agda">  <a id="ℤ-Path.Code"></a><a id="6035" href="Data.Int.html#6035" data-type="Nat → Nat → Int → Type" class="Function">Code</a> <a id="6040" class="Symbol">:</a> <a id="6042" class="Symbol">∀</a> <a id="6044" class="Symbol">(</a><a id="6045" href="Data.Int.html#6045" class="Bound">a</a> <a id="6047" href="Data.Int.html#6047" class="Bound">b</a> <a id="6049" class="Symbol">:</a> <a id="6051" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a><a id="6054" class="Symbol">)</a> <a id="6056" class="Symbol">(</a><a id="6057" href="Data.Int.html#6057" class="Bound">x</a> <a id="6059" class="Symbol">:</a> <a id="6061" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a><a id="6064" class="Symbol">)</a> <a id="6066" class="Symbol">→</a> <a id="6068" href="1Lab.Type.html#391" class="Primitive">Type</a>
  <a id="6075" href="Data.Int.html#6035" data-type="Nat → Nat → Int → Type" class="Function">Code</a> <a id="6080" href="Data.Int.html#6080" class="Bound">a</a> <a id="6082" href="Data.Int.html#6082" class="Bound">b</a> <a id="6084" class="Symbol">(</a><a id="6085" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="6090" href="Data.Int.html#6090" class="Bound">c</a> <a id="6092" href="Data.Int.html#6092" class="Bound">d</a><a id="6093" class="Symbol">)</a> <a id="6095" class="Symbol">=</a> <a id="6097" href="Data.Int.html#6080" class="Bound">a</a> <a id="6099" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="6101" href="Data.Int.html#6092" class="Bound">d</a> <a id="6103" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="6105" href="Data.Int.html#6082" class="Bound">b</a> <a id="6107" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="6109" href="Data.Int.html#6090" class="Bound">c</a>
  <a id="6113" href="Data.Int.html#6035" data-type="Nat → Nat → Int → Type" class="Function">Code</a> <a id="6118" href="Data.Int.html#6118" class="Bound">a</a> <a id="6120" href="Data.Int.html#6120" class="Bound">b</a> <a id="6122" class="Symbol">(</a><a id="6123" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="6128" href="Data.Int.html#6128" class="Bound">m</a> <a id="6130" href="Data.Int.html#6130" class="Bound">n</a> <a id="6132" href="Data.Int.html#6132" class="Bound">i</a><a id="6133" class="Symbol">)</a> <a id="6135" class="Symbol">=</a> <a id="6137" href="Data.Int.html#6154" data-type="(a b m n : Nat) (i : I) → (a + n ≡ b + m) ≡ (a + suc n ≡ b + suc m)" class="Function">path</a> <a id="6142" href="Data.Int.html#6132" class="Bound">i</a> <a id="6144" class="Keyword">where</a>
    <a id="6154" href="Data.Int.html#6154" data-type="(a b m n : Nat) (i : I) → (a + n ≡ b + m) ≡ (a + suc n ≡ b + suc m)" class="Function">path</a> <a id="6159" class="Symbol">:</a> <a id="6161" class="Symbol">(</a><a id="6162" href="Data.Int.html#6118" class="Bound">a</a> <a id="6164" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="6166" href="Data.Int.html#6130" class="Bound">n</a> <a id="6168" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="6170" href="Data.Int.html#6120" class="Bound">b</a> <a id="6172" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="6174" href="Data.Int.html#6128" class="Bound">m</a><a id="6175" class="Symbol">)</a> <a id="6177" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="6179" class="Symbol">(</a><a id="6180" href="Data.Int.html#6118" class="Bound">a</a> <a id="6182" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="6184" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="6188" href="Data.Int.html#6130" class="Bound">n</a> <a id="6190" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="6192" href="Data.Int.html#6120" class="Bound">b</a> <a id="6194" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="6196" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="6200" href="Data.Int.html#6128" class="Bound">m</a><a id="6201" class="Symbol">)</a>
    <a id="6207" href="Data.Int.html#6154" data-type="(a b m n : Nat) (i : I) → (a + n ≡ b + m) ≡ (a + suc n ≡ b + suc m)" class="Function">path</a> <a id="6212" class="Symbol">=</a> <a id="6214" href="1Lab.Univalence.html#8818" data-type="A ≃ B₁ → A ≡ B₁" class="Function">ua</a> <a id="6217" class="Symbol">(</a><a id="6218" href="1Lab.Equiv.html#23456" data-type="is-prop P → is-prop Q → (P → Q) → (Q → P) → P ≃ Q" class="Function">prop-ext</a> <a id="6227" class="Symbol">(</a><a id="6228" href="Data.Nat.Base.html#2530" data-type="is-set Nat" class="Function">Nat-is-set</a> <a id="6239" class="Symbol">_</a> <a id="6241" class="Symbol">_)</a> <a id="6244" class="Symbol">(</a><a id="6245" href="Data.Nat.Base.html#2530" data-type="is-set Nat" class="Function">Nat-is-set</a> <a id="6256" class="Symbol">_</a> <a id="6258" class="Symbol">_)</a> <a id="6261" href="Data.Int.html#5250" data-type="a + n ≡ b + m → a + suc n ≡ b + suc m" class="Function">encode-p-from</a> <a id="6275" href="Data.Int.html#5464" data-type="a + suc n ≡ b + suc m → a + n ≡ b + m" class="Function">encode-p-to</a><a id="6286" class="Symbol">)</a>
</pre>
<p>Hence, if we have a path <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">f</mi></mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\id{diff}(a, b) = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.07778em;">diff</span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>,</span> we can apply path induction, whence it suffices to consider the case where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> is literally_ the difference of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> and <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>.</span> To lift this into our <span class="Agda"><a href="Data.Int.html#6035" class="Function">Code</a></span> fibration, we must show that <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>=</mo><mi>b</mi><mo>+</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a + b = b + a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>,</span> but this is exactly commutativity of addition on <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\bb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span>.</span></p>
<pre class="Agda">  <a id="ℤ-Path.encode"></a><a id="6617" href="Data.Int.html#6617" data-type="(a b : Nat) (x : Int) → diff a b ≡ x → Code a b x" class="Function">encode</a> <a id="6624" class="Symbol">:</a> <a id="6626" class="Symbol">∀</a> <a id="6628" class="Symbol">(</a><a id="6629" href="Data.Int.html#6629" class="Bound">a</a> <a id="6631" href="Data.Int.html#6631" class="Bound">b</a> <a id="6633" class="Symbol">:</a> <a id="6635" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a><a id="6638" class="Symbol">)</a> <a id="6640" class="Symbol">(</a><a id="6641" href="Data.Int.html#6641" class="Bound">x</a> <a id="6643" class="Symbol">:</a> <a id="6645" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a><a id="6648" class="Symbol">)</a> <a id="6650" class="Symbol">→</a> <a id="6652" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="6657" href="Data.Int.html#6629" class="Bound">a</a> <a id="6659" href="Data.Int.html#6631" class="Bound">b</a> <a id="6661" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="6663" href="Data.Int.html#6641" class="Bound">x</a> <a id="6665" class="Symbol">→</a> <a id="6667" href="Data.Int.html#6035" data-type="Nat → Nat → Int → Type" class="Function">Code</a> <a id="6672" href="Data.Int.html#6629" class="Bound">a</a> <a id="6674" href="Data.Int.html#6631" class="Bound">b</a> <a id="6676" href="Data.Int.html#6641" class="Bound">x</a>
  <a id="6680" href="Data.Int.html#6617" data-type="(a b : Nat) (x : Int) → diff a b ≡ x → Code a b x" class="Function">encode</a> <a id="6687" href="Data.Int.html#6687" class="Bound">a</a> <a id="6689" href="Data.Int.html#6689" class="Bound">b</a> <a id="6691" href="Data.Int.html#6691" class="Bound">x</a> <a id="6693" class="Symbol">=</a> <a id="6695" href="1Lab.Path.html#19544" data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" class="Function">J</a> <a id="6697" class="Symbol">(λ</a> <a id="6700" href="Data.Int.html#6700" class="Bound">x</a> <a id="6702" href="Data.Int.html#6702" class="Bound">p</a> <a id="6704" class="Symbol">→</a> <a id="6706" href="Data.Int.html#6035" data-type="Nat → Nat → Int → Type" class="Function">Code</a> <a id="6711" href="Data.Int.html#6687" class="Bound">a</a> <a id="6713" href="Data.Int.html#6689" class="Bound">b</a> <a id="6715" href="Data.Int.html#6700" class="Bound">x</a><a id="6716" class="Symbol">)</a> <a id="6718" class="Symbol">(</a><a id="6719" href="Data.Nat.Properties.html#932" data-type="(x y : Nat) → x + y ≡ y + x" class="Function">+-commutative</a> <a id="6733" href="Data.Int.html#6687" class="Bound">a</a> <a id="6735" href="Data.Int.html#6689" class="Bound">b</a><a id="6736" class="Symbol">)</a>
</pre>
<p>As a finishing touch, we give <code>Int</code> instances for <span class="Agda"><a href="Agda.Builtin.FromNat.html#197" class="Record">Number</a></span> and <span class="Agda"><a href="Agda.Builtin.FromNeg.html#197" class="Record">Negative</a></span>, meaning that we can use positive and negative integer literals to denote values of <span class="Agda"><a href="Data.Int.html#807" class="Datatype">Int</a></span>.</p>
<pre class="Agda"><a id="6938" class="Keyword">instance</a>
  <a id="Number-Int"></a><a id="6949" href="Data.Int.html#6949" data-type="Number Int" class="Function">Number-Int</a> <a id="6960" class="Symbol">:</a> <a id="6962" href="Agda.Builtin.FromNat.html#197" data-type="(A : Type a) → Type (lsuc a)" class="Record">Number</a> <a id="6969" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a>
  <a id="6975" href="Data.Int.html#6949" data-type="Number Int" class="Function">Number-Int</a> <a id="6986" class="Symbol">.</a><a id="6987" href="Agda.Builtin.FromNat.html#253" data-type="Number A → Nat → Type a" class="Field">Number.Constraint</a> <a id="7005" class="Symbol">_</a> <a id="7007" class="Symbol">=</a> <a id="7009" href="Agda.Builtin.Unit.html#164" data-type="Type" class="Record">⊤</a>
  <a id="7013" href="Data.Int.html#6949" data-type="Number Int" class="Function">Number-Int</a> <a id="7024" class="Symbol">.</a><a id="7025" href="Agda.Builtin.FromNat.html#282" data-type="(r : Number A) (n : Nat) ⦃ _ : Constraint r n ⦄ → A" class="Field">Number.fromNat</a> <a id="7040" href="Data.Int.html#7040" class="Bound">n</a> <a id="7042" class="Symbol">=</a> <a id="7044" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="7049" href="Data.Int.html#7040" class="Bound">n</a> <a id="7051" class="Number">0</a>

  <a id="Negative-Int"></a><a id="7056" href="Data.Int.html#7056" data-type="Negative Int" class="Function">Negative-Int</a> <a id="7069" class="Symbol">:</a> <a id="7071" href="Agda.Builtin.FromNeg.html#197" data-type="(A : Type a) → Type (lsuc a)" class="Record">Negative</a> <a id="7080" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a>
  <a id="7086" href="Data.Int.html#7056" data-type="Negative Int" class="Function">Negative-Int</a> <a id="7099" class="Symbol">.</a><a id="7100" href="Agda.Builtin.FromNeg.html#255" data-type="Negative A → Nat → Type a" class="Field">Negative.Constraint</a> <a id="7120" class="Symbol">_</a> <a id="7122" class="Symbol">=</a> <a id="7124" href="Agda.Builtin.Unit.html#164" data-type="Type" class="Record">⊤</a>
  <a id="7128" href="Data.Int.html#7056" data-type="Negative Int" class="Function">Negative-Int</a> <a id="7141" class="Symbol">.</a><a id="7142" href="Agda.Builtin.FromNeg.html#284" data-type="(r : Negative A) (n : Nat) ⦃ _ : Constraint r n ⦄ → A" class="Field">Negative.fromNeg</a> <a id="7159" href="Data.Int.html#7159" class="Bound">n</a> <a id="7161" class="Symbol">=</a> <a id="7163" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="7168" class="Number">0</a> <a id="7170" href="Data.Int.html#7159" class="Bound">n</a>
</pre>
<h2 id="h-level"><a href="#h-level" class="header-link">h-level<span class="header-link-emoji">🔗</span></a></h2>
<p>To prove that <span class="Agda"><a href="Data.Int.html#807" class="Datatype">Int</a></span> is <a href="1Lab.HLevel.html#3356">a set</a>, we prove that it is equivalent to an inductive (rather than <em>higher</em>-inductive) representation of the integers. Since this latter representation (which we call <span class="Agda"><a href="Data.Int.html#7556" class="Datatype">Int&#39;</a></span>) has decidable equality, it is a set.</p>
<pre class="Agda"><a id="7486" class="Keyword">module</a> <a id="7493" href="Data.Int.html#7493" class="Module">_</a> <a id="7495" class="Keyword">where</a>
  <a id="7503" class="Keyword">open</a> <a id="7508" class="Keyword">import</a> <a id="7515" href="Data.Int.Inductive.html" class="Module">Data.Int.Inductive</a>
    <a id="7538" class="Keyword">renaming</a> <a id="7547" class="Symbol">(</a> <a id="7549" href="Agda.Builtin.Int.html#246" data-type="Type" class="Datatype">Int</a> <a id="7553" class="Symbol">to</a> <a id="7556" class="Datatype">Int&#39;</a>
             <a id="7574" class="Symbol">;</a> <a id="7576" href="Data.Int.Inductive.html#1175" data-type="Discrete Int" class="Function">Discrete-Int</a> <a id="7589" class="Symbol">to</a> <a id="7592" class="Function">Discrete-Int&#39;</a>
             <a id="7619" class="Symbol">)</a>
</pre>
<p>There is a canonical map which takes pairs of naturals to their difference as an <span class="Agda"><a href="Data.Int.html#7556" class="Datatype">Int&#39;</a></span>, which is <span class="Agda"><a href="Data.Int.Inductive.html#856" class="Function Operator">ℕ-</a></span>; It can be shown that this map extends to a function from <span class="Agda"><a href="Data.Int.html#807" class="Datatype">Int</a></span>, since it respects the generating equation <span class="Agda"><a href="Data.Int.html#853" class="InductiveConstructor">quot</a></span> definitionally:</p>
<pre class="Agda">  <a id="7898" class="Keyword">private</a>
    <a id="7910" href="Data.Int.html#7910" data-type="Int → Int" class="Function">to-inductive</a> <a id="7923" class="Symbol">:</a> <a id="7925" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a> <a id="7929" class="Symbol">→</a> <a id="7931" href="Data.Int.html#7556" class="Datatype">Int&#39;</a>
    <a id="7940" href="Data.Int.html#7910" data-type="Int → Int" class="Function">to-inductive</a> <a id="7953" class="Symbol">(</a><a id="7954" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="7959" href="Data.Int.html#7959" class="Bound">x</a> <a id="7961" href="Data.Int.html#7961" class="Bound">y</a><a id="7962" class="Symbol">)</a> <a id="7964" class="Symbol">=</a> <a id="7966" href="Data.Int.html#7959" class="Bound">x</a> <a id="7968" href="Data.Int.Inductive.html#856" data-type="Nat → Nat → Int" class="Function Operator">ℕ-</a> <a id="7971" href="Data.Int.html#7961" class="Bound">y</a>
    <a id="7977" href="Data.Int.html#7910" data-type="Int → Int" class="Function">to-inductive</a> <a id="7990" class="Symbol">(</a><a id="7991" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="7996" href="Data.Int.html#7996" class="Bound">m</a> <a id="7998" href="Data.Int.html#7998" class="Bound">n</a> <a id="8000" href="Data.Int.html#8000" class="Bound">i</a><a id="8001" class="Symbol">)</a> <a id="8003" class="Symbol">=</a> <a id="8005" href="Data.Int.html#7996" class="Bound">m</a> <a id="8007" href="Data.Int.Inductive.html#856" data-type="Nat → Nat → Int" class="Function Operator">ℕ-</a> <a id="8010" href="Data.Int.html#7998" class="Bound">n</a>

    <a id="8017" href="Data.Int.html#8017" data-type="Int → Int" class="Function">from-inductive</a> <a id="8032" class="Symbol">:</a> <a id="8034" href="Data.Int.html#7556" class="Datatype">Int&#39;</a> <a id="8039" class="Symbol">→</a> <a id="8041" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a>
    <a id="8049" href="Data.Int.html#8017" data-type="Int → Int" class="Function">from-inductive</a> <a id="8064" class="Symbol">(</a><a id="8065" href="Agda.Builtin.Int.html#264" data-type="Nat → Int" class="InductiveConstructor">pos</a> <a id="8069" href="Data.Int.html#8069" class="Bound">x</a><a id="8070" class="Symbol">)</a> <a id="8072" class="Symbol">=</a> <a id="8074" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="8079" href="Data.Int.html#8069" class="Bound">x</a> <a id="8081" class="Number">0</a>
    <a id="8087" href="Data.Int.html#8017" data-type="Int → Int" class="Function">from-inductive</a> <a id="8102" class="Symbol">(</a><a id="8103" href="Agda.Builtin.Int.html#291" data-type="Nat → Int" class="InductiveConstructor">negsuc</a> <a id="8110" href="Data.Int.html#8110" class="Bound">x</a><a id="8111" class="Symbol">)</a> <a id="8113" class="Symbol">=</a> <a id="8115" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="8120" class="Number">0</a> <a id="8122" class="Symbol">(</a><a id="8123" class="Number">1</a> <a id="8125" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="8127" href="Data.Int.html#8110" class="Bound">x</a><a id="8128" class="Symbol">)</a>
</pre>
<p>Mapping from <span class="Agda"><a href="Data.Int.html#7556" class="Datatype">Int&#39;</a></span> to <span class="Agda"><a href="Data.Int.html#807" class="Datatype">Int</a></span> sends the positive numbers to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> and the negative numbers to <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0, x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>.</span> Note that the left summand (the “negative numbers”) in the inductive definition of <span class="Agda"><a href="Data.Int.html#7556" class="Datatype">Int&#39;</a></span> are offset by one; Hence, the mapping out of <span class="Agda"><a href="Agda.Builtin.Int.html#291" class="InductiveConstructor">negsuc</a></span> sends <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> (which really represents the number <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">-(1+x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>)</span> to… well, <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">-(1 + x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>.</span></p>
<p>Using the helpers <span class="Agda"><a href="Data.Int.html#4358" class="Function">quot-triangle</a></span> and <span class="Agda"><a href="Data.Int.html#3926" class="Function">quot-diamond</a></span>, we construct an inductive proof that the integers are a retract of Agda’s built-in <span class="Agda"><a href="Data.Int.html#7556" class="Datatype">Int&#39;</a></span> type; Since the latter is a set, then so is ours!</p>
<pre class="Agda">    <a id="8722" href="Data.Int.html#8722" data-type="(x : Int) → from-inductive (to-inductive x) ≡ x" class="Function">to-from-inductive</a> <a id="8740" class="Symbol">:</a> <a id="8742" class="Symbol">(</a><a id="8743" href="Data.Int.html#8743" class="Bound">x</a> <a id="8745" class="Symbol">:</a> <a id="8747" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a><a id="8750" class="Symbol">)</a> <a id="8752" class="Symbol">→</a> <a id="8754" href="Data.Int.html#8017" data-type="Int → Int" class="Function">from-inductive</a> <a id="8769" class="Symbol">(</a><a id="8770" href="Data.Int.html#7910" data-type="Int → Int" class="Function">to-inductive</a> <a id="8783" href="Data.Int.html#8743" class="Bound">x</a><a id="8784" class="Symbol">)</a> <a id="8786" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="8788" href="Data.Int.html#8743" class="Bound">x</a>
    <a id="8794" href="Data.Int.html#8722" data-type="(x : Int) → from-inductive (to-inductive x) ≡ x" class="Function">to-from-inductive</a> <a id="8812" class="Symbol">(</a><a id="8813" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="8818" href="Data.Int.html#8818" class="Bound">x</a> <a id="8820" href="Agda.Builtin.Nat.html#210" data-type="Nat" class="InductiveConstructor">zero</a><a id="8824" class="Symbol">)</a>            <a id="8837" class="Symbol">=</a> <a id="8839" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
    <a id="8848" href="Data.Int.html#8722" data-type="(x : Int) → from-inductive (to-inductive x) ≡ x" class="Function">to-from-inductive</a> <a id="8866" class="Symbol">(</a><a id="8867" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="8872" href="Agda.Builtin.Nat.html#210" data-type="Nat" class="InductiveConstructor">zero</a> <a id="8877" class="Symbol">(</a><a id="8878" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="8882" href="Data.Int.html#8882" class="Bound">y</a><a id="8883" class="Symbol">))</a>      <a id="8891" class="Symbol">=</a> <a id="8893" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
    <a id="8902" href="Data.Int.html#8722" data-type="(x : Int) → from-inductive (to-inductive x) ≡ x" class="Function">to-from-inductive</a> <a id="8920" class="Symbol">(</a><a id="8921" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="8926" class="Symbol">(</a><a id="8927" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="8931" href="Data.Int.html#8931" class="Bound">x</a><a id="8932" class="Symbol">)</a> <a id="8934" class="Symbol">(</a><a id="8935" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="8939" href="Data.Int.html#8939" class="Bound">y</a><a id="8940" class="Symbol">))</a>   <a id="8945" class="Symbol">=</a> <a id="8947" href="Data.Int.html#8722" data-type="(x : Int) → from-inductive (to-inductive x) ≡ x" class="Function">to-from-inductive</a> <a id="8965" class="Symbol">(</a><a id="8966" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="8971" href="Data.Int.html#8931" class="Bound">x</a> <a id="8973" href="Data.Int.html#8939" class="Bound">y</a><a id="8974" class="Symbol">)</a> <a id="8976" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="8978" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="8983" class="Symbol">_</a> <a id="8985" class="Symbol">_</a>

    <a id="8992" href="Data.Int.html#8722" data-type="(x : Int) → from-inductive (to-inductive x) ≡ x" class="Function">to-from-inductive</a> <a id="9010" class="Symbol">(</a><a id="9011" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="9016" href="Data.Int.html#9016" class="Bound">m</a> <a id="9018" href="Agda.Builtin.Nat.html#210" data-type="Nat" class="InductiveConstructor">zero</a> <a id="9023" href="Data.Int.html#9023" class="Bound">i</a><a id="9024" class="Symbol">)</a>          <a id="9035" class="Symbol">=</a> <a id="9037" href="Data.Int.html#4358" data-type="(a b : Nat) (i : I) → diff a b ≡ quot a b i" class="Function">quot-triangle</a> <a id="9051" class="Symbol">_</a> <a id="9053" class="Symbol">_</a> <a id="9055" href="Data.Int.html#9023" class="Bound">i</a>
    <a id="9061" href="Data.Int.html#8722" data-type="(x : Int) → from-inductive (to-inductive x) ≡ x" class="Function">to-from-inductive</a> <a id="9079" class="Symbol">(</a><a id="9080" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="9085" href="Agda.Builtin.Nat.html#210" data-type="Nat" class="InductiveConstructor">zero</a> <a id="9090" class="Symbol">(</a><a id="9091" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="9095" href="Data.Int.html#9095" class="Bound">n</a><a id="9096" class="Symbol">)</a> <a id="9098" href="Data.Int.html#9098" class="Bound">i</a><a id="9099" class="Symbol">)</a>    <a id="9104" class="Symbol">=</a> <a id="9106" href="Data.Int.html#4358" data-type="(a b : Nat) (i : I) → diff a b ≡ quot a b i" class="Function">quot-triangle</a> <a id="9120" class="Symbol">_</a> <a id="9122" class="Symbol">_</a> <a id="9124" href="Data.Int.html#9098" class="Bound">i</a>
    <a id="9130" href="Data.Int.html#8722" data-type="(x : Int) → from-inductive (to-inductive x) ≡ x" class="Function">to-from-inductive</a> <a id="9148" class="Symbol">(</a><a id="9149" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="9154" class="Symbol">(</a><a id="9155" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="9159" href="Data.Int.html#9159" class="Bound">m</a><a id="9160" class="Symbol">)</a> <a id="9162" class="Symbol">(</a><a id="9163" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="9167" href="Data.Int.html#9167" class="Bound">n</a><a id="9168" class="Symbol">)</a> <a id="9170" href="Data.Int.html#9170" class="Bound">i</a><a id="9171" class="Symbol">)</a> <a id="9173" class="Symbol">=</a>
      <a id="9181" href="Data.Int.html#8722" data-type="(x : Int) → from-inductive (to-inductive x) ≡ x" class="Function">to-from-inductive</a> <a id="9199" class="Symbol">(</a><a id="9200" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="9205" class="Symbol">_</a> <a id="9207" class="Symbol">_</a> <a id="9209" href="Data.Int.html#9170" class="Bound">i</a><a id="9210" class="Symbol">)</a> <a id="9212" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="9214" href="Data.Int.html#3926" data-type="(a b : Nat) →
Square (quot a b) (quot a b) (quot (suc a) (suc b))
(quot (suc a) (suc b))" class="Function">quot-diamond</a> <a id="9227" class="Symbol">_</a> <a id="9229" class="Symbol">_</a> <a id="9231" href="Data.Int.html#9170" class="Bound">i</a>

  <a id="9236" href="Data.Int.html#9236" data-type="is-set Int" class="Function">Int-is-set</a> <a id="9247" class="Symbol">:</a> <a id="9249" href="1Lab.HLevel.html#3356" data-type="Type ℓ → Type ℓ" class="Function">is-set</a> <a id="9256" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a>
  <a id="9262" href="Data.Int.html#9236" data-type="is-set Int" class="Function">Int-is-set</a> <a id="9273" class="Symbol">=</a> <a id="9275" href="1Lab.HLevel.Retracts.html#1658" data-type="(n : Nat) (f : A → B₁) (g : B₁ → A) →
is-left-inverse f g → is-hlevel A n → is-hlevel B₁ n" class="Function">retract→is-hlevel</a> <a id="9293" class="Number">2</a> <a id="9295" href="Data.Int.html#8017" data-type="Int → Int" class="Function">from-inductive</a> <a id="9310" href="Data.Int.html#7910" data-type="Int → Int" class="Function">to-inductive</a> <a id="9323" href="Data.Int.html#8722" data-type="(x : Int) → from-inductive (to-inductive x) ≡ x" class="Function">to-from-inductive</a>
    <a id="9345" class="Symbol">(</a><a id="9346" href="1Lab.HLevel.Sets.html#3125" data-type="Discrete A → is-set A" class="Function">Discrete→is-set</a> <a id="9362" href="Data.Int.html#7592" class="Function">Discrete-Int&#39;</a><a id="9375" class="Symbol">)</a>
</pre>
<h1 id="recursion"><a href="#recursion" class="header-link">Recursion<span class="header-link-emoji">🔗</span></a></h1>
<p>If we want to define a map <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi mathvariant="double-struck">Z</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">f : \bb{Z} \to X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">Z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>,</span> it suffices to give a function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi mathvariant="double-struck">N</mi><mn>2</mn></msup><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">f : \bb{N}^2 \to X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathbb">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> which respects the quotient, in the following sense:</p>
<pre class="Agda"><a id="Int-rec"></a><a id="9556" href="Data.Int.html#9556" data-type="(f : Nat → Nat → X) →
((a b : Nat) → f a b ≡ f (suc a) (suc b)) → Int → X" class="Function">Int-rec</a> <a id="9564" class="Symbol">:</a> <a id="9566" class="Symbol">∀</a> <a id="9568" class="Symbol">{</a><a id="9569" href="Data.Int.html#9569" class="Bound">ℓ</a><a id="9570" class="Symbol">}</a> <a id="9572" class="Symbol">{</a><a id="9573" href="Data.Int.html#9573" class="Bound">X</a> <a id="9575" class="Symbol">:</a> <a id="9577" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="9582" href="Data.Int.html#9569" class="Bound">ℓ</a><a id="9583" class="Symbol">}</a>
        <a id="9593" class="Symbol">→</a> <a id="9595" class="Symbol">(</a><a id="9596" href="Data.Int.html#9596" class="Bound">f</a> <a id="9598" class="Symbol">:</a> <a id="9600" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="9604" class="Symbol">→</a> <a id="9606" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="9610" class="Symbol">→</a> <a id="9612" href="Data.Int.html#9573" class="Bound">X</a><a id="9613" class="Symbol">)</a>
        <a id="9623" class="Symbol">→</a> <a id="9625" class="Symbol">(</a><a id="9626" href="Data.Int.html#9626" class="Bound">q</a> <a id="9628" class="Symbol">:</a> <a id="9630" class="Symbol">(</a><a id="9631" href="Data.Int.html#9631" class="Bound">a</a> <a id="9633" href="Data.Int.html#9633" class="Bound">b</a> <a id="9635" class="Symbol">:</a> <a id="9637" class="Symbol">_)</a> <a id="9640" class="Symbol">→</a> <a id="9642" href="Data.Int.html#9596" class="Bound">f</a> <a id="9644" href="Data.Int.html#9631" class="Bound">a</a> <a id="9646" href="Data.Int.html#9633" class="Bound">b</a> <a id="9648" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="9650" href="Data.Int.html#9596" class="Bound">f</a> <a id="9652" class="Symbol">(</a><a id="9653" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="9657" href="Data.Int.html#9631" class="Bound">a</a><a id="9658" class="Symbol">)</a> <a id="9660" class="Symbol">(</a><a id="9661" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="9665" href="Data.Int.html#9633" class="Bound">b</a><a id="9666" class="Symbol">))</a>
        <a id="9677" class="Symbol">→</a> <a id="9679" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a> <a id="9683" class="Symbol">→</a> <a id="9685" href="Data.Int.html#9573" class="Bound">X</a>
<a id="9687" href="Data.Int.html#9556" data-type="(f : Nat → Nat → X) →
((a b : Nat) → f a b ≡ f (suc a) (suc b)) → Int → X" class="Function">Int-rec</a> <a id="9695" href="Data.Int.html#9695" class="Bound">f</a> <a id="9697" href="Data.Int.html#9697" class="Bound">q</a> <a id="9699" class="Symbol">(</a><a id="9700" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="9705" href="Data.Int.html#9705" class="Bound">x</a> <a id="9707" href="Data.Int.html#9707" class="Bound">y</a><a id="9708" class="Symbol">)</a> <a id="9710" class="Symbol">=</a> <a id="9712" href="Data.Int.html#9695" class="Bound">f</a> <a id="9714" href="Data.Int.html#9705" class="Bound">x</a> <a id="9716" href="Data.Int.html#9707" class="Bound">y</a>
<a id="9718" href="Data.Int.html#9556" data-type="(f : Nat → Nat → X) →
((a b : Nat) → f a b ≡ f (suc a) (suc b)) → Int → X" class="Function">Int-rec</a> <a id="9726" href="Data.Int.html#9726" class="Bound">f</a> <a id="9728" href="Data.Int.html#9728" class="Bound">q</a> <a id="9730" class="Symbol">(</a><a id="9731" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="9736" href="Data.Int.html#9736" class="Bound">m</a> <a id="9738" href="Data.Int.html#9738" class="Bound">n</a> <a id="9740" href="Data.Int.html#9740" class="Bound">i</a><a id="9741" class="Symbol">)</a> <a id="9743" class="Symbol">=</a> <a id="9745" href="Data.Int.html#9728" class="Bound">q</a> <a id="9747" href="Data.Int.html#9736" class="Bound">m</a> <a id="9749" href="Data.Int.html#9738" class="Bound">n</a> <a id="9751" href="Data.Int.html#9740" class="Bound">i</a>
</pre>
<p>However, since <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> can be a more general space, not necessarily a <em>set</em>, defining a <em>binary</em> operation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>:</mo><msup><mi mathvariant="double-struck">Z</mi><mn>2</mn></msup><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">f&#39; : \bb{Z}^2 \to X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> can be quite involved! It doesn’t suffice to exhibit a function from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">N</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\bb{N}^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathbb">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span> which respects the quotient separately in each argument:</p>
<pre class="Agda"><a id="Int-rec₂"></a><a id="10029" href="Data.Int.html#10029" data-type="(f : Nat × Nat → Nat × Nat → B₁)
(pl
 : (a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y))
(pr
 : (a b x y : Nat) →
   f (a , b) (x , y) ≡ f (a , b) (suc x , suc y)) →
((a b x y : Nat) →
 Square (pl a b x y) (pr a b x y) (pr (suc a) (suc b) x y)
 (pl a b (suc x) (suc y))) →
Int → Int → B₁" class="Function">Int-rec₂</a> <a id="10038" class="Symbol">:</a> <a id="10040" class="Symbol">∀</a> <a id="10042" class="Symbol">{</a><a id="10043" href="Data.Int.html#10043" class="Bound">ℓ</a><a id="10044" class="Symbol">}</a> <a id="10046" class="Symbol">{</a><a id="10047" href="Data.Int.html#10047" class="Bound">B</a> <a id="10049" class="Symbol">:</a> <a id="10051" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="10056" href="Data.Int.html#10043" class="Bound">ℓ</a><a id="10057" class="Symbol">}</a>
         <a id="10068" class="Symbol">→</a> <a id="10070" class="Symbol">(</a><a id="10071" href="Data.Int.html#10071" class="Bound">f</a> <a id="10073" class="Symbol">:</a> <a id="10075" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="10079" href="1Lab.Type.html#1846" data-type="Type a → Type b → Type (a ⊔ b)" class="Function Operator">×</a> <a id="10081" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="10085" class="Symbol">→</a> <a id="10087" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="10091" href="1Lab.Type.html#1846" data-type="Type a → Type b → Type (a ⊔ b)" class="Function Operator">×</a> <a id="10093" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="10097" class="Symbol">→</a> <a id="10099" href="Data.Int.html#10047" class="Bound">B</a><a id="10100" class="Symbol">)</a>
         <a id="10111" class="Symbol">→</a> <a id="10113" class="Symbol">(</a><a id="10114" href="Data.Int.html#10114" class="Bound">pl</a>     <a id="10121" class="Symbol">:</a> <a id="10123" class="Symbol">(</a><a id="10124" href="Data.Int.html#10124" class="Bound">a</a> <a id="10126" href="Data.Int.html#10126" class="Bound">b</a> <a id="10128" href="Data.Int.html#10128" class="Bound">x</a> <a id="10130" href="Data.Int.html#10130" class="Bound">y</a> <a id="10132" class="Symbol">:</a> <a id="10134" class="Symbol">_)</a> <a id="10137" class="Symbol">→</a> <a id="10139" href="Data.Int.html#10071" class="Bound">f</a> <a id="10141" class="Symbol">(</a><a id="10142" href="Data.Int.html#10124" class="Bound">a</a> <a id="10144" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="10146" href="Data.Int.html#10126" class="Bound">b</a><a id="10147" class="Symbol">)</a> <a id="10149" class="Symbol">(</a><a id="10150" href="Data.Int.html#10128" class="Bound">x</a> <a id="10152" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="10154" href="Data.Int.html#10130" class="Bound">y</a><a id="10155" class="Symbol">)</a> <a id="10157" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="10159" href="Data.Int.html#10071" class="Bound">f</a> <a id="10161" class="Symbol">(</a><a id="10162" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="10166" href="Data.Int.html#10124" class="Bound">a</a> <a id="10168" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="10170" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="10174" href="Data.Int.html#10126" class="Bound">b</a><a id="10175" class="Symbol">)</a> <a id="10177" class="Symbol">(</a><a id="10178" href="Data.Int.html#10128" class="Bound">x</a> <a id="10180" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="10182" href="Data.Int.html#10130" class="Bound">y</a><a id="10183" class="Symbol">))</a>
         <a id="10195" class="Symbol">→</a> <a id="10197" class="Symbol">(</a><a id="10198" href="Data.Int.html#10198" class="Bound">pr</a>     <a id="10205" class="Symbol">:</a> <a id="10207" class="Symbol">(</a><a id="10208" href="Data.Int.html#10208" class="Bound">a</a> <a id="10210" href="Data.Int.html#10210" class="Bound">b</a> <a id="10212" href="Data.Int.html#10212" class="Bound">x</a> <a id="10214" href="Data.Int.html#10214" class="Bound">y</a> <a id="10216" class="Symbol">:</a> <a id="10218" class="Symbol">_)</a> <a id="10221" class="Symbol">→</a> <a id="10223" href="Data.Int.html#10071" class="Bound">f</a> <a id="10225" class="Symbol">(</a><a id="10226" href="Data.Int.html#10208" class="Bound">a</a> <a id="10228" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="10230" href="Data.Int.html#10210" class="Bound">b</a><a id="10231" class="Symbol">)</a> <a id="10233" class="Symbol">(</a><a id="10234" href="Data.Int.html#10212" class="Bound">x</a> <a id="10236" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="10238" href="Data.Int.html#10214" class="Bound">y</a><a id="10239" class="Symbol">)</a> <a id="10241" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="10243" href="Data.Int.html#10071" class="Bound">f</a> <a id="10245" class="Symbol">(</a><a id="10246" href="Data.Int.html#10208" class="Bound">a</a> <a id="10248" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="10250" href="Data.Int.html#10210" class="Bound">b</a><a id="10251" class="Symbol">)</a> <a id="10253" class="Symbol">(</a><a id="10254" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="10258" href="Data.Int.html#10212" class="Bound">x</a> <a id="10260" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="10262" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="10266" href="Data.Int.html#10214" class="Bound">y</a><a id="10267" class="Symbol">))</a>
</pre>
<p>In addition, we must have that these two <em>paths</em> <code>pl</code> and <code>pr</code> are <em>coherent</em>. There are two ways of obtaining an equality <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi mathvariant="normal">S</mi><mi>a</mi><mo separator="true">,</mo><mi mathvariant="normal">S</mi><mi>b</mi><mo separator="true">,</mo><mi mathvariant="normal">S</mi><mi>x</mi><mo separator="true">,</mo><mi mathvariant="normal">S</mi><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(a, b, x, y) = f(\id{S}a,\id{S}b,\id{S}x,\id{S}y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathrm">S</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathrm">S</span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathrm">S</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathrm">S</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> (<code>pl</code> after <code>pr</code> and <code>pr</code> after <code>pl</code>, respectively) and these <em>must</em> be homotopic:</p>
<pre class="Agda">         <a id="10552" class="Symbol">→</a> <a id="10554" class="Symbol">(</a><a id="10555" href="Data.Int.html#10555" class="Bound">square</a> <a id="10562" class="Symbol">:</a> <a id="10564" class="Symbol">(</a><a id="10565" href="Data.Int.html#10565" class="Bound">a</a> <a id="10567" href="Data.Int.html#10567" class="Bound">b</a> <a id="10569" href="Data.Int.html#10569" class="Bound">x</a> <a id="10571" href="Data.Int.html#10571" class="Bound">y</a> <a id="10573" class="Symbol">:</a> <a id="10575" class="Symbol">_)</a> <a id="10578" class="Symbol">→</a>
              <a id="10594" href="1Lab.Path.html#9409" data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" class="Function">Square</a> <a id="10601" class="Symbol">(</a><a id="10602" href="Data.Int.html#10114" class="Bound">pl</a> <a id="10605" href="Data.Int.html#10565" class="Bound">a</a> <a id="10607" href="Data.Int.html#10567" class="Bound">b</a> <a id="10609" href="Data.Int.html#10569" class="Bound">x</a> <a id="10611" href="Data.Int.html#10571" class="Bound">y</a><a id="10612" class="Symbol">)</a> <a id="10614" class="Symbol">(</a><a id="10615" href="Data.Int.html#10198" class="Bound">pr</a> <a id="10618" href="Data.Int.html#10565" class="Bound">a</a> <a id="10620" href="Data.Int.html#10567" class="Bound">b</a> <a id="10622" href="Data.Int.html#10569" class="Bound">x</a> <a id="10624" href="Data.Int.html#10571" class="Bound">y</a><a id="10625" class="Symbol">)</a>
                     <a id="10648" class="Symbol">(</a><a id="10649" href="Data.Int.html#10198" class="Bound">pr</a> <a id="10652" class="Symbol">(</a><a id="10653" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="10657" href="Data.Int.html#10565" class="Bound">a</a><a id="10658" class="Symbol">)</a> <a id="10660" class="Symbol">(</a><a id="10661" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="10665" href="Data.Int.html#10567" class="Bound">b</a><a id="10666" class="Symbol">)</a> <a id="10668" href="Data.Int.html#10569" class="Bound">x</a> <a id="10670" href="Data.Int.html#10571" class="Bound">y</a><a id="10671" class="Symbol">)</a>
                     <a id="10694" class="Symbol">(</a><a id="10695" href="Data.Int.html#10114" class="Bound">pl</a> <a id="10698" href="Data.Int.html#10565" class="Bound">a</a> <a id="10700" href="Data.Int.html#10567" class="Bound">b</a> <a id="10702" class="Symbol">(</a><a id="10703" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="10707" href="Data.Int.html#10569" class="Bound">x</a><a id="10708" class="Symbol">)</a> <a id="10710" class="Symbol">(</a><a id="10711" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="10715" href="Data.Int.html#10571" class="Bound">y</a><a id="10716" class="Symbol">)))</a>
         <a id="10729" class="Symbol">→</a> <a id="10731" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a> <a id="10735" class="Symbol">→</a> <a id="10737" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a> <a id="10741" class="Symbol">→</a> <a id="10743" href="Data.Int.html#10047" class="Bound">B</a>
</pre>
<p>The type of <code>square</code> says that we need the following square of paths to commute, which says exactly that <code>pl ∙ pr</code> and <code>pr ∙ pl</code> are homotopic and imposes no further structure on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>:</p>
<div class="diagram-container">
<img src="96b44f04dd57b7493b2bae592d6e93413b7af24d.svg" title="commutative diagram" class="diagram quiver tall-1" />
</div>
<pre class="Agda"><a id="11382" href="Data.Int.html#10029" data-type="(f : Nat × Nat → Nat × Nat → B₁)
(pl
 : (a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y))
(pr
 : (a b x y : Nat) →
   f (a , b) (x , y) ≡ f (a , b) (suc x , suc y)) →
((a b x y : Nat) →
 Square (pl a b x y) (pr a b x y) (pr (suc a) (suc b) x y)
 (pl a b (suc x) (suc y))) →
Int → Int → B₁" class="Function">Int-rec₂</a> <a id="11391" href="Data.Int.html#11391" class="Bound">f</a> <a id="11393" href="Data.Int.html#11393" class="Bound">p-l</a> <a id="11397" href="Data.Int.html#11397" class="Bound">p-r</a> <a id="11401" href="Data.Int.html#11401" class="Bound">sq</a> <a id="11404" class="Symbol">(</a><a id="11405" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="11410" href="Data.Int.html#11410" class="Bound">a</a> <a id="11412" href="Data.Int.html#11412" class="Bound">b</a><a id="11413" class="Symbol">)</a> <a id="11415" class="Symbol">(</a><a id="11416" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="11421" href="Data.Int.html#11421" class="Bound">x</a> <a id="11423" href="Data.Int.html#11423" class="Bound">y</a><a id="11424" class="Symbol">)</a>     <a id="11430" class="Symbol">=</a> <a id="11432" href="Data.Int.html#11391" class="Bound">f</a> <a id="11434" class="Symbol">(</a><a id="11435" href="Data.Int.html#11410" class="Bound">a</a> <a id="11437" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="11439" href="Data.Int.html#11412" class="Bound">b</a><a id="11440" class="Symbol">)</a> <a id="11442" class="Symbol">(</a><a id="11443" href="Data.Int.html#11421" class="Bound">x</a> <a id="11445" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="11447" href="Data.Int.html#11423" class="Bound">y</a><a id="11448" class="Symbol">)</a>
<a id="11450" href="Data.Int.html#10029" data-type="(f : Nat × Nat → Nat × Nat → B₁)
(pl
 : (a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y))
(pr
 : (a b x y : Nat) →
   f (a , b) (x , y) ≡ f (a , b) (suc x , suc y)) →
((a b x y : Nat) →
 Square (pl a b x y) (pr a b x y) (pr (suc a) (suc b) x y)
 (pl a b (suc x) (suc y))) →
Int → Int → B₁" class="Function">Int-rec₂</a> <a id="11459" href="Data.Int.html#11459" class="Bound">f</a> <a id="11461" href="Data.Int.html#11461" class="Bound">p-l</a> <a id="11465" href="Data.Int.html#11465" class="Bound">p-r</a> <a id="11469" href="Data.Int.html#11469" class="Bound">sq</a> <a id="11472" class="Symbol">(</a><a id="11473" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="11478" href="Data.Int.html#11478" class="Bound">a</a> <a id="11480" href="Data.Int.html#11480" class="Bound">b</a><a id="11481" class="Symbol">)</a> <a id="11483" class="Symbol">(</a><a id="11484" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="11489" href="Data.Int.html#11489" class="Bound">x</a> <a id="11491" href="Data.Int.html#11491" class="Bound">y</a> <a id="11493" href="Data.Int.html#11493" class="Bound">i</a><a id="11494" class="Symbol">)</a>   <a id="11498" class="Symbol">=</a> <a id="11500" href="Data.Int.html#11465" class="Bound">p-r</a> <a id="11504" href="Data.Int.html#11478" class="Bound">a</a> <a id="11506" href="Data.Int.html#11480" class="Bound">b</a> <a id="11508" href="Data.Int.html#11489" class="Bound">x</a> <a id="11510" href="Data.Int.html#11491" class="Bound">y</a> <a id="11512" href="Data.Int.html#11493" class="Bound">i</a>
<a id="11514" href="Data.Int.html#10029" data-type="(f : Nat × Nat → Nat × Nat → B₁)
(pl
 : (a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y))
(pr
 : (a b x y : Nat) →
   f (a , b) (x , y) ≡ f (a , b) (suc x , suc y)) →
((a b x y : Nat) →
 Square (pl a b x y) (pr a b x y) (pr (suc a) (suc b) x y)
 (pl a b (suc x) (suc y))) →
Int → Int → B₁" class="Function">Int-rec₂</a> <a id="11523" href="Data.Int.html#11523" class="Bound">f</a> <a id="11525" href="Data.Int.html#11525" class="Bound">p-l</a> <a id="11529" href="Data.Int.html#11529" class="Bound">p-r</a> <a id="11533" href="Data.Int.html#11533" class="Bound">sq</a> <a id="11536" class="Symbol">(</a><a id="11537" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="11542" href="Data.Int.html#11542" class="Bound">a</a> <a id="11544" href="Data.Int.html#11544" class="Bound">b</a> <a id="11546" href="Data.Int.html#11546" class="Bound">i</a><a id="11547" class="Symbol">)</a> <a id="11549" class="Symbol">(</a><a id="11550" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="11555" href="Data.Int.html#11555" class="Bound">x</a> <a id="11557" href="Data.Int.html#11557" class="Bound">y</a><a id="11558" class="Symbol">)</a>   <a id="11562" class="Symbol">=</a> <a id="11564" href="Data.Int.html#11525" class="Bound">p-l</a> <a id="11568" href="Data.Int.html#11542" class="Bound">a</a> <a id="11570" href="Data.Int.html#11544" class="Bound">b</a> <a id="11572" href="Data.Int.html#11555" class="Bound">x</a> <a id="11574" href="Data.Int.html#11557" class="Bound">y</a> <a id="11576" href="Data.Int.html#11546" class="Bound">i</a>
<a id="11578" href="Data.Int.html#10029" data-type="(f : Nat × Nat → Nat × Nat → B₁)
(pl
 : (a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y))
(pr
 : (a b x y : Nat) →
   f (a , b) (x , y) ≡ f (a , b) (suc x , suc y)) →
((a b x y : Nat) →
 Square (pl a b x y) (pr a b x y) (pr (suc a) (suc b) x y)
 (pl a b (suc x) (suc y))) →
Int → Int → B₁" class="Function">Int-rec₂</a> <a id="11587" href="Data.Int.html#11587" class="Bound">f</a> <a id="11589" href="Data.Int.html#11589" class="Bound">p-l</a> <a id="11593" href="Data.Int.html#11593" class="Bound">p-r</a> <a id="11597" href="Data.Int.html#11597" class="Bound">sq</a> <a id="11600" class="Symbol">(</a><a id="11601" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="11606" href="Data.Int.html#11606" class="Bound">a</a> <a id="11608" href="Data.Int.html#11608" class="Bound">b</a> <a id="11610" href="Data.Int.html#11610" class="Bound">i</a><a id="11611" class="Symbol">)</a> <a id="11613" class="Symbol">(</a><a id="11614" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="11619" href="Data.Int.html#11619" class="Bound">x</a> <a id="11621" href="Data.Int.html#11621" class="Bound">y</a> <a id="11623" href="Data.Int.html#11623" class="Bound">j</a><a id="11624" class="Symbol">)</a> <a id="11626" class="Symbol">=</a> <a id="11628" href="Data.Int.html#11597" class="Bound">sq</a> <a id="11631" href="Data.Int.html#11606" class="Bound">a</a> <a id="11633" href="Data.Int.html#11608" class="Bound">b</a> <a id="11635" href="Data.Int.html#11619" class="Bound">x</a> <a id="11637" href="Data.Int.html#11621" class="Bound">y</a> <a id="11639" href="Data.Int.html#11610" class="Bound">i</a> <a id="11641" href="Data.Int.html#11623" class="Bound">j</a>
</pre>
<p>However, when the type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> we are mapping into <span class="Agda"><a href="1Lab.HLevel.html#3356" class="Function">is a set</a></span>, as is the case for the integers themselves, the square is automatically satisfied, so we can give a simplified recursion principle:</p>
<pre class="Agda"><a id="Int-rec₂-set"></a><a id="11868" href="Data.Int.html#11868" data-type="is-set B₁ →
(f : Nat × Nat → Nat × Nat → B₁) →
((a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y)) →
((a b x y : Nat) → f (a , b) (x , y) ≡ f (a , b) (suc x , suc y)) →
Int → Int → B₁" class="Function">Int-rec₂-set</a> <a id="11881" class="Symbol">:</a>
  <a id="11885" class="Symbol">∀</a> <a id="11887" class="Symbol">{</a><a id="11888" href="Data.Int.html#11888" class="Bound">ℓ</a><a id="11889" class="Symbol">}</a> <a id="11891" class="Symbol">{</a><a id="11892" href="Data.Int.html#11892" class="Bound">B</a> <a id="11894" class="Symbol">:</a> <a id="11896" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="11901" href="Data.Int.html#11888" class="Bound">ℓ</a><a id="11902" class="Symbol">}</a>
  <a id="11906" class="Symbol">→</a> <a id="11908" href="1Lab.HLevel.html#3356" data-type="Type ℓ → Type ℓ" class="Function">is-set</a> <a id="11915" href="Data.Int.html#11892" class="Bound">B</a>
  <a id="11919" class="Symbol">→</a> <a id="11921" class="Symbol">(</a><a id="11922" href="Data.Int.html#11922" class="Bound">f</a> <a id="11924" class="Symbol">:</a> <a id="11926" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="11930" href="1Lab.Type.html#1846" data-type="Type a → Type b → Type (a ⊔ b)" class="Function Operator">×</a> <a id="11932" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="11936" class="Symbol">→</a> <a id="11938" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="11942" href="1Lab.Type.html#1846" data-type="Type a → Type b → Type (a ⊔ b)" class="Function Operator">×</a> <a id="11944" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a> <a id="11948" class="Symbol">→</a> <a id="11950" href="Data.Int.html#11892" class="Bound">B</a><a id="11951" class="Symbol">)</a>
  <a id="11955" class="Symbol">→</a> <a id="11957" class="Symbol">(</a><a id="11958" href="Data.Int.html#11958" class="Bound">pl</a>     <a id="11965" class="Symbol">:</a> <a id="11967" class="Symbol">(</a><a id="11968" href="Data.Int.html#11968" class="Bound">a</a> <a id="11970" href="Data.Int.html#11970" class="Bound">b</a> <a id="11972" href="Data.Int.html#11972" class="Bound">x</a> <a id="11974" href="Data.Int.html#11974" class="Bound">y</a> <a id="11976" class="Symbol">:</a> <a id="11978" class="Symbol">_)</a> <a id="11981" class="Symbol">→</a> <a id="11983" href="Data.Int.html#11922" class="Bound">f</a> <a id="11985" class="Symbol">(</a><a id="11986" href="Data.Int.html#11968" class="Bound">a</a> <a id="11988" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="11990" href="Data.Int.html#11970" class="Bound">b</a><a id="11991" class="Symbol">)</a> <a id="11993" class="Symbol">(</a><a id="11994" href="Data.Int.html#11972" class="Bound">x</a> <a id="11996" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="11998" href="Data.Int.html#11974" class="Bound">y</a><a id="11999" class="Symbol">)</a> <a id="12001" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="12003" href="Data.Int.html#11922" class="Bound">f</a> <a id="12005" class="Symbol">(</a><a id="12006" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="12010" href="Data.Int.html#11968" class="Bound">a</a> <a id="12012" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="12014" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="12018" href="Data.Int.html#11970" class="Bound">b</a><a id="12019" class="Symbol">)</a> <a id="12021" class="Symbol">(</a><a id="12022" href="Data.Int.html#11972" class="Bound">x</a> <a id="12024" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="12026" href="Data.Int.html#11974" class="Bound">y</a><a id="12027" class="Symbol">))</a>
  <a id="12032" class="Symbol">→</a> <a id="12034" class="Symbol">(</a><a id="12035" href="Data.Int.html#12035" class="Bound">pr</a>     <a id="12042" class="Symbol">:</a> <a id="12044" class="Symbol">(</a><a id="12045" href="Data.Int.html#12045" class="Bound">a</a> <a id="12047" href="Data.Int.html#12047" class="Bound">b</a> <a id="12049" href="Data.Int.html#12049" class="Bound">x</a> <a id="12051" href="Data.Int.html#12051" class="Bound">y</a> <a id="12053" class="Symbol">:</a> <a id="12055" class="Symbol">_)</a> <a id="12058" class="Symbol">→</a> <a id="12060" href="Data.Int.html#11922" class="Bound">f</a> <a id="12062" class="Symbol">(</a><a id="12063" href="Data.Int.html#12045" class="Bound">a</a> <a id="12065" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="12067" href="Data.Int.html#12047" class="Bound">b</a><a id="12068" class="Symbol">)</a> <a id="12070" class="Symbol">(</a><a id="12071" href="Data.Int.html#12049" class="Bound">x</a> <a id="12073" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="12075" href="Data.Int.html#12051" class="Bound">y</a><a id="12076" class="Symbol">)</a> <a id="12078" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="12080" href="Data.Int.html#11922" class="Bound">f</a> <a id="12082" class="Symbol">(</a><a id="12083" href="Data.Int.html#12045" class="Bound">a</a> <a id="12085" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="12087" href="Data.Int.html#12047" class="Bound">b</a><a id="12088" class="Symbol">)</a> <a id="12090" class="Symbol">(</a><a id="12091" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="12095" href="Data.Int.html#12049" class="Bound">x</a> <a id="12097" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="12099" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="12103" href="Data.Int.html#12051" class="Bound">y</a><a id="12104" class="Symbol">))</a>
  <a id="12109" class="Symbol">→</a> <a id="12111" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a> <a id="12115" class="Symbol">→</a> <a id="12117" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a> <a id="12121" class="Symbol">→</a> <a id="12123" href="Data.Int.html#11892" class="Bound">B</a>
<a id="12125" href="Data.Int.html#11868" data-type="is-set B₁ →
(f : Nat × Nat → Nat × Nat → B₁) →
((a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y)) →
((a b x y : Nat) → f (a , b) (x , y) ≡ f (a , b) (suc x , suc y)) →
Int → Int → B₁" class="Function">Int-rec₂-set</a> <a id="12138" href="Data.Int.html#12138" class="Bound">iss-b</a> <a id="12144" href="Data.Int.html#12144" class="Bound">f</a> <a id="12146" href="Data.Int.html#12146" class="Bound">pl</a> <a id="12149" href="Data.Int.html#12149" class="Bound">pr</a> <a id="12152" class="Symbol">=</a> <a id="12154" href="Data.Int.html#10029" data-type="(f : Nat × Nat → Nat × Nat → B₁)
(pl
 : (a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y))
(pr
 : (a b x y : Nat) →
   f (a , b) (x , y) ≡ f (a , b) (suc x , suc y)) →
((a b x y : Nat) →
 Square (pl a b x y) (pr a b x y) (pr (suc a) (suc b) x y)
 (pl a b (suc x) (suc y))) →
Int → Int → B₁" class="Function">Int-rec₂</a> <a id="12163" href="Data.Int.html#12144" class="Bound">f</a> <a id="12165" href="Data.Int.html#12146" class="Bound">pl</a> <a id="12168" href="Data.Int.html#12149" class="Bound">pr</a> <a id="12171" href="Data.Int.html#12186" data-type="(iss-b : is-set B₁) (f : Nat × Nat → Nat × Nat → B₁)
(pl
 : (a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y))
(pr
 : (a b x y : Nat) → f (a , b) (x , y) ≡ f (a , b) (suc x , suc y))
(a b x y : Nat) →
PathP (λ i → pl a b x y i ≡ pl a b (suc x) (suc y) i) (pr a b x y)
(pr (suc a) (suc b) x y)" class="Function">square</a> <a id="12178" class="Keyword">where</a>
  <a id="12186" href="Data.Int.html#12186" data-type="(iss-b : is-set B₁) (f : Nat × Nat → Nat × Nat → B₁)
(pl
 : (a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y))
(pr
 : (a b x y : Nat) → f (a , b) (x , y) ≡ f (a , b) (suc x , suc y))
(a b x y : Nat) →
PathP (λ i → pl a b x y i ≡ pl a b (suc x) (suc y) i) (pr a b x y)
(pr (suc a) (suc b) x y)" class="Function">square</a> <a id="12193" class="Symbol">:</a> <a id="12195" class="Symbol">(</a><a id="12196" href="Data.Int.html#12196" class="Bound">a</a> <a id="12198" href="Data.Int.html#12198" class="Bound">b</a> <a id="12200" href="Data.Int.html#12200" class="Bound">x</a> <a id="12202" href="Data.Int.html#12202" class="Bound">y</a> <a id="12204" class="Symbol">:</a> <a id="12206" class="Symbol">_)</a> <a id="12209" class="Symbol">→</a> <a id="12211" class="Symbol">_</a>
  <a id="12215" href="Data.Int.html#12186" data-type="(iss-b : is-set B₁) (f : Nat × Nat → Nat × Nat → B₁)
(pl
 : (a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y))
(pr
 : (a b x y : Nat) → f (a , b) (x , y) ≡ f (a , b) (suc x , suc y))
(a b x y : Nat) →
PathP (λ i → pl a b x y i ≡ pl a b (suc x) (suc y) i) (pr a b x y)
(pr (suc a) (suc b) x y)" class="Function">square</a> <a id="12222" href="Data.Int.html#12222" class="Bound">a</a> <a id="12224" href="Data.Int.html#12224" class="Bound">b</a> <a id="12226" href="Data.Int.html#12226" class="Bound">x</a> <a id="12228" href="Data.Int.html#12228" class="Bound">y</a> <a id="12230" class="Symbol">=</a> <a id="12232" href="1Lab.HLevel.html#15401" data-type="((i j : I) → is-set (A i j)) →
(p : PathP (λ j → A j i0) a c) (q : PathP (A i0) a b)
(s : PathP (A i1) c d) (r : PathP (λ j → A j i1) b d) →
SquareP A p q s r" class="Function">is-set→squarep</a> <a id="12247" class="Symbol">(λ</a> <a id="12250" href="Data.Int.html#12250" class="Bound">i</a> <a id="12252" href="Data.Int.html#12252" class="Bound">j</a> <a id="12254" class="Symbol">→</a> <a id="12256" href="Data.Int.html#12138" class="Bound">iss-b</a><a id="12261" class="Symbol">)</a> <a id="12263" class="Symbol">_</a> <a id="12265" class="Symbol">_</a> <a id="12267" class="Symbol">_</a> <a id="12269" class="Symbol">_</a>
</pre>
<p>Furthermore, when proving <em><span class="Agda"><a href="1Lab.HLevel.html#2597" class="Function">propositions</a></span></em> of the integers, the quotient is automatically respected, so it suffices to give the case for <span class="Agda"><a href="Data.Int.html#826" class="InductiveConstructor">diff</a></span>:</p>
<pre class="Agda"><a id="Int-elim-prop"></a><a id="12458" href="Data.Int.html#12458" data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" class="Function">Int-elim-prop</a> <a id="12472" class="Symbol">:</a> <a id="12474" class="Symbol">∀</a> <a id="12476" class="Symbol">{</a><a id="12477" href="Data.Int.html#12477" class="Bound">ℓ</a><a id="12478" class="Symbol">}</a> <a id="12480" class="Symbol">{</a><a id="12481" href="Data.Int.html#12481" class="Bound">P</a> <a id="12483" class="Symbol">:</a> <a id="12485" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a> <a id="12489" class="Symbol">→</a> <a id="12491" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="12496" href="Data.Int.html#12477" class="Bound">ℓ</a><a id="12497" class="Symbol">}</a>
              <a id="12513" class="Symbol">→</a> <a id="12515" class="Symbol">((</a><a id="12517" href="Data.Int.html#12517" class="Bound">x</a> <a id="12519" class="Symbol">:</a> <a id="12521" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a><a id="12524" class="Symbol">)</a> <a id="12526" class="Symbol">→</a> <a id="12528" href="1Lab.HLevel.html#2597" data-type="Type ℓ → Type ℓ" class="Function">is-prop</a> <a id="12536" class="Symbol">(</a><a id="12537" href="Data.Int.html#12481" class="Bound">P</a> <a id="12539" href="Data.Int.html#12517" class="Bound">x</a><a id="12540" class="Symbol">))</a>
              <a id="12557" class="Symbol">→</a> <a id="12559" class="Symbol">(</a><a id="12560" href="Data.Int.html#12560" class="Bound">f</a> <a id="12562" class="Symbol">:</a> <a id="12564" class="Symbol">(</a><a id="12565" href="Data.Int.html#12565" class="Bound">a</a> <a id="12567" href="Data.Int.html#12567" class="Bound">b</a> <a id="12569" class="Symbol">:</a> <a id="12571" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a><a id="12574" class="Symbol">)</a> <a id="12576" class="Symbol">→</a> <a id="12578" href="Data.Int.html#12481" class="Bound">P</a> <a id="12580" class="Symbol">(</a><a id="12581" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="12586" href="Data.Int.html#12565" class="Bound">a</a> <a id="12588" href="Data.Int.html#12567" class="Bound">b</a><a id="12589" class="Symbol">))</a>
              <a id="12606" class="Symbol">→</a> <a id="12608" class="Symbol">(</a><a id="12609" href="Data.Int.html#12609" class="Bound">x</a> <a id="12611" class="Symbol">:</a> <a id="12613" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a><a id="12616" class="Symbol">)</a> <a id="12618" class="Symbol">→</a> <a id="12620" href="Data.Int.html#12481" class="Bound">P</a> <a id="12622" href="Data.Int.html#12609" class="Bound">x</a>
<a id="12624" href="Data.Int.html#12458" data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" class="Function">Int-elim-prop</a> <a id="12638" href="Data.Int.html#12638" class="Bound">pprop</a> <a id="12644" href="Data.Int.html#12644" class="Bound">f</a> <a id="12646" class="Symbol">(</a><a id="12647" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="12652" href="Data.Int.html#12652" class="Bound">a</a> <a id="12654" href="Data.Int.html#12654" class="Bound">b</a><a id="12655" class="Symbol">)</a> <a id="12657" class="Symbol">=</a> <a id="12659" href="Data.Int.html#12644" class="Bound">f</a> <a id="12661" href="Data.Int.html#12652" class="Bound">a</a> <a id="12663" href="Data.Int.html#12654" class="Bound">b</a>
<a id="12665" href="Data.Int.html#12458" data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" class="Function">Int-elim-prop</a> <a id="12679" href="Data.Int.html#12679" class="Bound">pprop</a> <a id="12685" href="Data.Int.html#12685" class="Bound">f</a> <a id="12687" class="Symbol">(</a><a id="12688" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="12693" href="Data.Int.html#12693" class="Bound">m</a> <a id="12695" href="Data.Int.html#12695" class="Bound">n</a> <a id="12697" href="Data.Int.html#12697" class="Bound">i</a><a id="12698" class="Symbol">)</a> <a id="12700" class="Symbol">=</a>
  <a id="12704" href="1Lab.HLevel.html#13498" data-type="((i : I) → is-prop (B₁ i)) →
(b0 : B₁ i0) (b1 : B₁ i1) → PathP B₁ b0 b1" class="Function">is-prop→pathp</a> <a id="12718" class="Symbol">(λ</a> <a id="12721" href="Data.Int.html#12721" class="Bound">i</a> <a id="12723" class="Symbol">→</a> <a id="12725" href="Data.Int.html#12679" class="Bound">pprop</a> <a id="12731" class="Symbol">(</a><a id="12732" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="12737" href="Data.Int.html#12693" class="Bound">m</a> <a id="12739" href="Data.Int.html#12695" class="Bound">n</a> <a id="12741" href="Data.Int.html#12721" class="Bound">i</a><a id="12742" class="Symbol">))</a> <a id="12745" class="Symbol">(</a><a id="12746" href="Data.Int.html#12685" class="Bound">f</a> <a id="12748" href="Data.Int.html#12693" class="Bound">m</a> <a id="12750" href="Data.Int.html#12695" class="Bound">n</a><a id="12751" class="Symbol">)</a> <a id="12753" class="Symbol">(</a><a id="12754" href="Data.Int.html#12685" class="Bound">f</a> <a id="12756" class="Symbol">(</a><a id="12757" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="12761" href="Data.Int.html#12693" class="Bound">m</a><a id="12762" class="Symbol">)</a> <a id="12764" class="Symbol">(</a><a id="12765" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="12769" href="Data.Int.html#12695" class="Bound">n</a><a id="12770" class="Symbol">))</a> <a id="12773" href="Data.Int.html#12697" class="Bound">i</a>
</pre>
<details>
<summary>
There are also variants for binary and ternary predicates.
</summary>
<pre class="Agda"><a id="Int-elim₂-prop"></a><a id="12876" href="Data.Int.html#12876" data-type="((x y : Int) → is-prop (P x y)) →
((a b x y : Nat) → P (diff a b) (diff x y)) → (x y : Int) → P x y" class="Function">Int-elim₂-prop</a> <a id="12891" class="Symbol">:</a> <a id="12893" class="Symbol">∀</a> <a id="12895" class="Symbol">{</a><a id="12896" href="Data.Int.html#12896" class="Bound">ℓ</a><a id="12897" class="Symbol">}</a> <a id="12899" class="Symbol">{</a><a id="12900" href="Data.Int.html#12900" class="Bound">P</a> <a id="12902" class="Symbol">:</a> <a id="12904" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a> <a id="12908" class="Symbol">→</a> <a id="12910" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a> <a id="12914" class="Symbol">→</a> <a id="12916" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="12921" href="Data.Int.html#12896" class="Bound">ℓ</a><a id="12922" class="Symbol">}</a>
               <a id="12939" class="Symbol">→</a> <a id="12941" class="Symbol">((</a><a id="12943" href="Data.Int.html#12943" class="Bound">x</a> <a id="12945" href="Data.Int.html#12945" class="Bound">y</a> <a id="12947" class="Symbol">:</a> <a id="12949" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a><a id="12952" class="Symbol">)</a> <a id="12954" class="Symbol">→</a> <a id="12956" href="1Lab.HLevel.html#2597" data-type="Type ℓ → Type ℓ" class="Function">is-prop</a> <a id="12964" class="Symbol">(</a><a id="12965" href="Data.Int.html#12900" class="Bound">P</a> <a id="12967" href="Data.Int.html#12943" class="Bound">x</a> <a id="12969" href="Data.Int.html#12945" class="Bound">y</a><a id="12970" class="Symbol">))</a>
               <a id="12988" class="Symbol">→</a> <a id="12990" class="Symbol">(</a><a id="12991" href="Data.Int.html#12991" class="Bound">f</a> <a id="12993" class="Symbol">:</a> <a id="12995" class="Symbol">(</a><a id="12996" href="Data.Int.html#12996" class="Bound">a</a> <a id="12998" href="Data.Int.html#12998" class="Bound">b</a> <a id="13000" href="Data.Int.html#13000" class="Bound">x</a> <a id="13002" href="Data.Int.html#13002" class="Bound">y</a> <a id="13004" class="Symbol">:</a> <a id="13006" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a><a id="13009" class="Symbol">)</a> <a id="13011" class="Symbol">→</a> <a id="13013" href="Data.Int.html#12900" class="Bound">P</a> <a id="13015" class="Symbol">(</a><a id="13016" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="13021" href="Data.Int.html#12996" class="Bound">a</a> <a id="13023" href="Data.Int.html#12998" class="Bound">b</a><a id="13024" class="Symbol">)</a> <a id="13026" class="Symbol">(</a><a id="13027" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="13032" href="Data.Int.html#13000" class="Bound">x</a> <a id="13034" href="Data.Int.html#13002" class="Bound">y</a><a id="13035" class="Symbol">))</a>
               <a id="13053" class="Symbol">→</a> <a id="13055" class="Symbol">(</a><a id="13056" href="Data.Int.html#13056" class="Bound">x</a> <a id="13058" class="Symbol">:</a> <a id="13060" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a><a id="13063" class="Symbol">)</a> <a id="13065" class="Symbol">(</a><a id="13066" href="Data.Int.html#13066" class="Bound">y</a> <a id="13068" class="Symbol">:</a> <a id="13070" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a><a id="13073" class="Symbol">)</a> <a id="13075" class="Symbol">→</a> <a id="13077" href="Data.Int.html#12900" class="Bound">P</a> <a id="13079" href="Data.Int.html#13056" class="Bound">x</a> <a id="13081" href="Data.Int.html#13066" class="Bound">y</a>
<a id="13083" href="Data.Int.html#12876" data-type="((x y : Int) → is-prop (P x y)) →
((a b x y : Nat) → P (diff a b) (diff x y)) → (x y : Int) → P x y" class="Function">Int-elim₂-prop</a> <a id="13098" href="Data.Int.html#13098" class="Bound">pprop</a> <a id="13104" href="Data.Int.html#13104" class="Bound">f</a> <a id="13106" class="Symbol">=</a>
  <a id="13110" href="Data.Int.html#12458" data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" class="Function">Int-elim-prop</a> <a id="13124" class="Symbol">(λ</a> <a id="13127" href="Data.Int.html#13127" class="Bound">x</a> <a id="13129" class="Symbol">→</a> <a id="13131" href="1Lab.HLevel.Retracts.html#4232" data-type="(n : Nat) →
((x : A) → is-hlevel (B₁ x) n) → is-hlevel ((x : A) → B₁ x) n" class="Function">Π-is-hlevel</a> <a id="13143" class="Number">1</a> <a id="13145" class="Symbol">(</a><a id="13146" href="Data.Int.html#13098" class="Bound">pprop</a> <a id="13152" href="Data.Int.html#13127" class="Bound">x</a><a id="13153" class="Symbol">))</a>
    <a id="13160" class="Symbol">λ</a> <a id="13162" href="Data.Int.html#13162" class="Bound">a</a> <a id="13164" href="Data.Int.html#13164" class="Bound">b</a> <a id="13166" href="Data.Int.html#13166" class="Bound">int</a> <a id="13170" class="Symbol">→</a> <a id="13172" href="Data.Int.html#12458" data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" class="Function">Int-elim-prop</a> <a id="13186" class="Symbol">(λ</a> <a id="13189" href="Data.Int.html#13189" class="Bound">x</a> <a id="13191" class="Symbol">→</a> <a id="13193" href="Data.Int.html#13098" class="Bound">pprop</a> <a id="13199" class="Symbol">(</a><a id="13200" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="13205" href="Data.Int.html#13162" class="Bound">a</a> <a id="13207" href="Data.Int.html#13164" class="Bound">b</a><a id="13208" class="Symbol">)</a> <a id="13210" href="Data.Int.html#13189" class="Bound">x</a><a id="13211" class="Symbol">)</a> <a id="13213" class="Symbol">(</a><a id="13214" href="Data.Int.html#13104" class="Bound">f</a> <a id="13216" href="Data.Int.html#13162" class="Bound">a</a> <a id="13218" href="Data.Int.html#13164" class="Bound">b</a><a id="13219" class="Symbol">)</a> <a id="13221" href="Data.Int.html#13166" class="Bound">int</a>

<a id="Int-elim₃-prop"></a><a id="13226" href="Data.Int.html#13226" data-type="((x y z : Int) → is-prop (P x y z)) →
((a b c d e f : Nat) → P (diff a b) (diff c d) (diff e f)) →
(x y z : Int) → P x y z" class="Function">Int-elim₃-prop</a> <a id="13241" class="Symbol">:</a> <a id="13243" class="Symbol">∀</a> <a id="13245" class="Symbol">{</a><a id="13246" href="Data.Int.html#13246" class="Bound">ℓ</a><a id="13247" class="Symbol">}</a> <a id="13249" class="Symbol">{</a><a id="13250" href="Data.Int.html#13250" class="Bound">P</a> <a id="13252" class="Symbol">:</a> <a id="13254" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a> <a id="13258" class="Symbol">→</a> <a id="13260" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a> <a id="13264" class="Symbol">→</a> <a id="13266" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a> <a id="13270" class="Symbol">→</a> <a id="13272" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="13277" href="Data.Int.html#13246" class="Bound">ℓ</a><a id="13278" class="Symbol">}</a>
               <a id="13295" class="Symbol">→</a> <a id="13297" class="Symbol">((</a><a id="13299" href="Data.Int.html#13299" class="Bound">x</a> <a id="13301" href="Data.Int.html#13301" class="Bound">y</a> <a id="13303" href="Data.Int.html#13303" class="Bound">z</a> <a id="13305" class="Symbol">:</a> <a id="13307" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a><a id="13310" class="Symbol">)</a> <a id="13312" class="Symbol">→</a> <a id="13314" href="1Lab.HLevel.html#2597" data-type="Type ℓ → Type ℓ" class="Function">is-prop</a> <a id="13322" class="Symbol">(</a><a id="13323" href="Data.Int.html#13250" class="Bound">P</a> <a id="13325" href="Data.Int.html#13299" class="Bound">x</a> <a id="13327" href="Data.Int.html#13301" class="Bound">y</a> <a id="13329" href="Data.Int.html#13303" class="Bound">z</a><a id="13330" class="Symbol">))</a>
               <a id="13348" class="Symbol">→</a> <a id="13350" class="Symbol">(</a><a id="13351" href="Data.Int.html#13351" class="Bound">f</a> <a id="13353" class="Symbol">:</a> <a id="13355" class="Symbol">(</a><a id="13356" href="Data.Int.html#13356" class="Bound">a</a> <a id="13358" href="Data.Int.html#13358" class="Bound">b</a> <a id="13360" href="Data.Int.html#13360" class="Bound">c</a> <a id="13362" href="Data.Int.html#13362" class="Bound">d</a> <a id="13364" href="Data.Int.html#13364" class="Bound">e</a> <a id="13366" href="Data.Int.html#13366" class="Bound">f</a> <a id="13368" class="Symbol">:</a> <a id="13370" href="Agda.Builtin.Nat.html#192" data-type="Type" class="Datatype">Nat</a><a id="13373" class="Symbol">)</a> <a id="13375" class="Symbol">→</a> <a id="13377" href="Data.Int.html#13250" class="Bound">P</a> <a id="13379" class="Symbol">(</a><a id="13380" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="13385" href="Data.Int.html#13356" class="Bound">a</a> <a id="13387" href="Data.Int.html#13358" class="Bound">b</a><a id="13388" class="Symbol">)</a> <a id="13390" class="Symbol">(</a><a id="13391" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="13396" href="Data.Int.html#13360" class="Bound">c</a> <a id="13398" href="Data.Int.html#13362" class="Bound">d</a><a id="13399" class="Symbol">)</a> <a id="13401" class="Symbol">(</a><a id="13402" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="13407" href="Data.Int.html#13364" class="Bound">e</a> <a id="13409" href="Data.Int.html#13366" class="Bound">f</a><a id="13410" class="Symbol">))</a>
               <a id="13428" class="Symbol">→</a> <a id="13430" class="Symbol">(</a><a id="13431" href="Data.Int.html#13431" class="Bound">x</a> <a id="13433" class="Symbol">:</a> <a id="13435" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a><a id="13438" class="Symbol">)</a> <a id="13440" class="Symbol">(</a><a id="13441" href="Data.Int.html#13441" class="Bound">y</a> <a id="13443" class="Symbol">:</a> <a id="13445" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a><a id="13448" class="Symbol">)</a> <a id="13450" class="Symbol">(</a><a id="13451" href="Data.Int.html#13451" class="Bound">z</a> <a id="13453" class="Symbol">:</a> <a id="13455" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a><a id="13458" class="Symbol">)</a> <a id="13460" class="Symbol">→</a> <a id="13462" href="Data.Int.html#13250" class="Bound">P</a> <a id="13464" href="Data.Int.html#13431" class="Bound">x</a> <a id="13466" href="Data.Int.html#13441" class="Bound">y</a> <a id="13468" href="Data.Int.html#13451" class="Bound">z</a>
<a id="13470" href="Data.Int.html#13226" data-type="((x y z : Int) → is-prop (P x y z)) →
((a b c d e f : Nat) → P (diff a b) (diff c d) (diff e f)) →
(x y z : Int) → P x y z" class="Function">Int-elim₃-prop</a> <a id="13485" href="Data.Int.html#13485" class="Bound">pprop</a> <a id="13491" href="Data.Int.html#13491" class="Bound">f</a> <a id="13493" class="Symbol">=</a>
  <a id="13497" href="Data.Int.html#12876" data-type="((x y : Int) → is-prop (P x y)) →
((a b x y : Nat) → P (diff a b) (diff x y)) → (x y : Int) → P x y" class="Function">Int-elim₂-prop</a> <a id="13512" class="Symbol">(λ</a> <a id="13515" href="Data.Int.html#13515" class="Bound">x</a> <a id="13517" href="Data.Int.html#13517" class="Bound">y</a> <a id="13519" class="Symbol">→</a> <a id="13521" href="1Lab.HLevel.Retracts.html#4232" data-type="(n : Nat) →
((x : A) → is-hlevel (B₁ x) n) → is-hlevel ((x : A) → B₁ x) n" class="Function">Π-is-hlevel</a> <a id="13533" class="Number">1</a> <a id="13535" class="Symbol">(</a><a id="13536" href="Data.Int.html#13485" class="Bound">pprop</a> <a id="13542" href="Data.Int.html#13515" class="Bound">x</a> <a id="13544" href="Data.Int.html#13517" class="Bound">y</a><a id="13545" class="Symbol">))</a>
    <a id="13552" class="Symbol">λ</a> <a id="13554" href="Data.Int.html#13554" class="Bound">a</a> <a id="13556" href="Data.Int.html#13556" class="Bound">b</a> <a id="13558" href="Data.Int.html#13558" class="Bound">c</a> <a id="13560" href="Data.Int.html#13560" class="Bound">d</a> <a id="13562" href="Data.Int.html#13562" class="Bound">int</a> <a id="13566" class="Symbol">→</a> <a id="13568" href="Data.Int.html#12458" data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" class="Function">Int-elim-prop</a> <a id="13582" class="Symbol">(λ</a> <a id="13585" href="Data.Int.html#13585" class="Bound">x</a> <a id="13587" class="Symbol">→</a> <a id="13589" href="Data.Int.html#13485" class="Bound">pprop</a> <a id="13595" class="Symbol">(</a><a id="13596" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="13601" href="Data.Int.html#13554" class="Bound">a</a> <a id="13603" href="Data.Int.html#13556" class="Bound">b</a><a id="13604" class="Symbol">)</a> <a id="13606" class="Symbol">(</a><a id="13607" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="13612" href="Data.Int.html#13558" class="Bound">c</a> <a id="13614" href="Data.Int.html#13560" class="Bound">d</a><a id="13615" class="Symbol">)</a> <a id="13617" href="Data.Int.html#13585" class="Bound">x</a><a id="13618" class="Symbol">)</a>
                                  <a id="13654" class="Symbol">(</a><a id="13655" href="Data.Int.html#13491" class="Bound">f</a> <a id="13657" href="Data.Int.html#13554" class="Bound">a</a> <a id="13659" href="Data.Int.html#13556" class="Bound">b</a> <a id="13661" href="Data.Int.html#13558" class="Bound">c</a> <a id="13663" href="Data.Int.html#13560" class="Bound">d</a><a id="13664" class="Symbol">)</a>
                                  <a id="13700" href="Data.Int.html#13562" class="Bound">int</a>
</pre>
</details>
<h1 id="algebra"><a href="#algebra" class="header-link">Algebra<span class="header-link-emoji">🔗</span></a></h1>
<p>With these recursion and elimination helpers, it becomes routine to lift the algebraic operations from naturals to integers:</p>
<h2 id="successors"><a href="#successors" class="header-link">Successors<span class="header-link-emoji">🔗</span></a></h2>
<p>The simplest “algebraic operation” on an integer is taking its successor. In fact, the integers are characterised by being the free type with an equivalence - that equivalence being “successor”.</p>
<pre class="Agda"><a id="sucℤ"></a><a id="14076" href="Data.Int.html#14076" data-type="Int → Int" class="Function">sucℤ</a> <a id="14081" class="Symbol">:</a> <a id="14083" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a> <a id="14087" class="Symbol">→</a> <a id="14089" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a>
<a id="14093" href="Data.Int.html#14076" data-type="Int → Int" class="Function">sucℤ</a> <a id="14098" class="Symbol">(</a><a id="14099" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="14104" href="Data.Int.html#14104" class="Bound">x</a> <a id="14106" href="Data.Int.html#14106" class="Bound">y</a><a id="14107" class="Symbol">)</a> <a id="14109" class="Symbol">=</a> <a id="14111" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="14116" class="Symbol">(</a><a id="14117" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="14121" href="Data.Int.html#14104" class="Bound">x</a><a id="14122" class="Symbol">)</a> <a id="14124" href="Data.Int.html#14106" class="Bound">y</a>
<a id="14126" href="Data.Int.html#14076" data-type="Int → Int" class="Function">sucℤ</a> <a id="14131" class="Symbol">(</a><a id="14132" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="14137" href="Data.Int.html#14137" class="Bound">m</a> <a id="14139" href="Data.Int.html#14139" class="Bound">n</a> <a id="14141" href="Data.Int.html#14141" class="Bound">i</a><a id="14142" class="Symbol">)</a> <a id="14144" class="Symbol">=</a> <a id="14146" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="14151" class="Symbol">(</a><a id="14152" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="14156" href="Data.Int.html#14137" class="Bound">m</a><a id="14157" class="Symbol">)</a> <a id="14159" href="Data.Int.html#14139" class="Bound">n</a> <a id="14161" href="Data.Int.html#14141" class="Bound">i</a>

<a id="predℤ"></a><a id="14164" href="Data.Int.html#14164" data-type="Int → Int" class="Function">predℤ</a> <a id="14170" class="Symbol">:</a> <a id="14172" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a> <a id="14176" class="Symbol">→</a> <a id="14178" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a>
<a id="14182" href="Data.Int.html#14164" data-type="Int → Int" class="Function">predℤ</a> <a id="14188" class="Symbol">(</a><a id="14189" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="14194" href="Data.Int.html#14194" class="Bound">x</a> <a id="14196" href="Data.Int.html#14196" class="Bound">y</a><a id="14197" class="Symbol">)</a> <a id="14199" class="Symbol">=</a> <a id="14201" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="14206" href="Data.Int.html#14194" class="Bound">x</a> <a id="14208" class="Symbol">(</a><a id="14209" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="14213" href="Data.Int.html#14196" class="Bound">y</a><a id="14214" class="Symbol">)</a>
<a id="14216" href="Data.Int.html#14164" data-type="Int → Int" class="Function">predℤ</a> <a id="14222" class="Symbol">(</a><a id="14223" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="14228" href="Data.Int.html#14228" class="Bound">m</a> <a id="14230" href="Data.Int.html#14230" class="Bound">n</a> <a id="14232" href="Data.Int.html#14232" class="Bound">i</a><a id="14233" class="Symbol">)</a> <a id="14235" class="Symbol">=</a> <a id="14237" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="14242" href="Data.Int.html#14228" class="Bound">m</a> <a id="14244" class="Symbol">(</a><a id="14245" href="Agda.Builtin.Nat.html#223" data-type="Nat → Nat" class="InductiveConstructor">suc</a> <a id="14249" href="Data.Int.html#14230" class="Bound">n</a><a id="14250" class="Symbol">)</a> <a id="14252" href="Data.Int.html#14232" class="Bound">i</a>
</pre>
<p>The successor of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span> is <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1 + a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>.</span> Similarly, the predecessor of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span> is <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mn>1</mn><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, 1 + b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>.</span> By the generating equality <span class="Agda"><a href="Data.Int.html#853" class="InductiveConstructor">quot</a></span>, we have that predecessor and successor are inverses, since applying both (in either order) takes <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span> to <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>a</mi><mo separator="true">,</mo><mn>1</mn><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1 + a, 1 + b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>.</span></p>
<pre class="Agda"><a id="pred-sucℤ"></a><a id="14536" href="Data.Int.html#14536" data-type="(x : Int) → predℤ (sucℤ x) ≡ x" class="Function">pred-sucℤ</a> <a id="14546" class="Symbol">:</a> <a id="14548" class="Symbol">(</a><a id="14549" href="Data.Int.html#14549" class="Bound">x</a> <a id="14551" class="Symbol">:</a> <a id="14553" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a><a id="14556" class="Symbol">)</a> <a id="14558" class="Symbol">→</a> <a id="14560" href="Data.Int.html#14164" data-type="Int → Int" class="Function">predℤ</a> <a id="14566" class="Symbol">(</a><a id="14567" href="Data.Int.html#14076" data-type="Int → Int" class="Function">sucℤ</a> <a id="14572" href="Data.Int.html#14549" class="Bound">x</a><a id="14573" class="Symbol">)</a> <a id="14575" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="14577" href="Data.Int.html#14549" class="Bound">x</a>
<a id="14579" href="Data.Int.html#14536" data-type="(x : Int) → predℤ (sucℤ x) ≡ x" class="Function">pred-sucℤ</a> <a id="14589" class="Symbol">(</a><a id="14590" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="14595" href="Data.Int.html#14595" class="Bound">x</a> <a id="14597" href="Data.Int.html#14597" class="Bound">y</a><a id="14598" class="Symbol">)</a> <a id="14600" class="Symbol">=</a> <a id="14602" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="14606" class="Symbol">(</a><a id="14607" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="14612" href="Data.Int.html#14595" class="Bound">x</a> <a id="14614" href="Data.Int.html#14597" class="Bound">y</a><a id="14615" class="Symbol">)</a>
<a id="14617" href="Data.Int.html#14536" data-type="(x : Int) → predℤ (sucℤ x) ≡ x" class="Function">pred-sucℤ</a> <a id="14627" class="Symbol">(</a><a id="14628" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="14633" href="Data.Int.html#14633" class="Bound">m</a> <a id="14635" href="Data.Int.html#14635" class="Bound">n</a> <a id="14637" href="Data.Int.html#14637" class="Bound">i</a><a id="14638" class="Symbol">)</a> <a id="14640" href="Data.Int.html#14640" class="Bound">j</a> <a id="14642" class="Symbol">=</a> <a id="14644" href="Data.Int.html#3926" data-type="(a b : Nat) →
Square (quot a b) (quot a b) (quot (suc a) (suc b))
(quot (suc a) (suc b))" class="Function">quot-diamond</a> <a id="14657" href="Data.Int.html#14633" class="Bound">m</a> <a id="14659" href="Data.Int.html#14635" class="Bound">n</a> <a id="14661" href="Data.Int.html#14637" class="Bound">i</a> <a id="14663" class="Symbol">(</a><a id="14664" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="14666" href="Data.Int.html#14640" class="Bound">j</a><a id="14667" class="Symbol">)</a>

<a id="suc-predℤ"></a><a id="14670" href="Data.Int.html#14670" data-type="(x : Int) → sucℤ (predℤ x) ≡ x" class="Function">suc-predℤ</a> <a id="14680" class="Symbol">:</a> <a id="14682" class="Symbol">(</a><a id="14683" href="Data.Int.html#14683" class="Bound">x</a> <a id="14685" class="Symbol">:</a> <a id="14687" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a><a id="14690" class="Symbol">)</a> <a id="14692" class="Symbol">→</a> <a id="14694" href="Data.Int.html#14076" data-type="Int → Int" class="Function">sucℤ</a> <a id="14699" class="Symbol">(</a><a id="14700" href="Data.Int.html#14164" data-type="Int → Int" class="Function">predℤ</a> <a id="14706" href="Data.Int.html#14683" class="Bound">x</a><a id="14707" class="Symbol">)</a> <a id="14709" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="14711" href="Data.Int.html#14683" class="Bound">x</a>
<a id="14713" href="Data.Int.html#14670" data-type="(x : Int) → sucℤ (predℤ x) ≡ x" class="Function">suc-predℤ</a> <a id="14723" class="Symbol">(</a><a id="14724" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="14729" href="Data.Int.html#14729" class="Bound">x</a> <a id="14731" href="Data.Int.html#14731" class="Bound">y</a><a id="14732" class="Symbol">)</a> <a id="14734" class="Symbol">=</a> <a id="14736" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="14740" class="Symbol">(</a><a id="14741" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="14746" href="Data.Int.html#14729" class="Bound">x</a> <a id="14748" href="Data.Int.html#14731" class="Bound">y</a><a id="14749" class="Symbol">)</a>
<a id="14751" href="Data.Int.html#14670" data-type="(x : Int) → sucℤ (predℤ x) ≡ x" class="Function">suc-predℤ</a> <a id="14761" class="Symbol">(</a><a id="14762" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="14767" href="Data.Int.html#14767" class="Bound">m</a> <a id="14769" href="Data.Int.html#14769" class="Bound">n</a> <a id="14771" href="Data.Int.html#14771" class="Bound">i</a><a id="14772" class="Symbol">)</a> <a id="14774" href="Data.Int.html#14774" class="Bound">j</a> <a id="14776" class="Symbol">=</a> <a id="14778" href="Data.Int.html#3926" data-type="(a b : Nat) →
Square (quot a b) (quot a b) (quot (suc a) (suc b))
(quot (suc a) (suc b))" class="Function">quot-diamond</a> <a id="14791" href="Data.Int.html#14767" class="Bound">m</a> <a id="14793" href="Data.Int.html#14769" class="Bound">n</a> <a id="14795" href="Data.Int.html#14771" class="Bound">i</a> <a id="14797" class="Symbol">(</a><a id="14798" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="14800" href="Data.Int.html#14774" class="Bound">j</a><a id="14801" class="Symbol">)</a>

<a id="sucℤ-is-equiv"></a><a id="14804" href="Data.Int.html#14804" data-type="is-equiv sucℤ" class="Function">sucℤ-is-equiv</a> <a id="14818" class="Symbol">:</a> <a id="14820" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="14829" href="Data.Int.html#14076" data-type="Int → Int" class="Function">sucℤ</a>
<a id="14834" href="Data.Int.html#14804" data-type="is-equiv sucℤ" class="Function">sucℤ-is-equiv</a> <a id="14848" class="Symbol">=</a> <a id="14850" href="1Lab.Equiv.html#19815" data-type="(i : is-iso f) → is-equiv f" class="Function">is-iso→is-equiv</a> <a id="14866" class="Symbol">(</a><a id="14867" href="1Lab.Equiv.html#6116" data-type="(inv₁ : B₁ → A) (rinv₁ : is-right-inverse inv₁ f)
(linv₁ : is-left-inverse inv₁ f) →
is-iso f" class="InductiveConstructor">iso</a> <a id="14871" href="Data.Int.html#14164" data-type="Int → Int" class="Function">predℤ</a> <a id="14877" href="Data.Int.html#14670" data-type="(x : Int) → sucℤ (predℤ x) ≡ x" class="Function">suc-predℤ</a> <a id="14887" href="Data.Int.html#14536" data-type="(x : Int) → predℤ (sucℤ x) ≡ x" class="Function">pred-sucℤ</a><a id="14896" class="Symbol">)</a>

<a id="predℤ-is-equiv"></a><a id="14899" href="Data.Int.html#14899" data-type="is-equiv predℤ" class="Function">predℤ-is-equiv</a> <a id="14914" class="Symbol">:</a> <a id="14916" href="1Lab.Equiv.html#2286" data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" class="Record">is-equiv</a> <a id="14925" href="Data.Int.html#14164" data-type="Int → Int" class="Function">predℤ</a>
<a id="14931" href="Data.Int.html#14899" data-type="is-equiv predℤ" class="Function">predℤ-is-equiv</a> <a id="14946" class="Symbol">=</a> <a id="14948" href="1Lab.Equiv.html#19815" data-type="(i : is-iso f) → is-equiv f" class="Function">is-iso→is-equiv</a> <a id="14964" class="Symbol">(</a><a id="14965" href="1Lab.Equiv.html#6116" data-type="(inv₁ : B₁ → A) (rinv₁ : is-right-inverse inv₁ f)
(linv₁ : is-left-inverse inv₁ f) →
is-iso f" class="InductiveConstructor">iso</a> <a id="14969" href="Data.Int.html#14076" data-type="Int → Int" class="Function">sucℤ</a> <a id="14974" href="Data.Int.html#14536" data-type="(x : Int) → predℤ (sucℤ x) ≡ x" class="Function">pred-sucℤ</a> <a id="14984" href="Data.Int.html#14670" data-type="(x : Int) → sucℤ (predℤ x) ≡ x" class="Function">suc-predℤ</a><a id="14993" class="Symbol">)</a>
</pre>
<h2 id="addition"><a href="#addition" class="header-link">Addition<span class="header-link-emoji">🔗</span></a></h2>
<pre class="Agda"><a id="_+ℤ_"></a><a id="15021" href="Data.Int.html#15021" data-type="Int → Int → Int" class="Function Operator">_+ℤ_</a> <a id="15026" class="Symbol">:</a> <a id="15028" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a> <a id="15032" class="Symbol">→</a> <a id="15034" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a> <a id="15038" class="Symbol">→</a> <a id="15040" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a>
<a id="15044" href="Data.Int.html#15021" data-type="Int → Int → Int" class="Function Operator">_+ℤ_</a> <a id="15049" class="Symbol">=</a>
  <a id="15053" href="Data.Int.html#11868" data-type="is-set B₁ →
(f : Nat × Nat → Nat × Nat → B₁) →
((a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y)) →
((a b x y : Nat) → f (a , b) (x , y) ≡ f (a , b) (suc x , suc y)) →
Int → Int → B₁" class="Function">Int-rec₂-set</a>
    <a id="15070" href="Data.Int.html#9236" data-type="is-set Int" class="Function">Int-is-set</a>
    <a id="15085" class="Symbol">(λ</a> <a id="15088" class="Symbol">{</a> <a id="15090" class="Symbol">(</a><a id="15091" href="Data.Int.html#15091" class="Bound">a</a> <a id="15093" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="15095" href="Data.Int.html#15095" class="Bound">b</a><a id="15096" class="Symbol">)</a> <a id="15098" class="Symbol">(</a><a id="15099" href="Data.Int.html#15099" class="Bound">c</a> <a id="15101" href="Agda.Builtin.Sigma.html#236" data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" class="InductiveConstructor Operator">,</a> <a id="15103" href="Data.Int.html#15103" class="Bound">d</a><a id="15104" class="Symbol">)</a> <a id="15106" class="Symbol">→</a> <a id="15108" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="15113" class="Symbol">(</a><a id="15114" href="Data.Int.html#15091" class="Bound">a</a> <a id="15116" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="15118" href="Data.Int.html#15099" class="Bound">c</a><a id="15119" class="Symbol">)</a> <a id="15121" class="Symbol">(</a><a id="15122" href="Data.Int.html#15095" class="Bound">b</a> <a id="15124" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="15126" href="Data.Int.html#15103" class="Bound">d</a><a id="15127" class="Symbol">)})</a>
    <a id="15135" class="Symbol">(λ</a> <a id="15138" href="Data.Int.html#15138" class="Bound">a</a> <a id="15140" href="Data.Int.html#15140" class="Bound">b</a> <a id="15142" href="Data.Int.html#15142" class="Bound">x</a> <a id="15144" href="Data.Int.html#15144" class="Bound">y</a> <a id="15146" class="Symbol">→</a> <a id="15148" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="15153" class="Symbol">_</a> <a id="15155" class="Symbol">_)</a>
    <a id="15162" class="Symbol">(λ</a> <a id="15165" href="Data.Int.html#15165" class="Bound">a</a> <a id="15167" href="Data.Int.html#15167" class="Bound">b</a> <a id="15169" href="Data.Int.html#15169" class="Bound">x</a> <a id="15171" href="Data.Int.html#15171" class="Bound">y</a> <a id="15173" class="Symbol">→</a> <a id="15175" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="15180" class="Symbol">_</a> <a id="15182" class="Symbol">_</a> <a id="15184" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="15186" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="15190" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="15195" class="Symbol">(</a><a id="15196" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="15200" class="Symbol">(</a><a id="15201" href="Data.Nat.Properties.html#824" data-type="(x y : Nat) → x + suc y ≡ suc (x + y)" class="Function">+-sucr</a> <a id="15208" class="Symbol">_</a> <a id="15210" class="Symbol">_))</a> <a id="15214" class="Symbol">(</a><a id="15215" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="15219" class="Symbol">(</a><a id="15220" href="Data.Nat.Properties.html#824" data-type="(x y : Nat) → x + suc y ≡ suc (x + y)" class="Function">+-sucr</a> <a id="15227" class="Symbol">_</a> <a id="15229" class="Symbol">_)))</a>
</pre>
<p>Since addition of integers is (essentially!) addition of pairs of naturals, the algebraic properties of <span class="Agda"><a href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a></span> on the natural numbers automatically lift to properties about <span class="Agda"><a href="Data.Int.html#15021" class="Function Operator">_+ℤ_</a></span>, using the recursion helpers for props (<span class="Agda"><a href="Data.Int.html#12458" class="Function">Int-elim-prop</a></span>) and the fact that <span class="Agda"><a href="Data.Int.html#9236" class="Function">equality of integers is a proposition</a></span>.</p>
<pre class="Agda"><a id="+ℤ-associative"></a><a id="15586" href="Data.Int.html#15586" data-type="(x y z : Int) → ((x +ℤ y) +ℤ z) ≡ (x +ℤ (y +ℤ z))" class="Function">+ℤ-associative</a> <a id="15601" class="Symbol">:</a> <a id="15603" class="Symbol">(</a><a id="15604" href="Data.Int.html#15604" class="Bound">x</a> <a id="15606" href="Data.Int.html#15606" class="Bound">y</a> <a id="15608" href="Data.Int.html#15608" class="Bound">z</a> <a id="15610" class="Symbol">:</a> <a id="15612" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a><a id="15615" class="Symbol">)</a> <a id="15617" class="Symbol">→</a> <a id="15619" class="Symbol">(</a><a id="15620" href="Data.Int.html#15604" class="Bound">x</a> <a id="15622" href="Data.Int.html#15021" data-type="Int → Int → Int" class="Function Operator">+ℤ</a> <a id="15625" href="Data.Int.html#15606" class="Bound">y</a><a id="15626" class="Symbol">)</a> <a id="15628" href="Data.Int.html#15021" data-type="Int → Int → Int" class="Function Operator">+ℤ</a> <a id="15631" href="Data.Int.html#15608" class="Bound">z</a> <a id="15633" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="15635" href="Data.Int.html#15604" class="Bound">x</a> <a id="15637" href="Data.Int.html#15021" data-type="Int → Int → Int" class="Function Operator">+ℤ</a> <a id="15640" class="Symbol">(</a><a id="15641" href="Data.Int.html#15606" class="Bound">y</a> <a id="15643" href="Data.Int.html#15021" data-type="Int → Int → Int" class="Function Operator">+ℤ</a> <a id="15646" href="Data.Int.html#15608" class="Bound">z</a><a id="15647" class="Symbol">)</a>
<a id="15649" href="Data.Int.html#15586" data-type="(x y z : Int) → ((x +ℤ y) +ℤ z) ≡ (x +ℤ (y +ℤ z))" class="Function">+ℤ-associative</a> <a id="15664" class="Symbol">=</a>
  <a id="15668" href="Data.Int.html#13226" data-type="((x y z : Int) → is-prop (P x y z)) →
((a b c d e f : Nat) → P (diff a b) (diff c d) (diff e f)) →
(x y z : Int) → P x y z" class="Function">Int-elim₃-prop</a>
    <a id="15687" class="Symbol">(λ</a> <a id="15690" href="Data.Int.html#15690" class="Bound">x</a> <a id="15692" href="Data.Int.html#15692" class="Bound">y</a> <a id="15694" href="Data.Int.html#15694" class="Bound">z</a> <a id="15696" class="Symbol">→</a> <a id="15698" href="Data.Int.html#9236" data-type="is-set Int" class="Function">Int-is-set</a> <a id="15709" class="Symbol">_</a> <a id="15711" class="Symbol">_)</a>
    <a id="15718" class="Symbol">(λ</a> <a id="15721" href="Data.Int.html#15721" class="Bound">a</a> <a id="15723" href="Data.Int.html#15723" class="Bound">b</a> <a id="15725" href="Data.Int.html#15725" class="Bound">c</a> <a id="15727" href="Data.Int.html#15727" class="Bound">d</a> <a id="15729" href="Data.Int.html#15729" class="Bound">e</a> <a id="15731" href="Data.Int.html#15731" class="Bound">f</a> <a id="15733" class="Symbol">→</a> <a id="15735" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="15739" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="15744" class="Symbol">(</a><a id="15745" href="Data.Nat.Properties.html#506" data-type="(x y z : Nat) → x + y + z ≡ x + (y + z)" class="Function">+-associative</a> <a id="15759" href="Data.Int.html#15721" class="Bound">a</a> <a id="15761" href="Data.Int.html#15725" class="Bound">c</a> <a id="15763" href="Data.Int.html#15729" class="Bound">e</a><a id="15764" class="Symbol">)</a> <a id="15766" class="Symbol">(</a><a id="15767" href="Data.Nat.Properties.html#506" data-type="(x y z : Nat) → x + y + z ≡ x + (y + z)" class="Function">+-associative</a> <a id="15781" href="Data.Int.html#15723" class="Bound">b</a> <a id="15783" href="Data.Int.html#15727" class="Bound">d</a> <a id="15785" href="Data.Int.html#15731" class="Bound">f</a><a id="15786" class="Symbol">))</a>

<a id="+ℤ-zerol"></a><a id="15790" href="Data.Int.html#15790" data-type="(x : Int) → (0 +ℤ x) ≡ x" class="Function">+ℤ-zerol</a> <a id="15799" class="Symbol">:</a> <a id="15801" class="Symbol">(</a><a id="15802" href="Data.Int.html#15802" class="Bound">x</a> <a id="15804" class="Symbol">:</a> <a id="15806" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a><a id="15809" class="Symbol">)</a> <a id="15811" class="Symbol">→</a> <a id="15813" class="Number">0</a> <a id="15815" href="Data.Int.html#15021" data-type="Int → Int → Int" class="Function Operator">+ℤ</a> <a id="15818" href="Data.Int.html#15802" class="Bound">x</a> <a id="15820" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="15822" href="Data.Int.html#15802" class="Bound">x</a>
<a id="15824" href="Data.Int.html#15790" data-type="(x : Int) → (0 +ℤ x) ≡ x" class="Function">+ℤ-zerol</a> <a id="15833" class="Symbol">=</a> <a id="15835" href="Data.Int.html#12458" data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" class="Function">Int-elim-prop</a> <a id="15849" class="Symbol">(λ</a> <a id="15852" href="Data.Int.html#15852" class="Bound">x</a> <a id="15854" class="Symbol">→</a> <a id="15856" href="Data.Int.html#9236" data-type="is-set Int" class="Function">Int-is-set</a> <a id="15867" class="Symbol">_</a> <a id="15869" class="Symbol">_)</a> <a id="15872" class="Symbol">(λ</a> <a id="15875" href="Data.Int.html#15875" class="Bound">a</a> <a id="15877" href="Data.Int.html#15877" class="Bound">b</a> <a id="15879" class="Symbol">→</a> <a id="15881" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="15885" class="Symbol">)</a>

<a id="+ℤ-zeror"></a><a id="15888" href="Data.Int.html#15888" data-type="(x : Int) → (x +ℤ 0) ≡ x" class="Function">+ℤ-zeror</a> <a id="15897" class="Symbol">:</a> <a id="15899" class="Symbol">(</a><a id="15900" href="Data.Int.html#15900" class="Bound">x</a> <a id="15902" class="Symbol">:</a> <a id="15904" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a><a id="15907" class="Symbol">)</a> <a id="15909" class="Symbol">→</a> <a id="15911" href="Data.Int.html#15900" class="Bound">x</a> <a id="15913" href="Data.Int.html#15021" data-type="Int → Int → Int" class="Function Operator">+ℤ</a> <a id="15916" class="Number">0</a> <a id="15918" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="15920" href="Data.Int.html#15900" class="Bound">x</a>
<a id="15922" href="Data.Int.html#15888" data-type="(x : Int) → (x +ℤ 0) ≡ x" class="Function">+ℤ-zeror</a> <a id="15931" class="Symbol">=</a>
  <a id="15935" href="Data.Int.html#12458" data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" class="Function">Int-elim-prop</a> <a id="15949" class="Symbol">(λ</a> <a id="15952" href="Data.Int.html#15952" class="Bound">x</a> <a id="15954" class="Symbol">→</a> <a id="15956" href="Data.Int.html#9236" data-type="is-set Int" class="Function">Int-is-set</a> <a id="15967" class="Symbol">_</a> <a id="15969" class="Symbol">_)</a> <a id="15972" class="Symbol">(λ</a> <a id="15975" href="Data.Int.html#15975" class="Bound">a</a> <a id="15977" href="Data.Int.html#15977" class="Bound">b</a> <a id="15979" class="Symbol">→</a> <a id="15981" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="15985" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="15990" class="Symbol">(</a><a id="15991" href="Data.Nat.Properties.html#699" data-type="(x : Nat) → x + 0 ≡ x" class="Function">+-zeror</a> <a id="15999" href="Data.Int.html#15975" class="Bound">a</a><a id="16000" class="Symbol">)</a> <a id="16002" class="Symbol">(</a><a id="16003" href="Data.Nat.Properties.html#699" data-type="(x : Nat) → x + 0 ≡ x" class="Function">+-zeror</a> <a id="16011" href="Data.Int.html#15977" class="Bound">b</a><a id="16012" class="Symbol">))</a>

<a id="+ℤ-commutative"></a><a id="16016" href="Data.Int.html#16016" data-type="(x y : Int) → (x +ℤ y) ≡ (y +ℤ x)" class="Function">+ℤ-commutative</a> <a id="16031" class="Symbol">:</a> <a id="16033" class="Symbol">(</a><a id="16034" href="Data.Int.html#16034" class="Bound">x</a> <a id="16036" href="Data.Int.html#16036" class="Bound">y</a> <a id="16038" class="Symbol">:</a> <a id="16040" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a><a id="16043" class="Symbol">)</a> <a id="16045" class="Symbol">→</a> <a id="16047" href="Data.Int.html#16034" class="Bound">x</a> <a id="16049" href="Data.Int.html#15021" data-type="Int → Int → Int" class="Function Operator">+ℤ</a> <a id="16052" href="Data.Int.html#16036" class="Bound">y</a> <a id="16054" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="16056" href="Data.Int.html#16036" class="Bound">y</a> <a id="16058" href="Data.Int.html#15021" data-type="Int → Int → Int" class="Function Operator">+ℤ</a> <a id="16061" href="Data.Int.html#16034" class="Bound">x</a>
<a id="16063" href="Data.Int.html#16016" data-type="(x y : Int) → (x +ℤ y) ≡ (y +ℤ x)" class="Function">+ℤ-commutative</a> <a id="16078" class="Symbol">=</a>
  <a id="16082" href="Data.Int.html#12876" data-type="((x y : Int) → is-prop (P x y)) →
((a b x y : Nat) → P (diff a b) (diff x y)) → (x y : Int) → P x y" class="Function">Int-elim₂-prop</a> <a id="16097" class="Symbol">(λ</a> <a id="16100" href="Data.Int.html#16100" class="Bound">x</a> <a id="16102" href="Data.Int.html#16102" class="Bound">y</a> <a id="16104" class="Symbol">→</a> <a id="16106" href="Data.Int.html#9236" data-type="is-set Int" class="Function">Int-is-set</a> <a id="16117" class="Symbol">_</a> <a id="16119" class="Symbol">_)</a>
    <a id="16126" class="Symbol">(λ</a> <a id="16129" href="Data.Int.html#16129" class="Bound">a</a> <a id="16131" href="Data.Int.html#16131" class="Bound">b</a> <a id="16133" href="Data.Int.html#16133" class="Bound">c</a> <a id="16135" href="Data.Int.html#16135" class="Bound">d</a> <a id="16137" class="Symbol">→</a> <a id="16139" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="16143" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="16148" class="Symbol">(</a><a id="16149" href="Data.Nat.Properties.html#932" data-type="(x y : Nat) → x + y ≡ y + x" class="Function">+-commutative</a> <a id="16163" href="Data.Int.html#16129" class="Bound">a</a> <a id="16165" href="Data.Int.html#16133" class="Bound">c</a><a id="16166" class="Symbol">)</a> <a id="16168" class="Symbol">(</a><a id="16169" href="Data.Nat.Properties.html#932" data-type="(x y : Nat) → x + y ≡ y + x" class="Function">+-commutative</a> <a id="16183" href="Data.Int.html#16131" class="Bound">b</a> <a id="16185" href="Data.Int.html#16135" class="Bound">d</a><a id="16186" class="Symbol">))</a>
</pre>
<h2 id="inverses"><a href="#inverses" class="header-link">Inverses<span class="header-link-emoji">🔗</span></a></h2>
<p>Every integer <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> has an additive inverse, denoted <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">-x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord mathnormal">x</span></span></span></span>,</span> which is obtained by swapping the components of the pair. Since the definition of <span class="Agda"><a href="Data.Int.html#16450" class="Function">negate</a></span> is very simple, it can be written conveniently without using <span class="Agda"><a href="Data.Int.html#9556" class="Function">Int-rec</a></span>:</p>
<pre class="Agda"><a id="negate"></a><a id="16450" href="Data.Int.html#16450" data-type="Int → Int" class="Function">negate</a> <a id="16457" class="Symbol">:</a> <a id="16459" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a> <a id="16463" class="Symbol">→</a> <a id="16465" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a>
<a id="16469" href="Data.Int.html#16450" data-type="Int → Int" class="Function">negate</a> <a id="16476" class="Symbol">(</a><a id="16477" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="16482" href="Data.Int.html#16482" class="Bound">x</a> <a id="16484" href="Data.Int.html#16484" class="Bound">y</a><a id="16485" class="Symbol">)</a> <a id="16487" class="Symbol">=</a> <a id="16489" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="16494" href="Data.Int.html#16484" class="Bound">y</a> <a id="16496" href="Data.Int.html#16482" class="Bound">x</a>
<a id="16498" href="Data.Int.html#16450" data-type="Int → Int" class="Function">negate</a> <a id="16505" class="Symbol">(</a><a id="16506" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="16511" href="Data.Int.html#16511" class="Bound">m</a> <a id="16513" href="Data.Int.html#16513" class="Bound">n</a> <a id="16515" href="Data.Int.html#16515" class="Bound">i</a><a id="16516" class="Symbol">)</a> <a id="16518" class="Symbol">=</a> <a id="16520" href="Data.Int.html#853" data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" class="InductiveConstructor">quot</a> <a id="16525" href="Data.Int.html#16513" class="Bound">n</a> <a id="16527" href="Data.Int.html#16511" class="Bound">m</a> <a id="16529" href="Data.Int.html#16515" class="Bound">i</a>
</pre>
<p>The proof that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">-x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord mathnormal">x</span></span></span></span> is an additive inverse to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> follows, essentially, from commutativity of addition on natural numbers, and the fact that <span class="Agda"><a href="Data.Int.html#1531" class="Function">all zeroes are identified</a></span>.</p>
<pre class="Agda"><a id="+ℤ-inverser"></a><a id="16735" href="Data.Int.html#16735" data-type="(x : Int) → (x +ℤ negate x) ≡ 0" class="Function">+ℤ-inverser</a> <a id="16747" class="Symbol">:</a> <a id="16749" class="Symbol">(</a><a id="16750" href="Data.Int.html#16750" class="Bound">x</a> <a id="16752" class="Symbol">:</a> <a id="16754" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a><a id="16757" class="Symbol">)</a> <a id="16759" class="Symbol">→</a> <a id="16761" href="Data.Int.html#16750" class="Bound">x</a> <a id="16763" href="Data.Int.html#15021" data-type="Int → Int → Int" class="Function Operator">+ℤ</a> <a id="16766" href="Data.Int.html#16450" data-type="Int → Int" class="Function">negate</a> <a id="16773" href="Data.Int.html#16750" class="Bound">x</a> <a id="16775" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="16777" class="Number">0</a>
<a id="16779" href="Data.Int.html#16735" data-type="(x : Int) → (x +ℤ negate x) ≡ 0" class="Function">+ℤ-inverser</a> <a id="16791" class="Symbol">=</a>
  <a id="16795" href="Data.Int.html#12458" data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" class="Function">Int-elim-prop</a> <a id="16809" class="Symbol">(λ</a> <a id="16812" href="Data.Int.html#16812" class="Bound">_</a> <a id="16814" class="Symbol">→</a> <a id="16816" href="Data.Int.html#9236" data-type="is-set Int" class="Function">Int-is-set</a> <a id="16827" class="Symbol">_</a> <a id="16829" class="Symbol">_)</a> <a id="16832" class="Symbol">λ</a> <a id="16834" class="Keyword">where</a>
    <a id="16844" href="Data.Int.html#16844" class="Bound">a</a> <a id="16846" href="Data.Int.html#16846" class="Bound">b</a> <a id="16848" class="Symbol">→</a> <a id="16850" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="16855" class="Symbol">(</a><a id="16856" href="Data.Int.html#16844" class="Bound">a</a> <a id="16858" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="16860" href="Data.Int.html#16846" class="Bound">b</a><a id="16861" class="Symbol">)</a> <a id="16863" class="Symbol">(</a><a id="16864" href="Data.Int.html#16846" class="Bound">b</a> <a id="16866" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="16868" href="Data.Int.html#16844" class="Bound">a</a><a id="16869" class="Symbol">)</a> <a id="16871" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="16874" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="16878" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="16883" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="16888" class="Symbol">(</a><a id="16889" href="Data.Nat.Properties.html#932" data-type="(x y : Nat) → x + y ≡ y + x" class="Function">+-commutative</a> <a id="16903" href="Data.Int.html#16846" class="Bound">b</a> <a id="16905" href="Data.Int.html#16844" class="Bound">a</a><a id="16906" class="Symbol">)</a> <a id="16908" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
          <a id="16920" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="16925" class="Symbol">(</a><a id="16926" href="Data.Int.html#16844" class="Bound">a</a> <a id="16928" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="16930" href="Data.Int.html#16846" class="Bound">b</a><a id="16931" class="Symbol">)</a> <a id="16933" class="Symbol">(</a><a id="16934" href="Data.Int.html#16844" class="Bound">a</a> <a id="16936" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="16938" href="Data.Int.html#16846" class="Bound">b</a><a id="16939" class="Symbol">)</a> <a id="16941" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="16944" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="16948" class="Symbol">(</a><a id="16949" href="Data.Int.html#1531" data-type="(n : Nat) → diff 0 0 ≡ diff n n" class="Function">zeroes</a> <a id="16956" class="Symbol">(</a><a id="16957" href="Data.Int.html#16844" class="Bound">a</a> <a id="16959" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="16961" href="Data.Int.html#16846" class="Bound">b</a><a id="16962" class="Symbol">))</a> <a id="16965" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
          <a id="16977" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="16982" class="Number">0</a> <a id="16984" class="Number">0</a>             <a id="16998" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

<a id="+ℤ-inversel"></a><a id="17001" href="Data.Int.html#17001" data-type="(x : Int) → (negate x +ℤ x) ≡ 0" class="Function">+ℤ-inversel</a> <a id="17013" class="Symbol">:</a> <a id="17015" class="Symbol">(</a><a id="17016" href="Data.Int.html#17016" class="Bound">x</a> <a id="17018" class="Symbol">:</a> <a id="17020" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a><a id="17023" class="Symbol">)</a> <a id="17025" class="Symbol">→</a> <a id="17027" href="Data.Int.html#16450" data-type="Int → Int" class="Function">negate</a> <a id="17034" href="Data.Int.html#17016" class="Bound">x</a> <a id="17036" href="Data.Int.html#15021" data-type="Int → Int → Int" class="Function Operator">+ℤ</a> <a id="17039" href="Data.Int.html#17016" class="Bound">x</a> <a id="17041" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="17043" class="Number">0</a>
<a id="17045" href="Data.Int.html#17001" data-type="(x : Int) → (negate x +ℤ x) ≡ 0" class="Function">+ℤ-inversel</a> <a id="17057" class="Symbol">=</a>
  <a id="17061" href="Data.Int.html#12458" data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" class="Function">Int-elim-prop</a> <a id="17075" class="Symbol">(λ</a> <a id="17078" href="Data.Int.html#17078" class="Bound">_</a> <a id="17080" class="Symbol">→</a> <a id="17082" href="Data.Int.html#9236" data-type="is-set Int" class="Function">Int-is-set</a> <a id="17093" class="Symbol">_</a> <a id="17095" class="Symbol">_)</a> <a id="17098" class="Symbol">λ</a> <a id="17100" class="Keyword">where</a>
    <a id="17110" href="Data.Int.html#17110" class="Bound">a</a> <a id="17112" href="Data.Int.html#17112" class="Bound">b</a> <a id="17114" class="Symbol">→</a> <a id="17116" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="17121" class="Symbol">(</a><a id="17122" href="Data.Int.html#17112" class="Bound">b</a> <a id="17124" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="17126" href="Data.Int.html#17110" class="Bound">a</a><a id="17127" class="Symbol">)</a> <a id="17129" class="Symbol">(</a><a id="17130" href="Data.Int.html#17110" class="Bound">a</a> <a id="17132" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="17134" href="Data.Int.html#17112" class="Bound">b</a><a id="17135" class="Symbol">)</a> <a id="17137" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="17140" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="17144" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="17149" class="Symbol">(</a><a id="17150" href="Data.Nat.Properties.html#932" data-type="(x y : Nat) → x + y ≡ y + x" class="Function">+-commutative</a> <a id="17164" href="Data.Int.html#17112" class="Bound">b</a> <a id="17166" href="Data.Int.html#17110" class="Bound">a</a><a id="17167" class="Symbol">)</a> <a id="17169" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="17174" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
          <a id="17186" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="17191" class="Symbol">(</a><a id="17192" href="Data.Int.html#17110" class="Bound">a</a> <a id="17194" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="17196" href="Data.Int.html#17112" class="Bound">b</a><a id="17197" class="Symbol">)</a> <a id="17199" class="Symbol">(</a><a id="17200" href="Data.Int.html#17110" class="Bound">a</a> <a id="17202" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="17204" href="Data.Int.html#17112" class="Bound">b</a><a id="17205" class="Symbol">)</a> <a id="17207" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="17210" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="17214" class="Symbol">(</a><a id="17215" href="Data.Int.html#1531" data-type="(n : Nat) → diff 0 0 ≡ diff n n" class="Function">zeroes</a> <a id="17222" class="Symbol">(</a><a id="17223" href="Data.Int.html#17110" class="Bound">a</a> <a id="17225" href="Agda.Builtin.Nat.html#325" data-type="Nat → Nat → Nat" class="Primitive Operator">+</a> <a id="17227" href="Data.Int.html#17112" class="Bound">b</a><a id="17228" class="Symbol">))</a> <a id="17231" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
          <a id="17243" href="Data.Int.html#826" data-type="Nat → Nat → Int" class="InductiveConstructor">diff</a> <a id="17248" class="Number">0</a> <a id="17250" class="Number">0</a>             <a id="17264" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
</pre>
<p>Since <span class="Agda"><a href="Data.Int.html#16450" class="Function">negate</a></span> is precisely what’s missing for <span class="Agda"><a href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a></span> to be a group, we <em>can</em> turn <a href="Algebra.Group.html#the-integers">the integers</a> into a group. Subtraction is defined as addition with the inverse, rather than directly on <span class="Agda"><a href="Data.Int.html#826" class="InductiveConstructor">diff</a></span>:</p>
<pre class="Agda"><a id="_-ℤ_"></a><a id="17546" href="Data.Int.html#17546" data-type="Int → Int → Int" class="Function Operator">_-ℤ_</a> <a id="17551" class="Symbol">:</a> <a id="17553" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a> <a id="17557" class="Symbol">→</a> <a id="17559" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a> <a id="17563" class="Symbol">→</a> <a id="17565" href="Data.Int.html#807" data-type="Type" class="Datatype">Int</a>
<a id="17569" href="Data.Int.html#17569" class="Bound">x</a> <a id="17571" href="Data.Int.html#17546" data-type="Int → Int → Int" class="Function Operator">-ℤ</a> <a id="17574" href="Data.Int.html#17574" class="Bound">y</a> <a id="17576" class="Symbol">=</a> <a id="17578" href="Data.Int.html#17569" class="Bound">x</a> <a id="17580" href="Data.Int.html#15021" data-type="Int → Int → Int" class="Function Operator">+ℤ</a> <a id="17583" href="Data.Int.html#16450" data-type="Int → Int" class="Function">negate</a> <a id="17590" href="Data.Int.html#17574" class="Bound">y</a>
</pre>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>In the diagram, we write <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">S</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\id{S}x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathrm">S</span><span class="mord mathnormal">x</span></span></span></span> for <code>suc x</code>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
  </article>
</div>
</main>
</body>
</html>
