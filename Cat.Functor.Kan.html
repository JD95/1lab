<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>Cat.Functor.Kan - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Cat.Functor.Kan - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="Cat.Functor.Kan - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script defer src="/main.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

  <!-- Google font embeds -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&amp;family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">Cat.Functor.Kan</a>
              </h3>

      <!-- Cube logo -->
      <a id="logo" href="/">
        <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />
      </a>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#kan-extensions"><a href="#kan-extensions" class="header-link">Kan extensions<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#ubiquity"><a href="#ubiquity" class="header-link">Ubiquity<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#a-formula"><a href="#a-formula" class="header-link">A formula<span class="header-link-emoji">🔗</span></a></a></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>

        <!-- Sidebar footnotes control -->
        <span class="inline-footnotes" style="display: none; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-fns" type="checkbox" class="inline-footnotes" id="sidebar-fns">
          <label for="sidebar-fns">Inline Footnotes</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
        <div class="search-form search-form-proxy" role="form">
          <input id="search-box-proxy" type_="text" placeholder="Search..." autocomplete="off" tabindex="0"></input>
        </div>

              <a href="/">back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/88cfc5c6046a4db6730c322e150410277202564a/src/Cat/Functor/Kan.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao and Naïm Favier</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="/">back to index</a>
      </div>
      
      <!-- Navbar equations control -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>

      <!-- Navbar footnotes control -->
      <span class="inline-footnotes" style="display: none; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-fns" type="checkbox" class="inline-footnotes" id="navbar-fns">
        <label for="navbar-fns">Inline Footnotes</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="Cat.Instances.Shape.Terminal.html" class="Module">Cat.Instances.Shape.Terminal</a>
<a id="50" class="Keyword">open</a> <a id="55" class="Keyword">import</a> <a id="62" href="Cat.Diagram.Colimit.Base.html" class="Module">Cat.Diagram.Colimit.Base</a>
<a id="87" class="Keyword">open</a> <a id="92" class="Keyword">import</a> <a id="99" href="Cat.Instances.Functor.html" class="Module">Cat.Instances.Functor</a>
<a id="121" class="Keyword">open</a> <a id="126" class="Keyword">import</a> <a id="133" href="Cat.Diagram.Initial.html" class="Module">Cat.Diagram.Initial</a>
<a id="153" class="Keyword">open</a> <a id="158" class="Keyword">import</a> <a id="165" href="Cat.Functor.Adjoint.html" class="Module">Cat.Functor.Adjoint</a>
<a id="185" class="Keyword">open</a> <a id="190" class="Keyword">import</a> <a id="197" href="Cat.Instances.Comma.html" class="Module">Cat.Instances.Comma</a>
<a id="217" class="Keyword">open</a> <a id="222" class="Keyword">import</a> <a id="229" href="Cat.Functor.Base.html" class="Module">Cat.Functor.Base</a>
<a id="246" class="Keyword">open</a> <a id="251" class="Keyword">import</a> <a id="258" href="Cat.Prelude.html" class="Module">Cat.Prelude</a>

<a id="271" class="Keyword">import</a> <a id="278" href="Cat.Functor.Reasoning.html" class="Module">Cat.Functor.Reasoning</a> <a id="300" class="Symbol">as</a> <a id="303" class="Module">Func</a>
<a id="308" class="Keyword">import</a> <a id="315" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="329" class="Symbol">as</a> <a id="332" class="Module">Cat</a>

<a id="337" class="Keyword">module</a> <a id="344" href="Cat.Functor.Kan.html" class="Module">Cat.Functor.Kan</a> <a id="360" class="Keyword">where</a>
</pre>
<!--
<pre class="Agda"><a id="384" class="Keyword">private</a>
  <a id="394" class="Keyword">variable</a>
    <a id="407" href="Cat.Functor.Kan.html#407" class="Generalizable">o</a> <a id="409" href="Cat.Functor.Kan.html#409" class="Generalizable">ℓ</a> <a id="411" class="Symbol">:</a> <a id="413" href="Agda.Primitive.html#597" data-type="Type" class="Postulate">Level</a>
    <a id="423" href="Cat.Functor.Kan.html#423" class="Generalizable">C</a> <a id="425" href="Cat.Functor.Kan.html#425" class="Generalizable">C′</a> <a id="428" href="Cat.Functor.Kan.html#428" class="Generalizable">D</a> <a id="430" class="Symbol">:</a> <a id="432" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="444" href="Cat.Functor.Kan.html#407" class="Generalizable">o</a> <a id="446" href="Cat.Functor.Kan.html#409" class="Generalizable">ℓ</a>
  <a id="kan-lvl"></a><a id="450" href="Cat.Functor.Kan.html#450" class="Function">kan-lvl</a> <a id="458" class="Symbol">:</a> <a id="460" class="Symbol">∀</a> <a id="462" class="Symbol">{</a><a id="463" href="Cat.Functor.Kan.html#463" class="Bound">o</a> <a id="465" href="Cat.Functor.Kan.html#465" class="Bound">ℓ</a> <a id="467" href="Cat.Functor.Kan.html#467" class="Bound">o′</a> <a id="470" href="Cat.Functor.Kan.html#470" class="Bound">ℓ′</a> <a id="473" href="Cat.Functor.Kan.html#473" class="Bound">o′′</a> <a id="477" href="Cat.Functor.Kan.html#477" class="Bound">ℓ′′</a><a id="480" class="Symbol">}</a> <a id="482" class="Symbol">{</a><a id="483" href="Cat.Functor.Kan.html#483" class="Bound">C</a> <a id="485" class="Symbol">:</a> <a id="487" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="499" href="Cat.Functor.Kan.html#463" class="Bound">o</a> <a id="501" href="Cat.Functor.Kan.html#465" class="Bound">ℓ</a><a id="502" class="Symbol">}</a> <a id="504" class="Symbol">{</a><a id="505" href="Cat.Functor.Kan.html#505" class="Bound">C′</a> <a id="508" class="Symbol">:</a> <a id="510" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="522" href="Cat.Functor.Kan.html#467" class="Bound">o′</a> <a id="525" href="Cat.Functor.Kan.html#470" class="Bound">ℓ′</a><a id="527" class="Symbol">}</a> <a id="529" class="Symbol">{</a><a id="530" href="Cat.Functor.Kan.html#530" class="Bound">D</a> <a id="532" class="Symbol">:</a> <a id="534" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="546" href="Cat.Functor.Kan.html#473" class="Bound">o′′</a> <a id="550" href="Cat.Functor.Kan.html#477" class="Bound">ℓ′′</a><a id="553" class="Symbol">}</a>
          <a id="565" class="Symbol">→</a> <a id="567" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="575" href="Cat.Functor.Kan.html#483" class="Bound">C</a> <a id="577" href="Cat.Functor.Kan.html#530" class="Bound">D</a> <a id="579" class="Symbol">→</a> <a id="581" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="589" href="Cat.Functor.Kan.html#483" class="Bound">C</a> <a id="591" href="Cat.Functor.Kan.html#505" class="Bound">C′</a> <a id="594" class="Symbol">→</a> <a id="596" href="Agda.Primitive.html#597" data-type="Type" class="Postulate">Level</a>
  <a id="604" href="Cat.Functor.Kan.html#450" class="Function">kan-lvl</a> <a id="612" class="Symbol">{</a><a id="613" href="Cat.Functor.Kan.html#613" class="Bound">a</a><a id="614" class="Symbol">}</a> <a id="616" class="Symbol">{</a><a id="617" href="Cat.Functor.Kan.html#617" class="Bound">b</a><a id="618" class="Symbol">}</a> <a id="620" class="Symbol">{</a><a id="621" href="Cat.Functor.Kan.html#621" class="Bound">c</a><a id="622" class="Symbol">}</a> <a id="624" class="Symbol">{</a><a id="625" href="Cat.Functor.Kan.html#625" class="Bound">d</a><a id="626" class="Symbol">}</a> <a id="628" class="Symbol">{</a><a id="629" href="Cat.Functor.Kan.html#629" class="Bound">e</a><a id="630" class="Symbol">}</a> <a id="632" class="Symbol">{</a><a id="633" href="Cat.Functor.Kan.html#633" class="Bound">f</a><a id="634" class="Symbol">}</a> <a id="636" class="Symbol">_</a> <a id="638" class="Symbol">_</a> <a id="640" class="Symbol">=</a> <a id="642" href="Cat.Functor.Kan.html#613" class="Bound">a</a> <a id="644" href="Agda.Primitive.html#810" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="646" href="Cat.Functor.Kan.html#617" class="Bound">b</a> <a id="648" href="Agda.Primitive.html#810" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="650" href="Cat.Functor.Kan.html#621" class="Bound">c</a> <a id="652" href="Agda.Primitive.html#810" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="654" href="Cat.Functor.Kan.html#625" class="Bound">d</a> <a id="656" href="Agda.Primitive.html#810" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="658" href="Cat.Functor.Kan.html#629" class="Bound">e</a> <a id="660" href="Agda.Primitive.html#810" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="662" href="Cat.Functor.Kan.html#633" class="Bound">f</a>
</pre>-->
<h1 id="kan-extensions"><a href="#kan-extensions" class="header-link">Kan extensions<span class="header-link-emoji">🔗</span></a></h1>
<p>Suppose we have a functor <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi mathvariant="script">C</mi><mo>→</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">F : \ca{C} \to \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>,</span> and a functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>:</mo><mi mathvariant="script">C</mi><mo>→</mo><msup><mi mathvariant="script">C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">p : \ca{C} \to \ca{C}&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> — perhaps to be thought of as a <a href="Cat.Functor.FullSubcategory.html">full subcategory</a> inclusion, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="script">C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">\ca{C}&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> is a completion of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>,</span> but the situation applies just as well to any pair of functors — which naturally fit into a commutative diagram</p>
<div class="diagram-container">
<img src="6a32e823706fad23aaaa018b81e7575133a4f0dc.svg" title="commutative diagram" class="diagram quiver" />
</div>
<p>but as we can see this is a particularly sad commutative diagram; it’s crying out for a third edge <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="script">C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>→</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\ca{C}&#39; \to \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span></p>
<div class="diagram-container">
<img src="835eef6d4aa8e64f94cef52f789dacbb0d6419b8.svg" title="commutative diagram" class="diagram quiver" />
</div>
<p>extending <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> to a functor <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="script">C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>→</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\ca{C}&#39; \to \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>.</span> If there exists an <em>universal</em> such extension (we’ll define what “universal” means in just a second), we call it the <strong>left Kan extension</strong> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> along <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>,</span> and denote it <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mi>p</mi></msub><mi>F</mi></mrow><annotation encoding="application/x-tex">\Lan_p F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Lan</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>.</span> Such extensions do not come for free (in a sense they’re pretty hard to come by), but concept of Kan extension can be used to rephrase the definition of both <a href="Cat.Diagram.Limit.Base.html">limit</a> and <a href="Cat.Functor.Adjoint.html">adjoint functor</a>.</p>
<p>A left Kan extension <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mi>p</mi></msub><mi>F</mi></mrow><annotation encoding="application/x-tex">\Lan_p F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Lan</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> is equipped with a natural transformation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi><mo>:</mo><mi>F</mi><mo>⇒</mo><msub><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mi>p</mi></msub><mi>F</mi><mo>∘</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">\eta : F \To \Lan_p F \circ p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Lan</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> witnessing the (“directed”) commutativity of the triangle (so that it need not commute on-the-nose) which is universal among such transformations; Meaning that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>:</mo><msup><mi mathvariant="script">C</mi><mo mathvariant="script" lspace="0em" rspace="0em">′</mo></msup><mo>→</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">M : \ca{C&#39;} \to \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span> is another functor with a transformation <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>:</mo><mi>M</mi><mo>⇒</mo><mi>M</mi><mo>∘</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">\alpha : M \To M \circ p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>,</span> there is a unique natural transformation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo>:</mo><msub><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mi>p</mi></msub><mi>F</mi><mo>⇒</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\sigma : \Lan_p F \To M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Lan</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> which commutes with <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>.</span></p>
<p>Note that in general the triangle commutes “weakly,” but when <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> is <a href="Cat.Functor.Base.html#ff-functors">fully faithful</a> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span> is <a href="Cat.Diagram.Colimit.Base.html#cocompleteness">cocomplete</a>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mi>p</mi></msub><mi>F</mi></mrow><annotation encoding="application/x-tex">\Lan_p F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Lan</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> genuinely extends <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>,</span> in that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span> is a natural isomorphism.</p>
<pre class="Agda"><a id="2831" class="Keyword">record</a> <a id="Lan"></a><a id="2838" href="Cat.Functor.Kan.html#2838" data-type="(p : Functor C C′) (F : Functor C D) →
Type (C.o ⊔ C.ℓ ⊔ C′.o ⊔ C′.ℓ ⊔ D.o ⊔ D.ℓ)" class="Record">Lan</a> <a id="2842" class="Symbol">(</a><a id="2843" href="Cat.Functor.Kan.html#2843" class="Bound">p</a> <a id="2845" class="Symbol">:</a> <a id="2847" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="2855" href="Cat.Functor.Kan.html#423" class="Generalizable">C</a> <a id="2857" href="Cat.Functor.Kan.html#425" class="Generalizable">C′</a><a id="2859" class="Symbol">)</a> <a id="2861" class="Symbol">(</a><a id="2862" href="Cat.Functor.Kan.html#2862" class="Bound">F</a> <a id="2864" class="Symbol">:</a> <a id="2866" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="2874" href="Cat.Functor.Kan.html#423" class="Generalizable">C</a> <a id="2876" href="Cat.Functor.Kan.html#428" class="Generalizable">D</a><a id="2877" class="Symbol">)</a> <a id="2879" class="Symbol">:</a> <a id="2881" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2886" class="Symbol">(</a><a id="2887" href="Cat.Functor.Kan.html#450" class="Function">kan-lvl</a> <a id="2895" href="Cat.Functor.Kan.html#2843" class="Bound">p</a> <a id="2897" href="Cat.Functor.Kan.html#2862" class="Bound">F</a><a id="2898" class="Symbol">)</a> <a id="2900" class="Keyword">where</a>
  <a id="2908" class="Keyword">field</a>
    <a id="Lan.Ext"></a><a id="2918" href="Cat.Functor.Kan.html#2918" data-type="Lan p F → Functor C′ D" class="Field">Ext</a> <a id="2922" class="Symbol">:</a> <a id="2924" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="2932" href="Cat.Functor.Kan.html#2857" class="Bound">C′</a> <a id="2935" href="Cat.Functor.Kan.html#2876" class="Bound">D</a>
    <a id="Lan.eta"></a><a id="2941" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a> <a id="2945" class="Symbol">:</a> <a id="2947" href="Cat.Functor.Kan.html#2862" class="Bound">F</a> <a id="2949" href="Cat.Base.html#12241" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Record Operator">=&gt;</a> <a id="2952" href="Cat.Functor.Kan.html#2918" data-type="Lan p F → Functor C′ D" class="Field">Ext</a> <a id="2956" href="Cat.Base.html#9697" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="2959" href="Cat.Functor.Kan.html#2843" class="Bound">p</a>
</pre>
<p>Universality of <span class="Agda"><a href="Cat.Functor.Kan.html#2941" class="Field">eta</a></span> is witnessed by the following fields, which essentially say that, in the diagram below (assuming <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> has a natural transformation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> witnessing the same “directed commutativity” that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span> does for <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mi>p</mi></msub><mi>F</mi></mrow><annotation encoding="application/x-tex">\Lan_p F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Lan</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>),</span> the 2-cell exists and is unique.</p>
<div class="diagram-container">
<img src="f0ea9b4df8662303a1afd8dcde622d9329c08d48.svg" title="commutative diagram" class="diagram quiver" />
</div>
<pre class="Agda">    <a id="Lan.σ"></a><a id="3692" href="Cat.Functor.Kan.html#3692" data-type="(r : Lan p F) → F =&gt; M F∘ p → r .Ext =&gt; M" class="Field">σ</a> <a id="3694" class="Symbol">:</a> <a id="3696" class="Symbol">{</a><a id="3697" href="Cat.Functor.Kan.html#3697" class="Bound">M</a> <a id="3699" class="Symbol">:</a> <a id="3701" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="3709" href="Cat.Functor.Kan.html#2857" class="Bound">C′</a> <a id="3712" href="Cat.Functor.Kan.html#2876" class="Bound">D</a><a id="3713" class="Symbol">}</a> <a id="3715" class="Symbol">(</a><a id="3716" href="Cat.Functor.Kan.html#3716" class="Bound">α</a> <a id="3718" class="Symbol">:</a> <a id="3720" href="Cat.Functor.Kan.html#2862" class="Bound">F</a> <a id="3722" href="Cat.Base.html#12241" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Record Operator">=&gt;</a> <a id="3725" href="Cat.Functor.Kan.html#3697" class="Bound">M</a> <a id="3727" href="Cat.Base.html#9697" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="3730" href="Cat.Functor.Kan.html#2843" class="Bound">p</a><a id="3731" class="Symbol">)</a> <a id="3733" class="Symbol">→</a> <a id="3735" href="Cat.Functor.Kan.html#2918" data-type="Lan p F → Functor C′ D" class="Field">Ext</a> <a id="3739" href="Cat.Base.html#12241" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Record Operator">=&gt;</a> <a id="3742" href="Cat.Functor.Kan.html#3697" class="Bound">M</a>
    <a id="Lan.σ-comm"></a><a id="3748" href="Cat.Functor.Kan.html#3748" data-type="(r : Lan p F) → (whiskerl (r .σ α) ∘nt r .eta) ≡ α" class="Field">σ-comm</a> <a id="3755" class="Symbol">:</a> <a id="3757" class="Symbol">{</a><a id="3758" href="Cat.Functor.Kan.html#3758" class="Bound">M</a> <a id="3760" class="Symbol">:</a> <a id="3762" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="3770" href="Cat.Functor.Kan.html#2857" class="Bound">C′</a> <a id="3773" href="Cat.Functor.Kan.html#2876" class="Bound">D</a><a id="3774" class="Symbol">}</a> <a id="3776" class="Symbol">{</a><a id="3777" href="Cat.Functor.Kan.html#3777" class="Bound">α</a> <a id="3779" class="Symbol">:</a> <a id="3781" href="Cat.Functor.Kan.html#2862" class="Bound">F</a> <a id="3783" href="Cat.Base.html#12241" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Record Operator">=&gt;</a> <a id="3786" href="Cat.Functor.Kan.html#3758" class="Bound">M</a> <a id="3788" href="Cat.Base.html#9697" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="3791" href="Cat.Functor.Kan.html#2843" class="Bound">p</a><a id="3792" class="Symbol">}</a> <a id="3794" class="Symbol">→</a> <a id="3796" href="Cat.Instances.Functor.html#13532" data-type="F =&gt; G → F F∘ H =&gt; G F∘ H" class="Function">whiskerl</a> <a id="3805" class="Symbol">(</a><a id="3806" href="Cat.Functor.Kan.html#3692" data-type="(r : Lan p F) → F =&gt; M F∘ p → r .Ext =&gt; M" class="Field">σ</a> <a id="3808" href="Cat.Functor.Kan.html#3777" class="Bound">α</a><a id="3809" class="Symbol">)</a> <a id="3811" href="Cat.Instances.Functor.html#890" data-type="G =&gt; H → F =&gt; G → F =&gt; H" class="Function Operator">∘nt</a> <a id="3815" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a> <a id="3819" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3821" href="Cat.Functor.Kan.html#3777" class="Bound">α</a>
    <a id="Lan.σ-uniq"></a><a id="3827" href="Cat.Functor.Kan.html#3827" data-type="(r : Lan p F) → α ≡ (whiskerl σ′ ∘nt r .eta) → r .σ α ≡ σ′" class="Field">σ-uniq</a> <a id="3834" class="Symbol">:</a> <a id="3836" class="Symbol">{</a><a id="3837" href="Cat.Functor.Kan.html#3837" class="Bound">M</a> <a id="3839" class="Symbol">:</a> <a id="3841" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="3849" href="Cat.Functor.Kan.html#2857" class="Bound">C′</a> <a id="3852" href="Cat.Functor.Kan.html#2876" class="Bound">D</a><a id="3853" class="Symbol">}</a> <a id="3855" class="Symbol">{</a><a id="3856" href="Cat.Functor.Kan.html#3856" class="Bound">α</a> <a id="3858" class="Symbol">:</a> <a id="3860" href="Cat.Functor.Kan.html#2862" class="Bound">F</a> <a id="3862" href="Cat.Base.html#12241" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Record Operator">=&gt;</a> <a id="3865" href="Cat.Functor.Kan.html#3837" class="Bound">M</a> <a id="3867" href="Cat.Base.html#9697" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="3870" href="Cat.Functor.Kan.html#2843" class="Bound">p</a><a id="3871" class="Symbol">}</a> <a id="3873" class="Symbol">{</a><a id="3874" href="Cat.Functor.Kan.html#3874" class="Bound">σ′</a> <a id="3877" class="Symbol">:</a> <a id="3879" href="Cat.Functor.Kan.html#2918" data-type="Lan p F → Functor C′ D" class="Field">Ext</a> <a id="3883" href="Cat.Base.html#12241" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Record Operator">=&gt;</a> <a id="3886" href="Cat.Functor.Kan.html#3837" class="Bound">M</a><a id="3887" class="Symbol">}</a>
           <a id="3900" class="Symbol">→</a> <a id="3902" href="Cat.Functor.Kan.html#3856" class="Bound">α</a> <a id="3904" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3906" href="Cat.Instances.Functor.html#13532" data-type="F =&gt; G → F F∘ H =&gt; G F∘ H" class="Function">whiskerl</a> <a id="3915" href="Cat.Functor.Kan.html#3874" class="Bound">σ′</a> <a id="3918" href="Cat.Instances.Functor.html#890" data-type="G =&gt; H → F =&gt; G → F =&gt; H" class="Function Operator">∘nt</a> <a id="3922" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a>
           <a id="3937" class="Symbol">→</a> <a id="3939" href="Cat.Functor.Kan.html#3692" data-type="(r : Lan p F) → F =&gt; M F∘ p → r .Ext =&gt; M" class="Field">σ</a> <a id="3941" href="Cat.Functor.Kan.html#3856" class="Bound">α</a> <a id="3943" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3945" href="Cat.Functor.Kan.html#3874" class="Bound">σ′</a>
</pre>
<h2 id="ubiquity"><a href="#ubiquity" class="header-link">Ubiquity<span class="header-link-emoji">🔗</span></a></h2>
<p>The elevator pitch for Kan extensions is that “all concepts are Kan extensions.” The example we will give here is that, if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>⊣</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">F \dashv G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> is an adjunction, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mi>η</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(G, \eta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span><span class="mclose">)</span></span></span></span> gives <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mi>F</mi></msub><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">d</mi></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Lan_F(\id{Id})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Lan</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">Id</span></span><span class="mclose">)</span></span></span></span>.</span> This isn’t exactly enlightening: adjunctions and Kan extensions have very different vibes, but the latter concept <em>is</em> a legitimate generalisation.</p>
<!--
<pre class="Agda"><a id="4324" class="Keyword">module</a> <a id="4331" href="Cat.Functor.Kan.html#4331" class="Module">_</a> <a id="4333" class="Symbol">{</a><a id="4334" href="Cat.Functor.Kan.html#4334" class="Bound">F</a> <a id="4336" class="Symbol">:</a> <a id="4338" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="4346" href="Cat.Functor.Kan.html#423" class="Generalizable">C</a> <a id="4348" href="Cat.Functor.Kan.html#428" class="Generalizable">D</a><a id="4349" class="Symbol">}</a> <a id="4351" class="Symbol">{</a><a id="4352" href="Cat.Functor.Kan.html#4352" class="Bound">G</a> <a id="4354" class="Symbol">:</a> <a id="4356" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="4364" href="Cat.Functor.Kan.html#428" class="Generalizable">D</a> <a id="4366" href="Cat.Functor.Kan.html#423" class="Generalizable">C</a><a id="4367" class="Symbol">}</a> <a id="4369" class="Symbol">(</a><a id="4370" href="Cat.Functor.Kan.html#4370" class="Bound">adj</a> <a id="4374" class="Symbol">:</a> <a id="4376" href="Cat.Functor.Kan.html#4334" class="Bound">F</a> <a id="4378" href="Cat.Functor.Adjoint.html#1933" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record Operator">⊣</a> <a id="4380" href="Cat.Functor.Kan.html#4352" class="Bound">G</a><a id="4381" class="Symbol">)</a> <a id="4383" class="Keyword">where</a>
  <a id="4391" class="Keyword">open</a> <a id="4396" href="Cat.Functor.Kan.html#2838" data-type="(p : Functor C C′) (F : Functor C D) →
Type (C.o ⊔ C.ℓ ⊔ C′.o ⊔ C′.ℓ ⊔ D.o ⊔ D.ℓ)" class="Module">Lan</a>
  <a id="4402" class="Keyword">private</a>
    <a id="4414" class="Keyword">module</a> <a id="4421" href="Cat.Functor.Kan.html#4421" class="Module">F</a> <a id="4423" class="Symbol">=</a> <a id="4425" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Module">Functor</a> <a id="4433" href="Cat.Functor.Kan.html#4334" class="Bound">F</a>
    <a id="4439" class="Keyword">module</a> <a id="4446" href="Cat.Functor.Kan.html#4446" class="Module">G</a> <a id="4448" class="Symbol">=</a> <a id="4450" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Module">Functor</a> <a id="4458" href="Cat.Functor.Kan.html#4352" class="Bound">G</a>
    <a id="4464" class="Keyword">module</a> <a id="4471" href="Cat.Functor.Kan.html#4471" class="Module">C</a> <a id="4473" class="Symbol">=</a> <a id="4475" href="Cat.Reasoning.html" class="Module">Cat</a> <a id="4479" href="Cat.Functor.Kan.html#4346" class="Bound">C</a>
    <a id="4485" class="Keyword">module</a> <a id="4492" href="Cat.Functor.Kan.html#4492" class="Module">D</a> <a id="4494" class="Symbol">=</a> <a id="4496" href="Cat.Reasoning.html" class="Module">Cat</a> <a id="4500" href="Cat.Functor.Kan.html#4348" class="Bound">D</a>
  <a id="4504" class="Keyword">open</a> <a id="4509" href="Cat.Functor.Adjoint.html#1933" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Module Operator">_⊣_</a> <a id="4513" href="Cat.Functor.Kan.html#4370" class="Bound">adj</a>
  <a id="4519" class="Keyword">open</a> <a id="4524" href="Cat.Base.html#12241" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Module Operator">_=&gt;_</a>
</pre>-->
<pre class="Agda">  <a id="4548" href="Cat.Functor.Kan.html#4548" data-type="(adj : F ⊣ G) → Lan F Id" class="Function">adjoint→lan</a> <a id="4560" class="Symbol">:</a> <a id="4562" href="Cat.Functor.Kan.html#2838" data-type="(p : Functor C C′) (F : Functor C D) →
Type (C.o ⊔ C.ℓ ⊔ C′.o ⊔ C′.ℓ ⊔ D.o ⊔ D.ℓ)" class="Record">Lan</a> <a id="4566" href="Cat.Functor.Kan.html#4334" class="Bound">F</a> <a id="4568" href="Cat.Base.html#11722" data-type="Functor C C" class="Function">Id</a>
  <a id="4573" href="Cat.Functor.Kan.html#4548" data-type="(adj : F ⊣ G) → Lan F Id" class="Function">adjoint→lan</a> <a id="4585" class="Symbol">.</a><a id="4586" href="Cat.Functor.Kan.html#2918" data-type="Lan p F → Functor C′ D" class="Field">Ext</a> <a id="4590" class="Symbol">=</a> <a id="4592" href="Cat.Functor.Kan.html#4352" class="Bound">G</a>
  <a id="4596" href="Cat.Functor.Kan.html#4548" data-type="(adj : F ⊣ G) → Lan F Id" class="Function">adjoint→lan</a> <a id="4608" class="Symbol">.</a><a id="4609" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a> <a id="4613" class="Symbol">=</a> <a id="4615" href="Cat.Functor.Adjoint.html#2083" data-type="L ⊣ R₁ → Id =&gt; R₁ F∘ L" class="Field">unit</a>
</pre>
<p>The proof is mostly pushing symbols around, and the calculation is available below unabridged. In components, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> must give, assuming a map <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>:</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">d</mi></mrow><mo>⇒</mo><mi>M</mi><mi>F</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\alpha : \id{Id} \To MFx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">Id</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">MF</span><span class="mord mathnormal">x</span></span></span></span>,</span> a map <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>x</mi><mo>→</mo><mi>M</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">Gx \to Mx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">x</span></span></span></span>.</span> The transformation we’re looking for arises as the composite</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>G</mi><mi>x</mi><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mi>α</mi></mpadded></mover><mi>M</mi><mi>F</mi><mi>G</mi><mi>x</mi><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mrow><mi>M</mi><mi>ε</mi></mrow></mpadded></mover><mi>M</mi><mi>x</mi><mtext>,</mtext></mrow><annotation encoding="application/x-tex">
Gx \xto{\alpha} MFGx \xto{M\epsilon} Mx\text{,}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9344em;vertical-align:-0.011em;"></span><span class="mord mathnormal">G</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9234em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1113em;vertical-align:-0.011em;"></span><span class="mord mathnormal">MFG</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1003em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight">Mε</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">x</span><span class="mord text"><span class="mord">,</span></span></span></span></span></span></p>
<p>where uniqueness and commutativity follows from the triangle identities <span class="Agda"><a href="Cat.Functor.Adjoint.html#2684" class="Field">zig</a></span> and <span class="Agda"><a href="Cat.Functor.Adjoint.html#2747" class="Field">zag</a></span>.</p>
<pre class="Agda">  <a id="5050" href="Cat.Functor.Kan.html#4548" data-type="(adj : F ⊣ G) → Lan F Id" class="Function">adjoint→lan</a> <a id="5062" class="Symbol">.</a><a id="5063" href="Cat.Functor.Kan.html#3692" data-type="(r : Lan p F) → F =&gt; M F∘ p → r .Ext =&gt; M" class="Field">σ</a> <a id="5065" class="Symbol">{</a><a id="5066" href="Cat.Functor.Kan.html#5066" class="Bound">M</a><a id="5067" class="Symbol">}</a> <a id="5069" href="Cat.Functor.Kan.html#5069" class="Bound">α</a> <a id="5071" class="Symbol">.</a><a id="5072" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="5074" href="Cat.Functor.Kan.html#5074" class="Bound">x</a> <a id="5076" class="Symbol">=</a> <a id="5078" href="Cat.Functor.Kan.html#5066" class="Bound">M</a> <a id="5080" class="Symbol">.</a><a id="5081" href="Cat.Base.html#8017" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">Functor.F₁</a> <a id="5092" class="Symbol">(</a><a id="5093" href="Cat.Functor.Adjoint.html#2207" class="Function">counit.ε</a> <a id="5102" class="Symbol">_)</a> <a id="5105" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5109" href="Cat.Functor.Kan.html#5069" class="Bound">α</a> <a id="5111" class="Symbol">.</a><a id="5112" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="5114" class="Symbol">(</a><a id="5115" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">G.₀</a> <a id="5119" href="Cat.Functor.Kan.html#5074" class="Bound">x</a><a id="5120" class="Symbol">)</a>
  <a id="5124" href="Cat.Functor.Kan.html#4548" data-type="(adj : F ⊣ G) → Lan F Id" class="Function">adjoint→lan</a> <a id="5136" class="Symbol">.</a><a id="5137" href="Cat.Functor.Kan.html#3692" data-type="(r : Lan p F) → F =&gt; M F∘ p → r .Ext =&gt; M" class="Field">σ</a> <a id="5139" class="Symbol">{</a><a id="5140" href="Cat.Functor.Kan.html#5140" class="Bound">M</a><a id="5141" class="Symbol">}</a> <a id="5143" href="Cat.Functor.Kan.html#5143" class="Bound">nt</a> <a id="5146" class="Symbol">.</a><a id="5147" href="Cat.Base.html#13369" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="5158" href="Cat.Functor.Kan.html#5158" class="Bound">x</a> <a id="5160" href="Cat.Functor.Kan.html#5160" class="Bound">y</a> <a id="5162" href="Cat.Functor.Kan.html#5162" class="Bound">f</a> <a id="5164" class="Symbol">=</a>
    <a id="5170" class="Symbol">(</a><a id="5171" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="5175" class="Symbol">(</a><a id="5176" href="Cat.Functor.Adjoint.html#2207" class="Function">counit.ε</a> <a id="5185" class="Symbol">_)</a> <a id="5188" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5192" href="Cat.Functor.Kan.html#5143" class="Bound">nt</a> <a id="5195" class="Symbol">.</a><a id="5196" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="5198" class="Symbol">_)</a> <a id="5201" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5205" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">G.₁</a> <a id="5209" href="Cat.Functor.Kan.html#5162" class="Bound">f</a>            <span class="reasoning-step"><span class="as-written Function"><a id="5222" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5225" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">C.pullr</a> <a id="5233" class="Symbol">(</a><a id="5234" href="Cat.Functor.Kan.html#5143" class="Bound">nt</a> <a id="5237" class="Symbol">.</a><a id="5238" href="Cat.Base.html#13369" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="5249" class="Symbol">_</a> <a id="5251" class="Symbol">_</a> <a id="5253" class="Symbol">_)</a> <a id="5256" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="5262" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="5266" class="Symbol">(</a><a id="5267" href="Cat.Functor.Adjoint.html#2207" class="Function">counit.ε</a> <a id="5276" class="Symbol">_)</a> <a id="5279" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5283" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="5287" class="Symbol">(</a><a id="5288" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">F.₁</a> <a id="5292" class="Symbol">(</a><a id="5293" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">G.₁</a> <a id="5297" href="Cat.Functor.Kan.html#5162" class="Bound">f</a><a id="5298" class="Symbol">))</a> <a id="5301" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5305" href="Cat.Functor.Kan.html#5143" class="Bound">nt</a> <a id="5308" class="Symbol">.</a><a id="5309" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="5311" class="Symbol">_</a>  <span class="reasoning-step"><span class="as-written Function"><a id="5314" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5317" href="Cat.Functor.Reasoning.html#1799" data-type="(F : Functor 𝒞 𝒟) (p : (F ∘ a) c ≡ (F ∘ b) d) →
(F ∘ F₁ F a) ((F ∘ F₁ F c) f) ≡ (F ∘ F₁ F b) ((F ∘ F₁ F d) f)" class="Function">M.extendl</a> <a id="5327" class="Symbol">(</a><a id="5328" href="Cat.Base.html#13369" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Function">counit.is-natural</a> <a id="5346" class="Symbol">_</a> <a id="5348" class="Symbol">_</a> <a id="5350" class="Symbol">_)</a> <a id="5353" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="5359" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="5363" href="Cat.Functor.Kan.html#5162" class="Bound">f</a> <a id="5365" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5369" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="5373" class="Symbol">(</a><a id="5374" href="Cat.Functor.Adjoint.html#2207" class="Function">counit.ε</a> <a id="5383" class="Symbol">_)</a> <a id="5386" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5390" href="Cat.Functor.Kan.html#5143" class="Bound">nt</a> <a id="5393" class="Symbol">.</a><a id="5394" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="5396" class="Symbol">_</a>              <a id="5411" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
    <a id="5417" class="Keyword">where</a> <a id="5423" class="Keyword">module</a> <a id="5430" href="Cat.Functor.Kan.html#5430" class="Module">M</a> <a id="5432" class="Symbol">=</a> <a id="5434" href="Cat.Functor.Reasoning.html" class="Module">Func</a> <a id="5439" href="Cat.Functor.Kan.html#5140" class="Bound">M</a>

  <a id="5444" href="Cat.Functor.Kan.html#4548" data-type="(adj : F ⊣ G) → Lan F Id" class="Function">adjoint→lan</a> <a id="5456" class="Symbol">.</a><a id="5457" href="Cat.Functor.Kan.html#3748" data-type="(r : Lan p F) → (whiskerl (r .σ α) ∘nt r .eta) ≡ α" class="Field">σ-comm</a> <a id="5464" class="Symbol">{</a><a id="5465" href="Cat.Functor.Kan.html#5465" class="Bound">M</a><a id="5466" class="Symbol">}</a> <a id="5468" class="Symbol">{</a><a id="5469" href="Cat.Functor.Kan.html#5469" class="Bound">α</a><a id="5470" class="Symbol">}</a> <a id="5472" class="Symbol">=</a> <a id="5474" href="Cat.Base.html#15597" data-type="((x : C .Ob) → a .η x ≡ b .η x) → a ≡ b" class="Function">Nat-path</a> <a id="5483" class="Symbol">λ</a> <a id="5485" href="Cat.Functor.Kan.html#5485" class="Bound">_</a> <a id="5487" class="Symbol">→</a>
    <a id="5493" class="Symbol">(</a><a id="5494" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="5498" class="Symbol">(</a><a id="5499" href="Cat.Functor.Adjoint.html#2207" class="Function">counit.ε</a> <a id="5508" class="Symbol">_)</a> <a id="5511" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5515" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">α.η</a> <a id="5519" class="Symbol">_)</a> <a id="5522" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5526" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">unit.η</a> <a id="5533" class="Symbol">_</a>              <span class="reasoning-step"><span class="as-written Function"><a id="5548" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5551" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">C.pullr</a> <a id="5559" class="Symbol">(</a><a id="5560" href="Cat.Base.html#13369" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">α.is-natural</a> <a id="5573" class="Symbol">_</a> <a id="5575" class="Symbol">_</a> <a id="5577" class="Symbol">_)</a> <a id="5580" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="5586" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="5590" class="Symbol">(</a><a id="5591" href="Cat.Functor.Adjoint.html#2207" class="Function">counit.ε</a> <a id="5600" class="Symbol">_)</a> <a id="5603" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5607" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="5611" class="Symbol">(</a><a id="5612" href="Cat.Base.html#8017" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Function">F.F₁</a> <a id="5617" class="Symbol">(</a><a id="5618" href="Cat.Functor.Adjoint.html#2083" data-type="L ⊣ R₁ → Id =&gt; R₁ F∘ L" class="Field">unit</a> <a id="5623" class="Symbol">.</a><a id="5624" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="5626" class="Symbol">_))</a> <a id="5630" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5634" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">α.η</a> <a id="5638" class="Symbol">_</a>  <span class="reasoning-step"><span class="as-written Function"><a id="5641" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5644" href="Cat.Functor.Reasoning.html#2239" data-type="(F : Functor 𝒞 𝒟) (inv₁ : (F ∘ a) b ≡ id F) →
(F ∘ F₁ F a) ((F ∘ F₁ F b) f) ≡ f" class="Function">M.cancell</a> <a id="5654" href="Cat.Functor.Adjoint.html#2684" data-type="(r : L ⊣ R₁) →
D ._∘_ (η (r .counit) (F₀ L A)) (F₁ L (r .unit .η A)) ≡ D .id" class="Field">zig</a> <a id="5658" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="5664" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">α.η</a> <a id="5668" class="Symbol">_</a>                                                  <a id="5719" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
    <a id="5725" class="Keyword">where</a> <a id="5731" class="Keyword">module</a> <a id="5738" href="Cat.Functor.Kan.html#5738" class="Module">α</a> <a id="5740" class="Symbol">=</a> <a id="5742" href="Cat.Base.html#12241" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Module Operator">_=&gt;_</a> <a id="5747" href="Cat.Functor.Kan.html#5469" class="Bound">α</a>
          <a id="5759" class="Keyword">module</a> <a id="5766" href="Cat.Functor.Kan.html#5766" class="Module">M</a> <a id="5768" class="Symbol">=</a> <a id="5770" href="Cat.Functor.Reasoning.html" class="Module">Func</a> <a id="5775" href="Cat.Functor.Kan.html#5465" class="Bound">M</a>

  <a id="5780" href="Cat.Functor.Kan.html#4548" data-type="(adj : F ⊣ G) → Lan F Id" class="Function">adjoint→lan</a> <a id="5792" class="Symbol">.</a><a id="5793" href="Cat.Functor.Kan.html#3827" data-type="(r : Lan p F) → α ≡ (whiskerl σ′ ∘nt r .eta) → r .σ α ≡ σ′" class="Field">σ-uniq</a> <a id="5800" class="Symbol">{</a><a id="5801" href="Cat.Functor.Kan.html#5801" class="Bound">M</a><a id="5802" class="Symbol">}</a> <a id="5804" class="Symbol">{</a><a id="5805" href="Cat.Functor.Kan.html#5805" class="Bound">α</a><a id="5806" class="Symbol">}</a> <a id="5808" class="Symbol">{</a><a id="5809" href="Cat.Functor.Kan.html#5809" class="Bound">σ&#39;</a><a id="5811" class="Symbol">}</a> <a id="5813" href="Cat.Functor.Kan.html#5813" class="Bound">p</a> <a id="5815" class="Symbol">=</a> <a id="5817" href="Cat.Base.html#15597" data-type="((x : C .Ob) → a .η x ≡ b .η x) → a ≡ b" class="Function">Nat-path</a> <a id="5826" class="Symbol">λ</a> <a id="5828" href="Cat.Functor.Kan.html#5828" class="Bound">x</a> <a id="5830" class="Symbol">→</a>
    <a id="5836" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="5840" class="Symbol">(</a><a id="5841" href="Cat.Functor.Adjoint.html#2207" class="Function">counit.ε</a> <a id="5850" class="Symbol">_)</a> <a id="5853" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5857" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">α.η</a> <a id="5861" class="Symbol">_</a>                <span class="reasoning-step"><span class="as-written Function"><a id="5878" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5881" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="5884" class="Symbol">(_</a> <a id="5887" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘_</a><a id="5891" class="Symbol">)</a> <a id="5893" class="Symbol">(</a><a id="5894" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="5897" class="Symbol">(λ</a> <a id="5900" href="Cat.Functor.Kan.html#5900" class="Bound">e</a> <a id="5902" class="Symbol">→</a> <a id="5904" href="Cat.Functor.Kan.html#5900" class="Bound">e</a> <a id="5906" class="Symbol">.</a><a id="5907" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="5909" class="Symbol">_)</a> <a id="5912" href="Cat.Functor.Kan.html#5813" class="Bound">p</a><a id="5913" class="Symbol">)</a> <a id="5915" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="5921" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="5925" class="Symbol">(</a><a id="5926" href="Cat.Functor.Adjoint.html#2207" class="Function">counit.ε</a> <a id="5935" class="Symbol">_)</a> <a id="5938" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5942" href="Cat.Functor.Kan.html#5809" class="Bound">σ&#39;</a> <a id="5945" class="Symbol">.</a><a id="5946" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="5948" class="Symbol">_</a> <a id="5950" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5954" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">unit.η</a> <a id="5961" class="Symbol">_</a> <span class="reasoning-step"><span class="as-written Function"><a id="5963" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5966" href="Cat.Reasoning.html#2007" data-type="(C : Precategory o ℓ) (p : (C ∘ f) h ≡ (C ∘ g) i) →
(C ∘ f) ((C ∘ h) b) ≡ (C ∘ g) ((C ∘ i) b)" class="Function">C.extendl</a> <a id="5976" class="Symbol">(</a><a id="5977" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="5981" class="Symbol">(</a><a id="5982" href="Cat.Functor.Kan.html#5809" class="Bound">σ&#39;</a> <a id="5985" class="Symbol">.</a><a id="5986" href="Cat.Base.html#13369" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="5997" class="Symbol">_</a> <a id="5999" class="Symbol">_</a> <a id="6001" class="Symbol">_))</a> <a id="6005" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="6011" href="Cat.Functor.Kan.html#5809" class="Bound">σ&#39;</a> <a id="6014" class="Symbol">.</a><a id="6015" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="6017" class="Symbol">_</a> <a id="6019" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="6023" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">G.₁</a> <a id="6027" class="Symbol">(</a><a id="6028" href="Cat.Functor.Adjoint.html#2207" class="Function">counit.ε</a> <a id="6037" class="Symbol">_)</a> <a id="6040" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="6044" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">unit.η</a> <a id="6051" class="Symbol">_</a> <span class="reasoning-step"><span class="as-written Function"><a id="6053" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="6056" href="Cat.Reasoning.html#1108" data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" class="Function">C.elimr</a> <a id="6064" href="Cat.Functor.Adjoint.html#2747" data-type="(r : L ⊣ R₁) →
C ._∘_ (F₁ R₁ (η (r .counit) B₁)) (r .unit .η (F₀ R₁ B₁)) ≡ C .id" class="Field">zag</a> <a id="6068" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="6074" href="Cat.Functor.Kan.html#5809" class="Bound">σ&#39;</a> <a id="6077" class="Symbol">.</a><a id="6078" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="6080" href="Cat.Functor.Kan.html#5828" class="Bound">x</a>                                   <a id="6116" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
    <a id="6122" class="Keyword">where</a> <a id="6128" class="Keyword">module</a> <a id="6135" href="Cat.Functor.Kan.html#6135" class="Module">α</a> <a id="6137" class="Symbol">=</a> <a id="6139" href="Cat.Base.html#12241" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Module Operator">_=&gt;_</a> <a id="6144" href="Cat.Functor.Kan.html#5805" class="Bound">α</a>
          <a id="6156" class="Keyword">module</a> <a id="6163" href="Cat.Functor.Kan.html#6163" class="Module">M</a> <a id="6165" class="Symbol">=</a> <a id="6167" href="Cat.Functor.Reasoning.html" class="Module">Func</a> <a id="6172" href="Cat.Functor.Kan.html#5801" class="Bound">M</a>
</pre>
<h1 id="a-formula"><a href="#a-formula" class="header-link">A formula<span class="header-link-emoji">🔗</span></a></h1>
<p>In the cases where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi><mo separator="true">,</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\ca{C}, \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span> are “small enough” and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">E</mi></mrow><annotation encoding="application/x-tex">\ca{E}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.08944em;">E</span></span></span></span> is “cocomplete enough,” the left Kan extension of <em>any</em> functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi mathvariant="script">C</mi><mo>→</mo><mi mathvariant="script">E</mi></mrow><annotation encoding="application/x-tex">F : \ca{C} \to \ca{E}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.08944em;">E</span></span></span></span> along <em>any</em> functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>:</mo><mi mathvariant="script">C</mi><mo>→</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">K : \ca{C} \to \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span> exists, and is computed as a colimit in <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">E</mi></mrow><annotation encoding="application/x-tex">\ca{E}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.08944em;">E</span></span></span></span>.</span> The size concerns here is unavoidable, so let’s be explicit about them: Suppose that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">E</mi></mrow><annotation encoding="application/x-tex">\ca{E}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.08944em;">E</span></span></span></span> admits colimits of [<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">κ</span></span></span></span>-small</span> diagrams], e.g. because it is <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="bold">S</mi><mi mathvariant="bold">e</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">s</mi></mrow><mi>κ</mi></msub></mrow><annotation encoding="application/x-tex">\sets_\kappa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8361em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">Sets</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">κ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span> Then the category <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span> must be <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">κ</span></span></span></span>-small,</span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span> must be locally <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">κ</span></span></span></span>-small,</span> i.e. its Hom-sets must live in the <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">κ</span></span></span></span>th</span> universe.</p>
<!--
<pre class="Agda"><a id="6844" class="Keyword">module</a> <a id="6851" href="Cat.Functor.Kan.html#6851" class="Module">_</a>
  <a id="6855" class="Symbol">{</a><a id="6856" href="Cat.Functor.Kan.html#6856" class="Bound">o</a> <a id="6858" href="Cat.Functor.Kan.html#6858" class="Bound">o′</a> <a id="6861" href="Cat.Functor.Kan.html#6861" class="Bound">ℓ</a> <a id="6863" href="Cat.Functor.Kan.html#6863" class="Bound">κ</a><a id="6864" class="Symbol">}</a> <a id="6866" class="Symbol">{</a><a id="6867" href="Cat.Functor.Kan.html#6867" class="Bound">C</a> <a id="6869" class="Symbol">:</a> <a id="6871" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="6883" href="Cat.Functor.Kan.html#6863" class="Bound">κ</a> <a id="6885" href="Cat.Functor.Kan.html#6863" class="Bound">κ</a><a id="6886" class="Symbol">}</a> <a id="6888" class="Symbol">{</a><a id="6889" href="Cat.Functor.Kan.html#6889" class="Bound">D</a> <a id="6891" class="Symbol">:</a> <a id="6893" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="6905" href="Cat.Functor.Kan.html#6858" class="Bound">o′</a> <a id="6908" href="Cat.Functor.Kan.html#6863" class="Bound">κ</a><a id="6909" class="Symbol">}</a> <a id="6911" class="Symbol">{</a><a id="6912" href="Cat.Functor.Kan.html#6912" class="Bound">E</a> <a id="6914" class="Symbol">:</a> <a id="6916" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="6928" href="Cat.Functor.Kan.html#6856" class="Bound">o</a> <a id="6930" href="Cat.Functor.Kan.html#6861" class="Bound">ℓ</a><a id="6931" class="Symbol">}</a>
  <a id="6935" class="Symbol">(</a><a id="6936" href="Cat.Functor.Kan.html#6936" class="Bound">colim</a> <a id="6942" class="Symbol">:</a> <a id="6944" href="Cat.Diagram.Colimit.Base.html#8150" data-type="(o ℓ : Level) →
Precategory oc ℓc → Type (oc ⊔ ℓc ⊔ lsuc o ⊔ lsuc ℓ)" class="Function">is-cocomplete</a> <a id="6958" href="Cat.Functor.Kan.html#6863" class="Bound">κ</a> <a id="6960" href="Cat.Functor.Kan.html#6863" class="Bound">κ</a> <a id="6962" href="Cat.Functor.Kan.html#6912" class="Bound">E</a><a id="6963" class="Symbol">)</a>
  <a id="6967" class="Symbol">(</a><a id="6968" href="Cat.Functor.Kan.html#6968" class="Bound">F</a> <a id="6970" class="Symbol">:</a> <a id="6972" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="6980" href="Cat.Functor.Kan.html#6867" class="Bound">C</a> <a id="6982" href="Cat.Functor.Kan.html#6912" class="Bound">E</a><a id="6983" class="Symbol">)</a>
  <a id="6987" class="Symbol">(</a><a id="6988" href="Cat.Functor.Kan.html#6988" class="Bound">K</a> <a id="6990" class="Symbol">:</a> <a id="6992" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="7000" href="Cat.Functor.Kan.html#6867" class="Bound">C</a> <a id="7002" href="Cat.Functor.Kan.html#6889" class="Bound">D</a><a id="7003" class="Symbol">)</a>
  <a id="7007" class="Keyword">where</a>
  <a id="7015" class="Keyword">private</a>
    <a id="7027" class="Keyword">module</a> <a id="7034" href="Cat.Functor.Kan.html#7034" class="Module">C</a> <a id="7036" class="Symbol">=</a> <a id="7038" href="Cat.Reasoning.html" class="Module">Cat</a> <a id="7042" href="Cat.Functor.Kan.html#6867" class="Bound">C</a>
    <a id="7048" class="Keyword">module</a> <a id="7055" href="Cat.Functor.Kan.html#7055" class="Module">D</a> <a id="7057" class="Symbol">=</a> <a id="7059" href="Cat.Reasoning.html" class="Module">Cat</a> <a id="7063" href="Cat.Functor.Kan.html#6889" class="Bound">D</a>
    <a id="7069" class="Keyword">module</a> <a id="7076" href="Cat.Functor.Kan.html#7076" class="Module">E</a> <a id="7078" class="Symbol">=</a> <a id="7080" href="Cat.Reasoning.html" class="Module">Cat</a> <a id="7084" href="Cat.Functor.Kan.html#6912" class="Bound">E</a>
    <a id="7090" class="Keyword">module</a> <a id="7097" href="Cat.Functor.Kan.html#7097" class="Module">F</a> <a id="7099" class="Symbol">=</a> <a id="7101" href="Cat.Functor.Reasoning.html" class="Module">Func</a> <a id="7106" href="Cat.Functor.Kan.html#6968" class="Bound">F</a>
    <a id="7112" class="Keyword">module</a> <a id="7119" href="Cat.Functor.Kan.html#7119" class="Module">K</a> <a id="7121" class="Symbol">=</a> <a id="7123" href="Cat.Functor.Reasoning.html" class="Module">Func</a> <a id="7128" href="Cat.Functor.Kan.html#6988" class="Bound">K</a>
    <a id="7134" class="Keyword">open</a> <a id="7139" href="Cat.Diagram.Colimit.Base.html#4086" data-type="(F : Functor J₁ C) (x y : Cocone F) → Type (o ⊔ ℓ′)" class="Module">Cocone-hom</a>
    <a id="7154" class="Keyword">open</a> <a id="7159" href="Cat.Diagram.Initial.html#401" data-type="(C : Precategory o h) → Type (o ⊔ h)" class="Module">Initial</a>
    <a id="7171" class="Keyword">open</a> <a id="7176" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Module">Functor</a>
    <a id="7188" class="Keyword">open</a> <a id="7193" href="Cat.Diagram.Colimit.Base.html#2300" data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Module">Cocone</a>
    <a id="7204" class="Keyword">open</a> <a id="7209" href="Cat.Functor.Kan.html#2838" data-type="(p : Functor C C′) (F : Functor C D) →
Type (C.o ⊔ C.ℓ ⊔ C′.o ⊔ C′.ℓ ⊔ D.o ⊔ D.ℓ)" class="Module">Lan</a>
    <a id="7217" class="Keyword">open</a> <a id="7222" href="Cat.Instances.Comma.html#1730" data-type="(F : Functor A C) (G : Functor B₁ C) → Type (ao ⊔ bo ⊔ h)" class="Module">↓Obj</a>
    <a id="7231" class="Keyword">open</a> <a id="7236" href="Cat.Instances.Comma.html#2452" data-type="(F : Functor A C) (G : Functor B₁ C) (a b : ↓Obj F G) →
Type (ah ⊔ bh ⊔ h)" class="Module">↓Hom</a>
</pre>-->
<p>The size restrictions on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span> ensure that the <a href="Cat.Instances.Comma.html">comma category</a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>↘</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">K \searrow d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↘</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span> is <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">κ</span></span></span></span>-small,</span> so that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">E</mi></mrow><annotation encoding="application/x-tex">\ca{E}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.08944em;">E</span></span></span></span> has a colimit for it. The objects of this category can be considered “approximations of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span> coming from <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>,</span>” so the colimit over this category is a “best approximation of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>!</span>” The rest of the computation is “straightforward” in the way that most category-theoretic computations are: it looks mighty complicated from the outside, but when you’re actually working them out, there’s only one step you can take at each point. Agda’s goal-and-context display guides you the whole way.</p>
<pre class="Agda">  <a id="7923" href="Cat.Functor.Kan.html#7923" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">lan-approximate</a> <a id="7939" class="Symbol">:</a> <a id="7941" class="Symbol">∀</a> <a id="7943" class="Symbol">{</a><a id="7944" href="Cat.Functor.Kan.html#7944" class="Bound">d</a> <a id="7946" href="Cat.Functor.Kan.html#7946" class="Bound">e</a><a id="7947" class="Symbol">}</a> <a id="7949" class="Symbol">(</a><a id="7950" href="Cat.Functor.Kan.html#7950" class="Bound">f</a> <a id="7952" class="Symbol">:</a> <a id="7954" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">D.Hom</a> <a id="7960" href="Cat.Functor.Kan.html#7944" class="Bound">d</a> <a id="7962" href="Cat.Functor.Kan.html#7946" class="Bound">e</a><a id="7963" class="Symbol">)</a> <a id="7965" class="Symbol">→</a> <a id="7967" href="Cat.Diagram.Colimit.Base.html#2300" data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Record">Cocone</a> <a id="7974" class="Symbol">(</a><a id="7975" href="Cat.Functor.Kan.html#6968" class="Bound">F</a> <a id="7977" href="Cat.Base.html#9697" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="7980" href="Cat.Instances.Comma.html#5380" data-type="(F : Functor A C) (G : Functor B₁ C) → Functor (F ↓ G) A" class="Function">Dom</a> <a id="7984" href="Cat.Functor.Kan.html#6988" class="Bound">K</a> <a id="7986" class="Symbol">(</a><a id="7987" href="Cat.Instances.Shape.Terminal.html#558" data-type="Ob A → Functor ⊤Cat A" class="Function">const!</a> <a id="7994" href="Cat.Functor.Kan.html#7944" class="Bound">d</a><a id="7995" class="Symbol">))</a>
  <a id="8000" href="Cat.Functor.Kan.html#7923" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">lan-approximate</a> <a id="8016" class="Symbol">{</a><a id="8017" class="Argument">e</a> <a id="8019" class="Symbol">=</a> <a id="8021" href="Cat.Functor.Kan.html#8021" class="Bound">e</a><a id="8022" class="Symbol">}</a> <a id="8024" href="Cat.Functor.Kan.html#8024" class="Bound">f</a> <a id="8026" class="Symbol">.</a><a id="8027" href="Cat.Diagram.Colimit.Base.html#2661" data-type="Cocone F → C .Ob" class="Field">coapex</a> <a id="8034" class="Symbol">=</a> <a id="8036" href="Cat.Functor.Kan.html#6936" class="Bound">colim</a> <a id="8042" class="Symbol">(</a><a id="8043" href="Cat.Functor.Kan.html#6968" class="Bound">F</a> <a id="8045" href="Cat.Base.html#9697" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="8048" href="Cat.Instances.Comma.html#5380" data-type="(F : Functor A C) (G : Functor B₁ C) → Functor (F ↓ G) A" class="Function">Dom</a> <a id="8052" href="Cat.Functor.Kan.html#6988" class="Bound">K</a> <a id="8054" class="Symbol">(</a><a id="8055" href="Cat.Instances.Shape.Terminal.html#558" data-type="Ob A → Functor ⊤Cat A" class="Function">const!</a> <a id="8062" href="Cat.Functor.Kan.html#8021" class="Bound">e</a><a id="8063" class="Symbol">))</a> <a id="8066" class="Symbol">.</a><a id="8067" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="8071" class="Symbol">.</a><a id="8072" href="Cat.Diagram.Colimit.Base.html#2661" data-type="Cocone F → C .Ob" class="Field">coapex</a>
  <a id="8081" href="Cat.Functor.Kan.html#7923" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">lan-approximate</a> <a id="8097" class="Symbol">{</a><a id="8098" class="Argument">e</a> <a id="8100" class="Symbol">=</a> <a id="8102" href="Cat.Functor.Kan.html#8102" class="Bound">e</a><a id="8103" class="Symbol">}</a> <a id="8105" href="Cat.Functor.Kan.html#8105" class="Bound">f</a> <a id="8107" class="Symbol">.</a><a id="8108" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a> <a id="8110" href="Cat.Functor.Kan.html#8110" class="Bound">x</a> <a id="8112" class="Symbol">=</a>
    <a id="8118" href="Cat.Functor.Kan.html#6936" class="Bound">colim</a> <a id="8124" class="Symbol">(</a><a id="8125" href="Cat.Functor.Kan.html#6968" class="Bound">F</a> <a id="8127" href="Cat.Base.html#9697" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="8130" href="Cat.Instances.Comma.html#5380" data-type="(F : Functor A C) (G : Functor B₁ C) → Functor (F ↓ G) A" class="Function">Dom</a> <a id="8134" href="Cat.Functor.Kan.html#6988" class="Bound">K</a> <a id="8136" class="Symbol">(</a><a id="8137" href="Cat.Instances.Shape.Terminal.html#558" data-type="Ob A → Functor ⊤Cat A" class="Function">const!</a> <a id="8144" href="Cat.Functor.Kan.html#8102" class="Bound">e</a><a id="8145" class="Symbol">))</a> <a id="8148" class="Symbol">.</a><a id="8149" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="8153" class="Symbol">.</a><a id="8154" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a> <a id="8156" class="Symbol">(</a><a id="8157" class="Keyword">record</a> <a id="8164" class="Symbol">{</a> <a id="8166" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a> <a id="8170" class="Symbol">=</a> <a id="8172" href="Cat.Functor.Kan.html#8105" class="Bound">f</a> <a id="8174" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8178" href="Cat.Functor.Kan.html#8110" class="Bound">x</a> <a id="8180" class="Symbol">.</a><a id="8181" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a> <a id="8185" class="Symbol">})</a>
  <a id="8190" href="Cat.Functor.Kan.html#7923" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">lan-approximate</a> <a id="8206" class="Symbol">{</a><a id="8207" class="Argument">e</a> <a id="8209" class="Symbol">=</a> <a id="8211" href="Cat.Functor.Kan.html#8211" class="Bound">e</a><a id="8212" class="Symbol">}</a> <a id="8214" href="Cat.Functor.Kan.html#8214" class="Bound">f</a> <a id="8216" class="Symbol">.</a><a id="8217" href="Cat.Diagram.Colimit.Base.html#3115" data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" class="Field">commutes</a> <a id="8226" class="Symbol">{</a><a id="8227" href="Cat.Functor.Kan.html#8227" class="Bound">x</a><a id="8228" class="Symbol">}</a> <a id="8230" class="Symbol">{</a><a id="8231" href="Cat.Functor.Kan.html#8231" class="Bound">y</a><a id="8232" class="Symbol">}</a> <a id="8234" href="Cat.Functor.Kan.html#8234" class="Bound">h</a> <a id="8236" class="Symbol">=</a>
    <a id="8242" href="Cat.Functor.Kan.html#6936" class="Bound">colim</a> <a id="8248" class="Symbol">(</a><a id="8249" href="Cat.Functor.Kan.html#6968" class="Bound">F</a> <a id="8251" href="Cat.Base.html#9697" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="8254" href="Cat.Instances.Comma.html#5380" data-type="(F : Functor A C) (G : Functor B₁ C) → Functor (F ↓ G) A" class="Function">Dom</a> <a id="8258" href="Cat.Functor.Kan.html#6988" class="Bound">K</a> <a id="8260" class="Symbol">(</a><a id="8261" href="Cat.Instances.Shape.Terminal.html#558" data-type="Ob A → Functor ⊤Cat A" class="Function">const!</a> <a id="8268" href="Cat.Functor.Kan.html#8211" class="Bound">e</a><a id="8269" class="Symbol">))</a> <a id="8272" class="Symbol">.</a><a id="8273" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="8277" class="Symbol">.</a><a id="8278" href="Cat.Diagram.Colimit.Base.html#3115" data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" class="Field">commutes</a> <a id="8287" class="Symbol">(</a><a id="8288" class="Keyword">record</a> <a id="8295" class="Symbol">{</a> <a id="8297" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">sq</a> <a id="8300" class="Symbol">=</a> <a id="8302" href="Cat.Functor.Kan.html#8335" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(f : D .Hom d e) (h : (K ↓ const! d) .Hom x y) →
D ._∘_ (D ._∘_ f (y .map)) (₁ K (h .α)) ≡
D ._∘_ (D .id) (D ._∘_ f (x .map))" class="Function">path</a> <a id="8307" class="Symbol">})</a>
    <a id="8314" class="Keyword">where</a> <a id="8320" class="Keyword">abstract</a>
      <a id="8335" href="Cat.Functor.Kan.html#8335" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(f : D .Hom d e) (h : (K ↓ const! d) .Hom x y) →
D ._∘_ (D ._∘_ f (y .map)) (₁ K (h .α)) ≡
D ._∘_ (D .id) (D ._∘_ f (x .map))" class="Function">path</a> <a id="8340" class="Symbol">:</a> <a id="8342" class="Symbol">(</a><a id="8343" href="Cat.Functor.Kan.html#8214" class="Bound">f</a> <a id="8345" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8349" href="Cat.Functor.Kan.html#8231" class="Bound">y</a> <a id="8351" class="Symbol">.</a><a id="8352" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a><a id="8355" class="Symbol">)</a> <a id="8357" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8361" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">K.₁</a> <a id="8365" class="Symbol">(</a><a id="8366" href="Cat.Functor.Kan.html#8234" class="Bound">h</a> <a id="8368" class="Symbol">.</a><a id="8369" href="Cat.Instances.Comma.html#2595" data-type="↓Hom F G a b → Hom A (a .x) (x b)" class="Field">α</a><a id="8370" class="Symbol">)</a> <a id="8372" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="8374" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a> <a id="8379" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8383" class="Symbol">(</a><a id="8384" href="Cat.Functor.Kan.html#8214" class="Bound">f</a> <a id="8386" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8390" href="Cat.Functor.Kan.html#8227" class="Bound">x</a> <a id="8392" class="Symbol">.</a><a id="8393" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a><a id="8396" class="Symbol">)</a>
      <a id="8404" href="Cat.Functor.Kan.html#8335" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(f : D .Hom d e) (h : (K ↓ const! d) .Hom x y) →
D ._∘_ (D ._∘_ f (y .map)) (₁ K (h .α)) ≡
D ._∘_ (D .id) (D ._∘_ f (x .map))" class="Function">path</a> <a id="8409" class="Symbol">=</a>
        <a id="8419" class="Symbol">(</a><a id="8420" href="Cat.Functor.Kan.html#8214" class="Bound">f</a> <a id="8422" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8426" href="Cat.Functor.Kan.html#8231" class="Bound">y</a> <a id="8428" class="Symbol">.</a><a id="8429" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a><a id="8432" class="Symbol">)</a> <a id="8434" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8438" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">K.₁</a> <a id="8442" class="Symbol">(</a><a id="8443" href="Cat.Functor.Kan.html#8234" class="Bound">h</a> <a id="8445" class="Symbol">.</a><a id="8446" href="Cat.Instances.Comma.html#2595" data-type="↓Hom F G a b → Hom A (a .x) (x b)" class="Field">α</a><a id="8447" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a id="8449" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8452" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">D.pullr</a> <a id="8460" class="Symbol">(</a><a id="8461" href="Cat.Functor.Kan.html#8234" class="Bound">h</a> <a id="8463" class="Symbol">.</a><a id="8464" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">sq</a><a id="8466" class="Symbol">)</a> <a id="8468" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a id="8478" href="Cat.Functor.Kan.html#8214" class="Bound">f</a> <a id="8480" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8484" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a> <a id="8489" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8493" href="Cat.Functor.Kan.html#8227" class="Bound">x</a> <a id="8495" class="Symbol">.</a><a id="8496" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a>         <span class="reasoning-step"><span class="as-written Function"><a id="8508" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8511" href="Cat.Solver.html#7426" data-type="Term → Term → TC ⊤" class="Macro">solve</a> <a id="8517" href="Cat.Functor.Kan.html#6889" class="Bound">D</a> <a id="8519" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a id="8529" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a> <a id="8534" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8538" class="Symbol">(</a><a id="8539" href="Cat.Functor.Kan.html#8214" class="Bound">f</a> <a id="8541" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8545" href="Cat.Functor.Kan.html#8227" class="Bound">x</a> <a id="8547" class="Symbol">.</a><a id="8548" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a><a id="8551" class="Symbol">)</a>       <a id="8559" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

  <a id="8564" href="Cat.Functor.Kan.html#8564" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">cocomplete→lan</a> <a id="8579" class="Symbol">:</a> <a id="8581" href="Cat.Functor.Kan.html#2838" data-type="(p : Functor C C′) (F : Functor C D) →
Type (C.o ⊔ C.ℓ ⊔ C′.o ⊔ C′.ℓ ⊔ D.o ⊔ D.ℓ)" class="Record">Lan</a> <a id="8585" href="Cat.Functor.Kan.html#6988" class="Bound">K</a> <a id="8587" href="Cat.Functor.Kan.html#6968" class="Bound">F</a>
  <a id="8591" href="Cat.Functor.Kan.html#8564" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">cocomplete→lan</a> <a id="8606" class="Symbol">=</a> <a id="8608" href="Cat.Functor.Kan.html#11133" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">lan</a> <a id="8612" class="Keyword">where</a>
    <a id="8622" href="Cat.Functor.Kan.html#8622" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="8630" class="Symbol">:</a> <a id="8632" class="Symbol">∀</a> <a id="8634" href="Cat.Functor.Kan.html#8634" class="Bound">d</a> <a id="8636" class="Symbol">→</a> <a id="8638" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="8646" class="Symbol">(</a><a id="8647" href="Cat.Functor.Kan.html#6988" class="Bound">K</a> <a id="8649" href="Cat.Instances.Comma.html#5869" data-type="Functor B₁ A →
A .Ob → Precategory (ah ⊔ bo ⊔ lzero) (ah ⊔ bh ⊔ lzero)" class="Function Operator">↘</a> <a id="8651" href="Cat.Functor.Kan.html#8634" class="Bound">d</a><a id="8652" class="Symbol">)</a> <a id="8654" href="Cat.Functor.Kan.html#6912" class="Bound">E</a>
    <a id="8660" href="Cat.Functor.Kan.html#8622" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="8668" href="Cat.Functor.Kan.html#8668" class="Bound">d</a> <a id="8670" class="Symbol">=</a> <a id="8672" href="Cat.Functor.Kan.html#6968" class="Bound">F</a> <a id="8674" href="Cat.Base.html#9697" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="8677" href="Cat.Instances.Comma.html#5380" data-type="(F : Functor A C) (G : Functor B₁ C) → Functor (F ↓ G) A" class="Function">Dom</a> <a id="8681" href="Cat.Functor.Kan.html#6988" class="Bound">K</a> <a id="8683" class="Symbol">(</a><a id="8684" href="Cat.Instances.Shape.Terminal.html#558" data-type="Ob A → Functor ⊤Cat A" class="Function">const!</a> <a id="8691" href="Cat.Functor.Kan.html#8668" class="Bound">d</a><a id="8692" class="Symbol">)</a>

    <a id="8699" href="Cat.Functor.Kan.html#8699" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">approx</a> <a id="8706" class="Symbol">=</a> <a id="8708" href="Cat.Functor.Kan.html#7923" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">lan-approximate</a>
</pre>
<p>Our extension will associate to each object <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span> the colimit of</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>K</mi><mo>↘</mo><mi>d</mi><mo stretchy="false">)</mo><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mrow><mi mathvariant="normal">D</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow></mpadded></mover><mi>C</mi><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mi>F</mi></mpadded></mover><mi>E</mi><mtext>,</mtext></mrow><annotation encoding="application/x-tex">
(K \searrow d) \xto{\id{Dom}} C \xto{F} E\text{,}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↘</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3503em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1003em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">Dom</span></span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1113em;vertical-align:-0.011em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1003em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord text"><span class="mord">,</span></span></span></span></span></span></p>
<p>where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">D</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow><annotation encoding="application/x-tex">\id{Dom}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">Dom</span></span></span></span></span> is the functor which projects out the <em>dom</em>ain of each object of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>↘</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">K \searrow d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↘</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>.</span> Now, we must also associate <em>arrows</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>d</mi><mo>→</mo><mi>e</mi><mo>∈</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">f : d \to e \in \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span> to arrows between the respective colimits of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span> and <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span>.</span> What we note is that any arrow <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>d</mi><mo>→</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">f : d \to e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> displays (the colimit associated with) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> as a cocone under <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>,</span> as can be seen in the computation of <span class="Agda"><a href="Cat.Functor.Kan.html#8699" class="Function">approx</a></span> above.</p>
<p>Our functor can then take an arrow <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>d</mi><mo>→</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">f : d \to e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> to the uniqueness arrow from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">colim</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo><mo>→</mo><mi mathvariant="normal">colim</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\colim(d) \to \colim(e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">colim</span></span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">colim</span></span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span> (punning <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> for their respective diagrams), which exists because <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">colim</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\colim(d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">colim</span></span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span> is initial. Uniqueness of this arrow ensures that this assignment is functorial — but as the functoriality proof is (to use a technical term) goddamn nasty, we leave it hidden from the page.</p>
<pre class="Agda">    <a id="9636" href="Cat.Functor.Kan.html#9636" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Functor D E" class="Function">func</a> <a id="9641" class="Symbol">:</a> <a id="9643" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="9651" href="Cat.Functor.Kan.html#6889" class="Bound">D</a> <a id="9653" href="Cat.Functor.Kan.html#6912" class="Bound">E</a>
    <a id="9659" href="Cat.Functor.Kan.html#9636" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Functor D E" class="Function">func</a> <a id="9664" class="Symbol">.</a><a id="9665" href="Cat.Base.html#7996" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="9668" href="Cat.Functor.Kan.html#9668" class="Bound">d</a> <a id="9670" class="Symbol">=</a> <a id="9672" href="Cat.Functor.Kan.html#6936" class="Bound">colim</a> <a id="9678" class="Symbol">(</a><a id="9679" href="Cat.Functor.Kan.html#8622" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="9687" href="Cat.Functor.Kan.html#9668" class="Bound">d</a><a id="9688" class="Symbol">)</a> <a id="9690" class="Symbol">.</a><a id="9691" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="9695" class="Symbol">.</a><a id="9696" href="Cat.Diagram.Colimit.Base.html#2661" data-type="Cocone F → C .Ob" class="Field">coapex</a>
    <a id="9707" href="Cat.Functor.Kan.html#9636" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Functor D E" class="Function">func</a> <a id="9712" class="Symbol">.</a><a id="9713" href="Cat.Base.html#8017" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="9716" class="Symbol">{</a><a id="9717" href="Cat.Functor.Kan.html#9717" class="Bound">d</a><a id="9718" class="Symbol">}</a> <a id="9720" class="Symbol">{</a><a id="9721" href="Cat.Functor.Kan.html#9721" class="Bound">e</a><a id="9722" class="Symbol">}</a> <a id="9724" href="Cat.Functor.Kan.html#9724" class="Bound">f</a> <a id="9726" class="Symbol">=</a> <a id="9728" href="Cat.Functor.Kan.html#6936" class="Bound">colim</a> <a id="9734" class="Symbol">(</a><a id="9735" href="Cat.Functor.Kan.html#8622" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="9743" href="Cat.Functor.Kan.html#9717" class="Bound">d</a><a id="9744" class="Symbol">)</a> <a id="9746" class="Symbol">.</a><a id="9747" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="9752" class="Symbol">(</a><a id="9753" href="Cat.Functor.Kan.html#8699" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">approx</a> <a id="9760" href="Cat.Functor.Kan.html#9724" class="Bound">f</a><a id="9761" class="Symbol">)</a> <a id="9763" class="Symbol">.</a><a id="9764" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="9771" class="Symbol">.</a><a id="9772" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a>
</pre>
<!--
<pre class="Agda">    <a id="9798" href="Cat.Functor.Kan.html#9636" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Functor D E" class="Function">func</a> <a id="9803" class="Symbol">.</a><a id="9804" href="Cat.Base.html#8343" data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" class="Field">F-id</a> <a id="9809" class="Symbol">{</a><a id="9810" href="Cat.Functor.Kan.html#9810" class="Bound">d</a><a id="9811" class="Symbol">}</a> <a id="9813" class="Symbol">=</a> <a id="9815" href="Cat.Functor.Kan.html#9841" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
func colim F K .F₁ (D .id) ≡ E .id" class="Function">path</a> <a id="9820" class="Keyword">where</a> <a id="9826" class="Keyword">abstract</a>
      <a id="9841" href="Cat.Functor.Kan.html#9841" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
func colim F K .F₁ (D .id) ≡ E .id" class="Function">path</a> <a id="9846" class="Symbol">:</a> <a id="9848" href="Cat.Functor.Kan.html#9636" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Functor D E" class="Function">func</a> <a id="9853" class="Symbol">.</a><a id="9854" href="Cat.Base.html#8017" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="9857" class="Symbol">(</a><a id="9858" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a> <a id="9863" class="Symbol">{</a><a id="9864" class="Argument">x</a> <a id="9866" class="Symbol">=</a> <a id="9868" href="Cat.Functor.Kan.html#9810" class="Bound">d</a><a id="9869" class="Symbol">})</a> <a id="9872" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="9874" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">E.id</a>
      <a id="9885" href="Cat.Functor.Kan.html#9841" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
func colim F K .F₁ (D .id) ≡ E .id" class="Function">path</a> <a id="9890" class="Symbol">=</a> <a id="9892" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="9895" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a> <a id="9899" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="9901" href="Cat.Functor.Kan.html#6936" class="Bound">colim</a> <a id="9907" class="Symbol">(</a><a id="9908" href="Cat.Functor.Kan.html#8622" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="9916" href="Cat.Functor.Kan.html#9810" class="Bound">d</a><a id="9917" class="Symbol">)</a> <a id="9919" class="Symbol">.</a><a id="9920" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="9925" class="Symbol">(</a><a id="9926" href="Cat.Functor.Kan.html#8699" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">approx</a> <a id="9933" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a><a id="9937" class="Symbol">)</a> <a id="9939" class="Symbol">.</a><a id="9940" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a>
        <a id="9954" class="Symbol">(</a><a id="9955" href="Cat.Diagram.Colimit.Base.html#4170" data-type="(hom : C .Hom (x .coapex) (y .coapex))
(commutes : (o : J₁ .Ob) → C ._∘_ hom (x .ψ o) ≡ y .ψ o) →
Cocone-hom F x y" class="InductiveConstructor">cocone-hom</a> <a id="9966" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">E.id</a> <a id="9971" class="Symbol">(λ</a> <a id="9974" href="Cat.Functor.Kan.html#9974" class="Bound">o</a> <a id="9976" class="Symbol">→</a> <a id="9978" href="Cat.Base.html#3482" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" class="Function">E.idl</a> <a id="9984" class="Symbol">_</a>
                         <a id="10011" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="10013" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="10016" class="Symbol">(</a><a id="10017" href="Cat.Functor.Kan.html#6936" class="Bound">colim</a> <a id="10023" class="Symbol">(</a><a id="10024" href="Cat.Functor.Kan.html#8622" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="10032" href="Cat.Functor.Kan.html#9810" class="Bound">d</a><a id="10033" class="Symbol">)</a> <a id="10035" class="Symbol">.</a><a id="10036" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="10040" class="Symbol">.</a><a id="10041" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a><a id="10042" class="Symbol">)</a>
                              <a id="10074" class="Symbol">(</a><a id="10075" href="Cat.Instances.Comma.html#3533" data-type="(F : Functor A C) (G : Functor B₁ C) (p : a .x ≡ b .x)
(q : a .y ≡ b .y) →
PathP (λ i → Hom C (F₀ F (p i)) (F₀ G (q i))) (a .map) (b .map) →
a ≡ b" class="Function">↓Obj-path</a> <a id="10085" class="Symbol">_</a> <a id="10087" class="Symbol">_</a> <a id="10089" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="10094" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="10099" class="Symbol">(</a><a id="10100" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="10104" class="Symbol">(</a><a id="10105" href="Cat.Base.html#3482" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" class="Function">D.idl</a> <a id="10111" class="Symbol">_)))))</a>
    <a id="10122" href="Cat.Functor.Kan.html#9636" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Functor D E" class="Function">func</a> <a id="10127" class="Symbol">.</a><a id="10128" href="Cat.Base.html#8383" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Field">F-∘</a> <a id="10132" class="Symbol">{</a><a id="10133" href="Cat.Functor.Kan.html#10133" class="Bound">d</a><a id="10134" class="Symbol">}</a> <a id="10136" class="Symbol">{</a><a id="10137" href="Cat.Functor.Kan.html#10137" class="Bound">e</a><a id="10138" class="Symbol">}</a> <a id="10140" class="Symbol">{</a><a id="10141" href="Cat.Functor.Kan.html#10141" class="Bound">f</a><a id="10142" class="Symbol">}</a> <a id="10144" href="Cat.Functor.Kan.html#10144" class="Bound">g</a> <a id="10146" href="Cat.Functor.Kan.html#10146" class="Bound">h</a> <a id="10148" class="Symbol">=</a> <a id="10150" href="Cat.Functor.Kan.html#10176" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(g : D .Hom e f) (h : D .Hom d e) →
func colim F K .F₁ (D ._∘_ g h) ≡
E ._∘_ (func colim F K .F₁ g) (func colim F K .F₁ h)" class="Function">path</a> <a id="10155" class="Keyword">where</a> <a id="10161" class="Keyword">abstract</a>
      <a id="10176" href="Cat.Functor.Kan.html#10176" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(g : D .Hom e f) (h : D .Hom d e) →
func colim F K .F₁ (D ._∘_ g h) ≡
E ._∘_ (func colim F K .F₁ g) (func colim F K .F₁ h)" class="Function">path</a> <a id="10181" class="Symbol">:</a> <a id="10183" href="Cat.Functor.Kan.html#9636" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Functor D E" class="Function">func</a> <a id="10188" class="Symbol">.</a><a id="10189" href="Cat.Base.html#8017" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="10192" class="Symbol">(</a><a id="10193" href="Cat.Functor.Kan.html#10144" class="Bound">g</a> <a id="10195" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="10199" href="Cat.Functor.Kan.html#10146" class="Bound">h</a><a id="10200" class="Symbol">)</a> <a id="10202" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="10204" href="Cat.Functor.Kan.html#9636" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Functor D E" class="Function">func</a> <a id="10209" class="Symbol">.</a><a id="10210" href="Cat.Base.html#8017" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="10213" href="Cat.Functor.Kan.html#10144" class="Bound">g</a> <a id="10215" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">E.∘</a> <a id="10219" href="Cat.Functor.Kan.html#9636" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Functor D E" class="Function">func</a> <a id="10224" class="Symbol">.</a><a id="10225" href="Cat.Base.html#8017" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="10228" href="Cat.Functor.Kan.html#10146" class="Bound">h</a>
      <a id="10236" href="Cat.Functor.Kan.html#10176" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(g : D .Hom e f) (h : D .Hom d e) →
func colim F K .F₁ (D ._∘_ g h) ≡
E ._∘_ (func colim F K .F₁ g) (func colim F K .F₁ h)" class="Function">path</a> <a id="10241" class="Symbol">=</a> <a id="10243" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="10246" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a> <a id="10250" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="10252" href="Cat.Functor.Kan.html#6936" class="Bound">colim</a> <a id="10258" class="Symbol">(</a><a id="10259" href="Cat.Functor.Kan.html#8622" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="10267" href="Cat.Functor.Kan.html#10133" class="Bound">d</a><a id="10268" class="Symbol">)</a> <a id="10270" class="Symbol">.</a><a id="10271" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="10276" class="Symbol">(</a><a id="10277" href="Cat.Functor.Kan.html#8699" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">approx</a> <a id="10284" class="Symbol">_)</a> <a id="10287" class="Symbol">.</a><a id="10288" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a>
        <a id="10302" class="Symbol">(</a><a id="10303" href="Cat.Diagram.Colimit.Base.html#4170" data-type="(hom : C .Hom (x .coapex) (y .coapex))
(commutes : (o : J₁ .Ob) → C ._∘_ hom (x .ψ o) ≡ y .ψ o) →
Cocone-hom F x y" class="InductiveConstructor">cocone-hom</a> <a id="10314" class="Symbol">_</a> <a id="10316" class="Symbol">λ</a> <a id="10318" href="Cat.Functor.Kan.html#10318" class="Bound">o</a> <a id="10320" class="Symbol">→</a>
            <a id="10334" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">E.pullr</a> <a id="10342" class="Symbol">(</a><a id="10343" href="Cat.Functor.Kan.html#6936" class="Bound">colim</a> <a id="10349" class="Symbol">(</a><a id="10350" href="Cat.Functor.Kan.html#8622" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="10358" href="Cat.Functor.Kan.html#10133" class="Bound">d</a><a id="10359" class="Symbol">)</a> <a id="10361" class="Symbol">.</a><a id="10362" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="10367" class="Symbol">(</a><a id="10368" href="Cat.Functor.Kan.html#8699" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">approx</a> <a id="10375" href="Cat.Functor.Kan.html#10146" class="Bound">h</a><a id="10376" class="Symbol">)</a> <a id="10378" class="Symbol">.</a><a id="10379" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="10386" class="Symbol">.</a><a id="10387" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="10396" class="Symbol">_)</a>
          <a id="10409" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="10411" href="Cat.Functor.Kan.html#6936" class="Bound">colim</a> <a id="10417" class="Symbol">(</a><a id="10418" href="Cat.Functor.Kan.html#8622" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="10426" href="Cat.Functor.Kan.html#10137" class="Bound">e</a><a id="10427" class="Symbol">)</a> <a id="10429" class="Symbol">.</a><a id="10430" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="10435" class="Symbol">(</a><a id="10436" href="Cat.Functor.Kan.html#8699" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">approx</a> <a id="10443" href="Cat.Functor.Kan.html#10144" class="Bound">g</a><a id="10444" class="Symbol">)</a> <a id="10446" class="Symbol">.</a><a id="10447" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="10454" class="Symbol">.</a><a id="10455" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="10464" class="Symbol">_</a>
          <a id="10476" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="10478" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="10481" class="Symbol">(</a><a id="10482" href="Cat.Functor.Kan.html#6936" class="Bound">colim</a> <a id="10488" class="Symbol">(</a><a id="10489" href="Cat.Functor.Kan.html#8622" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="10497" href="Cat.Functor.Kan.html#10141" class="Bound">f</a><a id="10498" class="Symbol">)</a> <a id="10500" class="Symbol">.</a><a id="10501" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="10505" class="Symbol">.</a><a id="10506" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a><a id="10507" class="Symbol">)</a>
               <a id="10524" class="Symbol">(</a><a id="10525" href="Cat.Instances.Comma.html#3533" data-type="(F : Functor A C) (G : Functor B₁ C) (p : a .x ≡ b .x)
(q : a .y ≡ b .y) →
PathP (λ i → Hom C (F₀ F (p i)) (F₀ G (q i))) (a .map) (b .map) →
a ≡ b" class="Function">↓Obj-path</a> <a id="10535" class="Symbol">_</a> <a id="10537" class="Symbol">_</a> <a id="10539" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="10544" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="10549" class="Symbol">(</a><a id="10550" href="Cat.Base.html#3857" data-type="(r : Precategory o h) (f : r .Hom y z) (g : r .Hom x y)
(h : r .Hom w x) →
r ._∘_ f (r ._∘_ g h) ≡ r ._∘_ (r ._∘_ f g) h" class="Function">D.assoc</a> <a id="10558" class="Symbol">_</a> <a id="10560" class="Symbol">_</a> <a id="10562" class="Symbol">_)))</a>

    <a id="10572" class="Keyword">open</a> <a id="10577" href="Cat.Base.html#12241" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Module Operator">_=&gt;_</a>
</pre>-->
<p>It remains to show that our extension functor admits a natural transformation (with components) <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>x</mi><mo>→</mo><mi mathvariant="normal">colim</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>F</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Fx \to \colim(Fx)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">colim</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>,</span> but we can take these arrows to be the colimit coprojections <span class="Agda"><a href="Cat.Diagram.Colimit.Base.html#2681" class="Field">ψ</a></span>; The factoring natural transformation <span class="Agda"><a href="Cat.Functor.Kan.html#3692" class="Field">σ</a></span> is given by eliminating the colimit, which ensures commutativity and uniqueness. We leave the rest of the computation in this <code class="sourceCode html"><span class="kw">&lt;details&gt;</span></code> tag, for the interested reader.</p>
<details>
<summary>
Fair advance warning that the computation here doesn’t have any further comments.
</summary>
<pre class="Agda">    <a id="11133" href="Cat.Functor.Kan.html#11133" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">lan</a> <a id="11137" class="Symbol">:</a> <a id="11139" href="Cat.Functor.Kan.html#2838" data-type="(p : Functor C C′) (F : Functor C D) →
Type (C.o ⊔ C.ℓ ⊔ C′.o ⊔ C′.ℓ ⊔ D.o ⊔ D.ℓ)" class="Record">Lan</a> <a id="11143" href="Cat.Functor.Kan.html#6988" class="Bound">K</a> <a id="11145" href="Cat.Functor.Kan.html#6968" class="Bound">F</a>
    <a id="11151" href="Cat.Functor.Kan.html#11133" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">lan</a> <a id="11155" class="Symbol">.</a><a id="11156" href="Cat.Functor.Kan.html#2918" data-type="Lan p F → Functor C′ D" class="Field">Ext</a> <a id="11160" class="Symbol">=</a> <a id="11162" href="Cat.Functor.Kan.html#9636" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Functor D E" class="Function">func</a>
    <a id="11171" href="Cat.Functor.Kan.html#11133" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">lan</a> <a id="11175" class="Symbol">.</a><a id="11176" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a> <a id="11180" class="Symbol">.</a><a id="11181" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="11183" href="Cat.Functor.Kan.html#11183" class="Bound">x</a> <a id="11185" class="Symbol">=</a> <a id="11187" href="Cat.Functor.Kan.html#6936" class="Bound">colim</a> <a id="11193" class="Symbol">(</a><a id="11194" href="Cat.Functor.Kan.html#8622" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="11202" class="Symbol">(</a><a id="11203" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">K.₀</a> <a id="11207" href="Cat.Functor.Kan.html#11183" class="Bound">x</a><a id="11208" class="Symbol">))</a> <a id="11211" class="Symbol">.</a><a id="11212" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="11216" class="Symbol">.</a><a id="11217" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a> <a id="11219" class="Symbol">(</a><a id="11220" class="Keyword">record</a> <a id="11227" class="Symbol">{</a> <a id="11229" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a> <a id="11233" class="Symbol">=</a> <a id="11235" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a> <a id="11240" class="Symbol">})</a>

    <a id="11248" href="Cat.Functor.Kan.html#11133" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">lan</a> <a id="11252" class="Symbol">.</a><a id="11253" href="Cat.Functor.Kan.html#3692" data-type="(r : Lan p F) → F =&gt; M F∘ p → r .Ext =&gt; M" class="Field">σ</a> <a id="11255" class="Symbol">{</a><a id="11256" href="Cat.Functor.Kan.html#11256" class="Bound">M</a><a id="11257" class="Symbol">}</a> <a id="11259" href="Cat.Functor.Kan.html#11259" class="Bound">α</a> <a id="11261" class="Symbol">.</a><a id="11262" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="11264" href="Cat.Functor.Kan.html#11264" class="Bound">x</a> <a id="11266" class="Symbol">=</a> <a id="11268" href="Cat.Functor.Kan.html#6936" class="Bound">colim</a> <a id="11274" class="Symbol">(</a><a id="11275" href="Cat.Functor.Kan.html#8622" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="11283" href="Cat.Functor.Kan.html#11264" class="Bound">x</a><a id="11284" class="Symbol">)</a> <a id="11286" class="Symbol">.</a><a id="11287" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="11292" href="Cat.Functor.Kan.html#11360" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(α : F =&gt; M F∘ K) (x : D .Ob) →
Cocone (diagram colim F K x)" class="Function">cocone′</a> <a id="11300" class="Symbol">.</a><a id="11301" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="11308" class="Symbol">.</a><a id="11309" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a>
      <a id="11319" class="Keyword">where</a>
        <a id="11333" class="Keyword">module</a> <a id="11340" href="Cat.Functor.Kan.html#11340" class="Module">M</a> <a id="11342" class="Symbol">=</a> <a id="11344" href="Cat.Functor.Reasoning.html" class="Module">Func</a> <a id="11349" href="Cat.Functor.Kan.html#11256" class="Bound">M</a>

        <a id="11360" href="Cat.Functor.Kan.html#11360" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(α : F =&gt; M F∘ K) (x : D .Ob) →
Cocone (diagram colim F K x)" class="Function">cocone′</a> <a id="11368" class="Symbol">:</a> <a id="11370" href="Cat.Diagram.Colimit.Base.html#2300" data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Record">Cocone</a> <a id="11377" class="Symbol">_</a>
        <a id="11387" href="Cat.Functor.Kan.html#11360" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(α : F =&gt; M F∘ K) (x : D .Ob) →
Cocone (diagram colim F K x)" class="Function">cocone′</a> <a id="11395" class="Symbol">.</a><a id="11396" href="Cat.Diagram.Colimit.Base.html#2661" data-type="Cocone F → C .Ob" class="Field">coapex</a> <a id="11403" class="Symbol">=</a> <a id="11405" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">M.₀</a> <a id="11409" href="Cat.Functor.Kan.html#11264" class="Bound">x</a>
        <a id="11419" href="Cat.Functor.Kan.html#11360" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(α : F =&gt; M F∘ K) (x : D .Ob) →
Cocone (diagram colim F K x)" class="Function">cocone′</a> <a id="11427" class="Symbol">.</a><a id="11428" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a> <a id="11430" href="Cat.Functor.Kan.html#11430" class="Bound">ob</a> <a id="11433" class="Symbol">=</a> <a id="11435" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="11439" class="Symbol">(</a><a id="11440" href="Cat.Functor.Kan.html#11430" class="Bound">ob</a> <a id="11443" class="Symbol">.</a><a id="11444" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a><a id="11447" class="Symbol">)</a> <a id="11449" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">E.∘</a> <a id="11453" href="Cat.Functor.Kan.html#11259" class="Bound">α</a> <a id="11455" class="Symbol">.</a><a id="11456" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="11458" class="Symbol">_</a>
        <a id="11468" href="Cat.Functor.Kan.html#11360" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(α : F =&gt; M F∘ K) (x : D .Ob) →
Cocone (diagram colim F K x)" class="Function">cocone′</a> <a id="11476" class="Symbol">.</a><a id="11477" href="Cat.Diagram.Colimit.Base.html#3115" data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" class="Field">commutes</a> <a id="11486" class="Symbol">{</a><a id="11487" href="Cat.Functor.Kan.html#11487" class="Bound">x</a><a id="11488" class="Symbol">}</a> <a id="11490" class="Symbol">{</a><a id="11491" href="Cat.Functor.Kan.html#11491" class="Bound">y</a><a id="11492" class="Symbol">}</a> <a id="11494" href="Cat.Functor.Kan.html#11494" class="Bound">f</a> <a id="11496" class="Symbol">=</a>
          <a id="11508" class="Symbol">(</a><a id="11509" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="11513" class="Symbol">(</a><a id="11514" href="Cat.Functor.Kan.html#11491" class="Bound">y</a> <a id="11516" class="Symbol">.</a><a id="11517" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a><a id="11520" class="Symbol">)</a> <a id="11522" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">E.∘</a> <a id="11526" href="Cat.Functor.Kan.html#11259" class="Bound">α</a> <a id="11528" class="Symbol">.</a><a id="11529" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="11531" class="Symbol">_)</a> <a id="11534" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">E.∘</a> <a id="11538" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">F.₁</a> <a id="11542" class="Symbol">(</a><a id="11543" href="Cat.Functor.Kan.html#11494" class="Bound">f</a> <a id="11545" class="Symbol">.</a><a id="11546" href="Cat.Instances.Comma.html#2595" data-type="↓Hom F G a b → Hom A (a .x) (x b)" class="Field">↓Hom.α</a><a id="11552" class="Symbol">)</a>      <span class="reasoning-step"><span class="as-written Function"><a id="11559" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="11562" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">E.pullr</a> <a id="11570" class="Symbol">(</a><a id="11571" href="Cat.Functor.Kan.html#11259" class="Bound">α</a> <a id="11573" class="Symbol">.</a><a id="11574" href="Cat.Base.html#13369" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="11585" class="Symbol">_</a> <a id="11587" class="Symbol">_</a> <a id="11589" class="Symbol">_)</a> <a id="11592" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a id="11604" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="11608" class="Symbol">(</a><a id="11609" href="Cat.Functor.Kan.html#11491" class="Bound">y</a> <a id="11611" class="Symbol">.</a><a id="11612" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a><a id="11615" class="Symbol">)</a> <a id="11617" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">E.∘</a> <a id="11621" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="11625" class="Symbol">(</a><a id="11626" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">K.₁</a> <a id="11630" class="Symbol">(</a><a id="11631" href="Cat.Functor.Kan.html#11494" class="Bound">f</a> <a id="11633" class="Symbol">.</a><a id="11634" href="Cat.Instances.Comma.html#2595" data-type="↓Hom F G a b → Hom A (a .x) (x b)" class="Field">↓Hom.α</a><a id="11640" class="Symbol">))</a> <a id="11643" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">E.∘</a> <a id="11647" href="Cat.Functor.Kan.html#11259" class="Bound">α</a> <a id="11649" class="Symbol">.</a><a id="11650" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="11652" class="Symbol">_</a>  <span class="reasoning-step"><span class="as-written Function"><a id="11655" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="11658" href="Cat.Functor.Reasoning.html#1281" data-type="(F : Functor 𝒞 𝒟) (ab≡c : (F ∘ a) b ≡ c) →
(F ∘ F₁ F a) ((F ∘ F₁ F b) f) ≡ (F ∘ F₁ F c) f" class="Function">M.pulll</a> <a id="11666" class="Symbol">(</a><a id="11667" href="Cat.Functor.Kan.html#11494" class="Bound">f</a> <a id="11669" class="Symbol">.</a><a id="11670" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">↓Hom.sq</a> <a id="11678" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="11680" href="Cat.Base.html#3482" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" class="Function">D.idl</a> <a id="11686" class="Symbol">_)</a> <a id="11689" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a id="11701" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="11705" class="Symbol">(</a><a id="11706" href="Cat.Functor.Kan.html#11487" class="Bound">x</a> <a id="11708" class="Symbol">.</a><a id="11709" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a><a id="11712" class="Symbol">)</a> <a id="11714" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">E.∘</a> <a id="11718" href="Cat.Functor.Kan.html#11259" class="Bound">α</a> <a id="11720" class="Symbol">.</a><a id="11721" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="11723" class="Symbol">_</a>                            <a id="11752" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

    <a id="11759" href="Cat.Functor.Kan.html#11133" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">lan</a> <a id="11763" class="Symbol">.</a><a id="11764" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a> <a id="11768" class="Symbol">.</a><a id="11769" href="Cat.Base.html#13369" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="11780" href="Cat.Functor.Kan.html#11780" class="Bound">x</a> <a id="11782" href="Cat.Functor.Kan.html#11782" class="Bound">y</a> <a id="11784" href="Cat.Functor.Kan.html#11784" class="Bound">f</a> <a id="11786" class="Symbol">=</a> <a id="11788" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="11792" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a>
        <a id="11802" href="Cat.Functor.Kan.html#6936" class="Bound">colim</a> <a id="11808" class="Symbol">(</a><a id="11809" href="Cat.Functor.Kan.html#8622" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="11817" class="Symbol">(</a><a id="11818" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">K.₀</a> <a id="11822" href="Cat.Functor.Kan.html#11780" class="Bound">x</a><a id="11823" class="Symbol">))</a> <a id="11826" class="Symbol">.</a><a id="11827" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="11832" class="Symbol">(</a><a id="11833" href="Cat.Functor.Kan.html#8699" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">approx</a> <a id="11840" class="Symbol">(</a><a id="11841" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">K.₁</a> <a id="11845" href="Cat.Functor.Kan.html#11784" class="Bound">f</a><a id="11846" class="Symbol">))</a> <a id="11849" class="Symbol">.</a><a id="11850" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="11857" class="Symbol">.</a><a id="11858" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="11867" class="Symbol">_</a>
      <a id="11875" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="11877" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="11881" class="Symbol">(</a><a id="11882" href="Cat.Functor.Kan.html#6936" class="Bound">colim</a> <a id="11888" class="Symbol">(</a><a id="11889" href="Cat.Functor.Kan.html#8622" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="11897" class="Symbol">(</a><a id="11898" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">K.₀</a> <a id="11902" href="Cat.Functor.Kan.html#11782" class="Bound">y</a><a id="11903" class="Symbol">))</a> <a id="11906" class="Symbol">.</a><a id="11907" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="11911" class="Symbol">.</a><a id="11912" href="Cat.Diagram.Colimit.Base.html#3115" data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" class="Field">commutes</a>
            <a id="11933" class="Symbol">(</a><a id="11934" class="Keyword">record</a> <a id="11941" class="Symbol">{</a> <a id="11943" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">sq</a> <a id="11946" class="Symbol">=</a> <a id="11948" href="Cat.Reasoning.html#1207" data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → f ≡ (C ∘ a) f" class="Function">D.introl</a> <a id="11957" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="11962" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="11964" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="11968" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D._∘_</a> <a id="11974" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="11979" class="Symbol">(</a><a id="11980" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="11984" href="Cat.Reasoning.html#789" data-type="(C : Precategory o ℓ) → (C ∘ f) (id C) ≡ (C ∘ id C) f" class="Function">D.id-comm</a><a id="11993" class="Symbol">)</a> <a id="11995" class="Symbol">}))</a>

    <a id="12004" href="Cat.Functor.Kan.html#11133" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">lan</a> <a id="12008" class="Symbol">.</a><a id="12009" href="Cat.Functor.Kan.html#3692" data-type="(r : Lan p F) → F =&gt; M F∘ p → r .Ext =&gt; M" class="Field">σ</a> <a id="12011" class="Symbol">{</a><a id="12012" href="Cat.Functor.Kan.html#12012" class="Bound">M</a><a id="12013" class="Symbol">}</a> <a id="12015" href="Cat.Functor.Kan.html#12015" class="Bound">α</a> <a id="12017" class="Symbol">.</a><a id="12018" href="Cat.Base.html#13369" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="12029" href="Cat.Functor.Kan.html#12029" class="Bound">x</a> <a id="12031" href="Cat.Functor.Kan.html#12031" class="Bound">y</a> <a id="12033" href="Cat.Functor.Kan.html#12033" class="Bound">f</a> <a id="12035" class="Symbol">=</a>
      <a id="12043" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="12046" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a> <a id="12050" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="12052" href="1Lab.HLevel.html#3818" data-type="is-contr A → is-prop A" class="Function">is-contr→is-prop</a> <a id="12069" class="Symbol">(</a><a id="12070" href="Cat.Functor.Kan.html#6936" class="Bound">colim</a> <a id="12076" class="Symbol">(</a><a id="12077" href="Cat.Functor.Kan.html#8622" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="12085" href="Cat.Functor.Kan.html#12029" class="Bound">x</a><a id="12086" class="Symbol">)</a> <a id="12088" class="Symbol">.</a><a id="12089" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="12094" href="Cat.Functor.Kan.html#12444" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(α : F =&gt; M F∘ K) (x y : D .Ob) (f : D .Hom x y) →
Cocone (diagram colim F K x)" class="Function">cocone′</a><a id="12101" class="Symbol">)</a>
        <a id="12111" class="Symbol">(</a><a id="12112" href="Cat.Diagram.Colimit.Base.html#4170" data-type="(hom : C .Hom (x .coapex) (y .coapex))
(commutes : (o : J₁ .Ob) → C ._∘_ hom (x .ψ o) ≡ y .ψ o) →
Cocone-hom F x y" class="InductiveConstructor">cocone-hom</a> <a id="12123" class="Symbol">_</a> <a id="12125" class="Symbol">λ</a> <a id="12127" href="Cat.Functor.Kan.html#12127" class="Bound">o</a> <a id="12129" class="Symbol">→</a> <a id="12131" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">E.pullr</a> <a id="12139" class="Symbol">(</a><a id="12140" href="Cat.Functor.Kan.html#6936" class="Bound">colim</a> <a id="12146" class="Symbol">(</a><a id="12147" href="Cat.Functor.Kan.html#8622" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="12155" href="Cat.Functor.Kan.html#12029" class="Bound">x</a><a id="12156" class="Symbol">)</a> <a id="12158" class="Symbol">.</a><a id="12159" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="12164" class="Symbol">(</a><a id="12165" href="Cat.Functor.Kan.html#8699" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">approx</a> <a id="12172" href="Cat.Functor.Kan.html#12033" class="Bound">f</a><a id="12173" class="Symbol">)</a> <a id="12175" class="Symbol">.</a><a id="12176" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="12183" class="Symbol">.</a><a id="12184" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="12193" class="Symbol">_)</a>
                          <a id="12222" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="12224" href="Cat.Functor.Kan.html#6936" class="Bound">colim</a> <a id="12230" class="Symbol">(</a><a id="12231" href="Cat.Functor.Kan.html#8622" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="12239" href="Cat.Functor.Kan.html#12031" class="Bound">y</a><a id="12240" class="Symbol">)</a> <a id="12242" class="Symbol">.</a><a id="12243" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="12248" class="Symbol">_</a> <a id="12250" class="Symbol">.</a><a id="12251" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="12258" class="Symbol">.</a><a id="12259" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="12268" class="Symbol">_)</a>
        <a id="12279" class="Symbol">(</a><a id="12280" href="Cat.Diagram.Colimit.Base.html#4170" data-type="(hom : C .Hom (x .coapex) (y .coapex))
(commutes : (o : J₁ .Ob) → C ._∘_ hom (x .ψ o) ≡ y .ψ o) →
Cocone-hom F x y" class="InductiveConstructor">cocone-hom</a> <a id="12291" class="Symbol">_</a> <a id="12293" class="Symbol">λ</a> <a id="12295" href="Cat.Functor.Kan.html#12295" class="Bound">o</a> <a id="12297" class="Symbol">→</a> <a id="12299" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">E.pullr</a> <a id="12307" class="Symbol">(</a><a id="12308" href="Cat.Functor.Kan.html#6936" class="Bound">colim</a> <a id="12314" class="Symbol">(</a><a id="12315" href="Cat.Functor.Kan.html#8622" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="12323" href="Cat.Functor.Kan.html#12029" class="Bound">x</a><a id="12324" class="Symbol">)</a> <a id="12326" class="Symbol">.</a><a id="12327" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="12332" class="Symbol">_</a> <a id="12334" class="Symbol">.</a><a id="12335" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="12342" class="Symbol">.</a><a id="12343" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="12352" class="Symbol">_)</a>
                          <a id="12381" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="12383" href="Cat.Functor.Reasoning.html#1281" data-type="(F : Functor 𝒞 𝒟) (ab≡c : (F ∘ a) b ≡ c) →
(F ∘ F₁ F a) ((F ∘ F₁ F b) f) ≡ (F ∘ F₁ F c) f" class="Function">M.pulll</a> <a id="12391" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="12395" class="Symbol">)</a>
      <a id="12403" class="Keyword">where</a>
        <a id="12417" class="Keyword">module</a> <a id="12424" href="Cat.Functor.Kan.html#12424" class="Module">M</a> <a id="12426" class="Symbol">=</a> <a id="12428" href="Cat.Functor.Reasoning.html" class="Module">Func</a> <a id="12433" href="Cat.Functor.Kan.html#12012" class="Bound">M</a>

        <a id="12444" href="Cat.Functor.Kan.html#12444" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(α : F =&gt; M F∘ K) (x y : D .Ob) (f : D .Hom x y) →
Cocone (diagram colim F K x)" class="Function">cocone′</a> <a id="12452" class="Symbol">:</a> <a id="12454" href="Cat.Diagram.Colimit.Base.html#2300" data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Record">Cocone</a> <a id="12461" class="Symbol">_</a>
        <a id="12471" href="Cat.Functor.Kan.html#12444" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(α : F =&gt; M F∘ K) (x y : D .Ob) (f : D .Hom x y) →
Cocone (diagram colim F K x)" class="Function">cocone′</a> <a id="12479" class="Symbol">.</a><a id="12480" href="Cat.Diagram.Colimit.Base.html#2661" data-type="Cocone F → C .Ob" class="Field">coapex</a> <a id="12487" class="Symbol">=</a> <a id="12489" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">M.₀</a> <a id="12493" href="Cat.Functor.Kan.html#12031" class="Bound">y</a>
        <a id="12503" href="Cat.Functor.Kan.html#12444" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(α : F =&gt; M F∘ K) (x y : D .Ob) (f : D .Hom x y) →
Cocone (diagram colim F K x)" class="Function">cocone′</a> <a id="12511" class="Symbol">.</a><a id="12512" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a> <a id="12514" href="Cat.Functor.Kan.html#12514" class="Bound">x</a> <a id="12516" class="Symbol">=</a> <a id="12518" class="Symbol">_</a>
        <a id="12528" href="Cat.Functor.Kan.html#12444" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(α : F =&gt; M F∘ K) (x y : D .Ob) (f : D .Hom x y) →
Cocone (diagram colim F K x)" class="Function">cocone′</a> <a id="12536" class="Symbol">.</a><a id="12537" href="Cat.Diagram.Colimit.Base.html#3115" data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" class="Field">commutes</a> <a id="12546" class="Symbol">{</a><a id="12547" href="Cat.Functor.Kan.html#12547" class="Bound">x</a><a id="12548" class="Symbol">}</a> <a id="12550" class="Symbol">{</a><a id="12551" href="Cat.Functor.Kan.html#12551" class="Bound">y</a><a id="12552" class="Symbol">}</a> <a id="12554" href="Cat.Functor.Kan.html#12554" class="Bound">f</a> <a id="12556" class="Symbol">=</a>
            <a id="12570" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">E.pullr</a> <a id="12578" class="Symbol">(</a><a id="12579" href="Cat.Functor.Kan.html#12015" class="Bound">α</a> <a id="12581" class="Symbol">.</a><a id="12582" href="Cat.Base.html#13369" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="12593" class="Symbol">_</a> <a id="12595" class="Symbol">_</a> <a id="12597" class="Symbol">_)</a>
          <a id="12610" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="12612" href="Cat.Functor.Reasoning.html#1281" data-type="(F : Functor 𝒞 𝒟) (ab≡c : (F ∘ a) b ≡ c) →
(F ∘ F₁ F a) ((F ∘ F₁ F b) f) ≡ (F ∘ F₁ F c) f" class="Function">M.pulll</a> <a id="12620" class="Symbol">(</a><a id="12621" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">D.pullr</a> <a id="12629" class="Symbol">(</a><a id="12630" href="Cat.Functor.Kan.html#12554" class="Bound">f</a> <a id="12632" class="Symbol">.</a><a id="12633" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">↓Hom.sq</a> <a id="12641" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="12643" href="Cat.Base.html#3482" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" class="Function">D.idl</a> <a id="12649" class="Symbol">_))</a>

    <a id="12658" href="Cat.Functor.Kan.html#11133" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">lan</a> <a id="12662" class="Symbol">.</a><a id="12663" href="Cat.Functor.Kan.html#3748" data-type="(r : Lan p F) → (whiskerl (r .σ α) ∘nt r .eta) ≡ α" class="Field">σ-comm</a> <a id="12670" class="Symbol">{</a><a id="12671" class="Argument">M</a> <a id="12673" class="Symbol">=</a> <a id="12675" href="Cat.Functor.Kan.html#12675" class="Bound">M</a><a id="12676" class="Symbol">}</a> <a id="12678" class="Symbol">=</a>
      <a id="12686" href="Cat.Base.html#15597" data-type="((x : C .Ob) → a .η x ≡ b .η x) → a ≡ b" class="Function">Nat-path</a> <a id="12695" class="Symbol">λ</a> <a id="12697" href="Cat.Functor.Kan.html#12697" class="Bound">x</a> <a id="12699" class="Symbol">→</a> <a id="12701" href="Cat.Functor.Kan.html#6936" class="Bound">colim</a> <a id="12707" class="Symbol">(</a><a id="12708" href="Cat.Functor.Kan.html#8622" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="12716" class="Symbol">(</a><a id="12717" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">K.₀</a> <a id="12721" href="Cat.Functor.Kan.html#12697" class="Bound">x</a><a id="12722" class="Symbol">))</a> <a id="12725" class="Symbol">.</a><a id="12726" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="12731" class="Symbol">_</a>  <a id="12734" class="Symbol">.</a><a id="12735" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="12742" class="Symbol">.</a><a id="12743" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="12752" class="Symbol">_</a> <a id="12754" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="12756" href="Cat.Functor.Reasoning.html#936" data-type="(F : Functor 𝒞 𝒟) (a≡id : a ≡ id F) → (F ∘ F₁ F a) f ≡ f" class="Function">M.eliml</a> <a id="12764" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
      <a id="12775" class="Keyword">where</a> <a id="12781" class="Keyword">module</a> <a id="12788" href="Cat.Functor.Kan.html#12788" class="Module">M</a> <a id="12790" class="Symbol">=</a> <a id="12792" href="Cat.Functor.Reasoning.html" class="Module">Func</a> <a id="12797" href="Cat.Functor.Kan.html#12675" class="Bound">M</a>

    <a id="12804" href="Cat.Functor.Kan.html#11133" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">lan</a> <a id="12808" class="Symbol">.</a><a id="12809" href="Cat.Functor.Kan.html#3827" data-type="(r : Lan p F) → α ≡ (whiskerl σ′ ∘nt r .eta) → r .σ α ≡ σ′" class="Field">σ-uniq</a> <a id="12816" class="Symbol">{</a><a id="12817" class="Argument">M</a> <a id="12819" class="Symbol">=</a> <a id="12821" href="Cat.Functor.Kan.html#12821" class="Bound">M</a><a id="12822" class="Symbol">}</a> <a id="12824" class="Symbol">{</a><a id="12825" href="Cat.Functor.Kan.html#12825" class="Bound">α</a><a id="12826" class="Symbol">}</a> <a id="12828" class="Symbol">{</a><a id="12829" href="Cat.Functor.Kan.html#12829" class="Bound">σ&#39;</a><a id="12831" class="Symbol">}</a> <a id="12833" href="Cat.Functor.Kan.html#12833" class="Bound">path</a> <a id="12838" class="Symbol">=</a> <a id="12840" href="Cat.Base.html#15597" data-type="((x : C .Ob) → a .η x ≡ b .η x) → a ≡ b" class="Function">Nat-path</a> <a id="12849" class="Symbol">λ</a> <a id="12851" href="Cat.Functor.Kan.html#12851" class="Bound">x</a> <a id="12853" class="Symbol">→</a>
      <a id="12861" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="12864" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a> <a id="12868" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="12870" href="Cat.Functor.Kan.html#6936" class="Bound">colim</a> <a id="12876" class="Symbol">(</a><a id="12877" href="Cat.Functor.Kan.html#8622" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="12885" class="Symbol">_)</a> <a id="12888" class="Symbol">.</a><a id="12889" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="12894" class="Symbol">_</a> <a id="12896" class="Symbol">.</a><a id="12897" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a>
        <a id="12911" class="Symbol">(</a><a id="12912" href="Cat.Diagram.Colimit.Base.html#4170" data-type="(hom : C .Hom (x .coapex) (y .coapex))
(commutes : (o : J₁ .Ob) → C ._∘_ hom (x .ψ o) ≡ y .ψ o) →
Cocone-hom F x y" class="InductiveConstructor">cocone-hom</a> <a id="12923" class="Symbol">_</a> <a id="12925" class="Symbol">λ</a> <a id="12927" href="Cat.Functor.Kan.html#12927" class="Bound">o</a> <a id="12929" class="Symbol">→</a> <a id="12931" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="12935" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a>
            <a id="12949" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="12953" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">E._∘_</a> <a id="12959" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="12964" class="Symbol">(</a><a id="12965" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="12968" class="Symbol">(λ</a> <a id="12971" href="Cat.Functor.Kan.html#12971" class="Bound">e</a> <a id="12973" class="Symbol">→</a> <a id="12975" href="Cat.Functor.Kan.html#12971" class="Bound">e</a> <a id="12977" class="Symbol">.</a><a id="12978" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="12980" class="Symbol">_)</a> <a id="12983" href="Cat.Functor.Kan.html#12833" class="Bound">path</a><a id="12987" class="Symbol">)</a>
          <a id="12999" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="13001" href="Cat.Reasoning.html#1548" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ a) ((C ∘ b) f) ≡ (C ∘ c) f" class="Function">E.pulll</a> <a id="13009" class="Symbol">(</a><a id="13010" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="13014" class="Symbol">(</a><a id="13015" href="Cat.Functor.Kan.html#12829" class="Bound">σ&#39;</a> <a id="13018" class="Symbol">.</a><a id="13019" href="Cat.Base.html#13369" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="13030" class="Symbol">_</a> <a id="13032" class="Symbol">_</a> <a id="13034" class="Symbol">_))</a>
          <a id="13048" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="13050" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">E.pullr</a> <a id="13058" class="Symbol">(</a> <a id="13060" href="Cat.Functor.Kan.html#6936" class="Bound">colim</a> <a id="13066" class="Symbol">_</a> <a id="13068" class="Symbol">.</a><a id="13069" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="13074" class="Symbol">_</a> <a id="13076" class="Symbol">.</a><a id="13077" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="13084" class="Symbol">.</a><a id="13085" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="13094" class="Symbol">_</a>
                    <a id="13116" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="13118" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="13121" class="Symbol">(</a><a id="13122" href="Cat.Functor.Kan.html#6936" class="Bound">colim</a> <a id="13128" class="Symbol">(</a><a id="13129" href="Cat.Functor.Kan.html#8622" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="13137" href="Cat.Functor.Kan.html#12851" class="Bound">x</a><a id="13138" class="Symbol">)</a> <a id="13140" class="Symbol">.</a><a id="13141" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="13145" class="Symbol">.</a><a id="13146" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a><a id="13147" class="Symbol">)</a>
                         <a id="13174" class="Symbol">(</a><a id="13175" href="Cat.Instances.Comma.html#3533" data-type="(F : Functor A C) (G : Functor B₁ C) (p : a .x ≡ b .x)
(q : a .y ≡ b .y) →
PathP (λ i → Hom C (F₀ F (p i)) (F₀ G (q i))) (a .map) (b .map) →
a ≡ b" class="Function">↓Obj-path</a> <a id="13185" class="Symbol">_</a> <a id="13187" class="Symbol">_</a> <a id="13189" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="13194" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="13199" class="Symbol">(</a><a id="13200" href="Cat.Base.html#3437" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" class="Function">D.idr</a> <a id="13206" class="Symbol">_))))</a>
</pre>
</details>
<p>A useful result about this calculation of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mi>F</mi></msub><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Lan_F(G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Lan</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span></span></span></span> is that, if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> is fully faithful, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mi>F</mi></msub><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>∘</mo><mi>F</mi><mo>≅</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">\Lan_F(G) \circ F \cong G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Lan</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> — the left Kan extension along a fully-faithful functor does actually <em>extend</em>.</p>
<pre class="Agda">  <a id="13443" class="Keyword">private</a> <a id="13451" class="Keyword">module</a> <a id="13458" href="Cat.Functor.Kan.html#13458" class="Module">Fn</a> <a id="13461" class="Symbol">=</a> <a id="13463" href="Cat.Reasoning.html" class="Module">Cat</a> <a id="13467" href="Cat.Instances.Functor.html#2100" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Precategory (o₁ ⊔ o₂ ⊔ h₁ ⊔ h₂) (o₁ ⊔ h₁ ⊔ h₂)" class="Function Operator">Cat[</a> <a id="13472" href="Cat.Functor.Kan.html#6867" class="Bound">C</a> <a id="13474" href="Cat.Instances.Functor.html#2100" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Precategory (o₁ ⊔ o₂ ⊔ h₁ ⊔ h₂) (o₁ ⊔ h₁ ⊔ h₂)" class="Function Operator">,</a> <a id="13476" href="Cat.Functor.Kan.html#6912" class="Bound">E</a> <a id="13478" href="Cat.Instances.Functor.html#2100" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Precategory (o₁ ⊔ o₂ ⊔ h₁ ⊔ h₂) (o₁ ⊔ h₁ ⊔ h₂)" class="Function Operator">]</a>
  <a id="13482" class="Keyword">open</a> <a id="13487" href="Cat.Base.html#12241" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Module Operator">_=&gt;_</a>

  <a id="13495" href="Cat.Functor.Kan.html#13495" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
is-fully-faithful K →
(Cat[ C , E ] ≅ (cocomplete→lan colim F K .Ext F∘ K)) F" class="Function">ff-lan-ext</a> <a id="13506" class="Symbol">:</a> <a id="13508" href="Cat.Functor.Base.html#1110" data-type="Functor C D → Type (C.o ⊔ C.h ⊔ D.h)" class="Function">is-fully-faithful</a> <a id="13526" href="Cat.Functor.Kan.html#6988" class="Bound">K</a> <a id="13528" class="Symbol">→</a> <a id="13530" href="Cat.Functor.Kan.html#8564" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">cocomplete→lan</a> <a id="13545" class="Symbol">.</a><a id="13546" href="Cat.Functor.Kan.html#2918" data-type="Lan p F → Functor C′ D" class="Field">Ext</a> <a id="13550" href="Cat.Base.html#9697" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="13553" href="Cat.Functor.Kan.html#6988" class="Bound">K</a> <a id="13555" href="Cat.Morphism.html#2202" data-type="(C : Precategory o h) (a b : Ob C) → Type h" class="Record Operator">Fn.≅</a> <a id="13560" href="Cat.Functor.Kan.html#6968" class="Bound">F</a>

  <a id="13565" href="Cat.Functor.Kan.html#13495" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
is-fully-faithful K →
(Cat[ C , E ] ≅ (cocomplete→lan colim F K .Ext F∘ K)) F" class="Function">ff-lan-ext</a> <a id="13576" href="Cat.Functor.Kan.html#13576" class="Bound">ff</a> <a id="13579" class="Symbol">=</a> <a id="13581" href="Cat.Morphism.html#7747" data-type="(C : Precategory o h) → (C ≅ a) b → (C ≅ b) a" class="Function Operator">Fn._Iso⁻¹</a> <a id="13591" class="Symbol">(</a><a id="13592" href="Cat.Morphism.html#3941" data-type="(C : Precategory o h) (f : Hom C a b) →
is-invertible C f → (C ≅ a) b" class="Function">Fn.invertible→iso</a> <a id="13610" class="Symbol">(</a><a id="13611" href="Cat.Functor.Kan.html#8564" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">cocomplete→lan</a> <a id="13626" class="Symbol">.</a><a id="13627" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a><a id="13630" class="Symbol">)</a> <a id="13632" href="Cat.Functor.Kan.html#14801" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) →
is-invertible Cat[ C , E ] (cocomplete→lan colim F K .eta)" class="Function">inv</a><a id="13635" class="Symbol">)</a> <a id="13637" class="Keyword">where</a>
    <a id="13647" href="Cat.Functor.Kan.html#13647" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
is-fully-faithful K →
(x : C .Ob) → is-invertible E (cocomplete→lan colim F K .eta .η x)" class="Function">inv′</a> <a id="13652" class="Symbol">:</a> <a id="13654" class="Symbol">∀</a> <a id="13656" href="Cat.Functor.Kan.html#13656" class="Bound">x</a> <a id="13658" class="Symbol">→</a> <a id="13660" href="Cat.Morphism.html#1930" data-type="(C : Precategory o h) (f : Hom C a b) → Type h" class="Record">E.is-invertible</a> <a id="13676" class="Symbol">(</a><a id="13677" href="Cat.Functor.Kan.html#8564" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">cocomplete→lan</a> <a id="13692" class="Symbol">.</a><a id="13693" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a> <a id="13697" class="Symbol">.</a><a id="13698" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="13700" href="Cat.Functor.Kan.html#13656" class="Bound">x</a><a id="13701" class="Symbol">)</a>
    <a id="13707" href="Cat.Functor.Kan.html#13647" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
is-fully-faithful K →
(x : C .Ob) → is-invertible E (cocomplete→lan colim F K .eta .η x)" class="Function">inv′</a> <a id="13712" href="Cat.Functor.Kan.html#13712" class="Bound">x</a> <a id="13714" class="Symbol">=</a> <a id="13716" href="Cat.Morphism.html#3457" data-type="(C : Precategory o h) (g : Hom C b a) →
(C ∘ f) g ≡ id C → (C ∘ g) f ≡ id C → is-invertible C f" class="Function">E.make-invertible</a> <a id="13734" href="Cat.Functor.Kan.html#14122" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
E .Hom (colim (diagram colim F K (F₀ K x)) .bot .coapex) (₀ F x)" class="Function">to</a> <a id="13737" href="Cat.Functor.Kan.html#14196" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
E ._∘_ (cocomplete→lan colim F K .eta .η x) (to colim F K ff x) ≡
E .id" class="Function">invl</a> <a id="13742" href="Cat.Functor.Kan.html#14582" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
E ._∘_ (to colim F K ff x) (cocomplete→lan colim F K .eta .η x) ≡
E .id" class="Function">invr</a> <a id="13747" class="Keyword">where</a>
      <a id="13759" href="Cat.Functor.Kan.html#13759" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
Cocone (diagram colim F K (F₀ K x))" class="Function">cocone′</a> <a id="13767" class="Symbol">:</a> <a id="13769" href="Cat.Diagram.Colimit.Base.html#2300" data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Record">Cocone</a> <a id="13776" class="Symbol">_</a>
      <a id="13784" href="Cat.Functor.Kan.html#13759" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
Cocone (diagram colim F K (F₀ K x))" class="Function">cocone′</a> <a id="13792" class="Symbol">.</a><a id="13793" href="Cat.Diagram.Colimit.Base.html#2661" data-type="Cocone F → C .Ob" class="Field">coapex</a> <a id="13800" class="Symbol">=</a> <a id="13802" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">F.₀</a> <a id="13806" href="Cat.Functor.Kan.html#13712" class="Bound">x</a>
      <a id="13814" href="Cat.Functor.Kan.html#13759" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
Cocone (diagram colim F K (F₀ K x))" class="Function">cocone′</a> <a id="13822" class="Symbol">.</a><a id="13823" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a> <a id="13825" href="Cat.Functor.Kan.html#13825" class="Bound">ob</a> <a id="13828" class="Symbol">=</a> <a id="13830" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">F.₁</a> <a id="13834" class="Symbol">(</a><a id="13835" href="1Lab.Equiv.html#6449" data-type="is-equiv f → B₁ → A" class="Function">equiv→inverse</a> <a id="13849" href="Cat.Functor.Kan.html#13576" class="Bound">ff</a> <a id="13852" class="Symbol">(</a><a id="13853" href="Cat.Functor.Kan.html#13825" class="Bound">ob</a> <a id="13856" class="Symbol">.</a><a id="13857" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a><a id="13860" class="Symbol">))</a>
      <a id="13869" href="Cat.Functor.Kan.html#13759" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
Cocone (diagram colim F K (F₀ K x))" class="Function">cocone′</a> <a id="13877" class="Symbol">.</a><a id="13878" href="Cat.Diagram.Colimit.Base.html#3115" data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" class="Field">commutes</a> <a id="13887" class="Symbol">{</a><a id="13888" class="Argument">x</a> <a id="13890" class="Symbol">=</a> <a id="13892" href="Cat.Functor.Kan.html#13892" class="Bound">y</a><a id="13893" class="Symbol">}</a> <a id="13895" class="Symbol">{</a><a id="13896" href="Cat.Functor.Kan.html#13896" class="Bound">z</a><a id="13897" class="Symbol">}</a> <a id="13899" href="Cat.Functor.Kan.html#13899" class="Bound">f</a> <a id="13901" class="Symbol">=</a>
        <a id="13911" href="Cat.Functor.Reasoning.html#1206" data-type="(F : Functor 𝒞 𝒟) (ab≡c : (F ∘ a) b ≡ c) →
(F ∘ F₁ F a) (F₁ F b) ≡ F₁ F c" class="Function">F.collapse</a> <a id="13922" class="Symbol">(</a><a id="13923" href="Cat.Functor.Base.html#1212" data-type="is-fully-faithful F → is-faithful F" class="Function">fully-faithful→faithful</a> <a id="13947" class="Symbol">{</a><a id="13948" class="Argument">F</a> <a id="13950" class="Symbol">=</a> <a id="13952" href="Cat.Functor.Kan.html#6988" class="Bound">K</a><a id="13953" class="Symbol">}</a> <a id="13955" href="Cat.Functor.Kan.html#13576" class="Bound">ff</a>
          <a id="13968" class="Symbol">(</a> <a id="13970" href="Cat.Functor.Kan.html#6988" class="Bound">K</a> <a id="13972" class="Symbol">.</a><a id="13973" href="Cat.Base.html#8383" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Field">Functor.F-∘</a>  <a id="13986" class="Symbol">_</a> <a id="13988" class="Symbol">_</a>
          <a id="14000" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="14002" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="14006" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D._∘_</a> <a id="14012" class="Symbol">(</a><a id="14013" href="1Lab.Equiv.html#6548" data-type="(eqv₁ : is-equiv f) → is-right-inverse (equiv→inverse eqv₁) f" class="Function">equiv→section</a> <a id="14027" href="Cat.Functor.Kan.html#13576" class="Bound">ff</a> <a id="14030" class="Symbol">_)</a> <a id="14033" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
          <a id="14048" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="14050" href="Cat.Functor.Kan.html#13899" class="Bound">f</a> <a id="14052" class="Symbol">.</a><a id="14053" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">sq</a>
          <a id="14066" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="14068" href="Cat.Base.html#3482" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" class="Function">D.idl</a> <a id="14074" class="Symbol">_</a>
          <a id="14086" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="14088" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="14092" class="Symbol">(</a><a id="14093" href="1Lab.Equiv.html#6548" data-type="(eqv₁ : is-equiv f) → is-right-inverse (equiv→inverse eqv₁) f" class="Function">equiv→section</a> <a id="14107" href="Cat.Functor.Kan.html#13576" class="Bound">ff</a> <a id="14110" class="Symbol">_)))</a>

      <a id="14122" href="Cat.Functor.Kan.html#14122" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
E .Hom (colim (diagram colim F K (F₀ K x)) .bot .coapex) (₀ F x)" class="Function">to</a> <a id="14125" class="Symbol">:</a> <a id="14127" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">E.Hom</a> <a id="14133" class="Symbol">_</a> <a id="14135" class="Symbol">(</a><a id="14136" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">F.₀</a> <a id="14140" href="Cat.Functor.Kan.html#13712" class="Bound">x</a><a id="14141" class="Symbol">)</a>
      <a id="14149" href="Cat.Functor.Kan.html#14122" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
E .Hom (colim (diagram colim F K (F₀ K x)) .bot .coapex) (₀ F x)" class="Function">to</a> <a id="14152" class="Symbol">=</a> <a id="14154" href="Cat.Functor.Kan.html#6936" class="Bound">colim</a> <a id="14160" class="Symbol">_</a> <a id="14162" class="Symbol">.</a><a id="14163" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="14168" href="Cat.Functor.Kan.html#13759" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
Cocone (diagram colim F K (F₀ K x))" class="Function">cocone′</a> <a id="14176" class="Symbol">.</a><a id="14177" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="14184" class="Symbol">.</a><a id="14185" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a>

      <a id="14196" href="Cat.Functor.Kan.html#14196" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
E ._∘_ (cocomplete→lan colim F K .eta .η x) (to colim F K ff x) ≡
E .id" class="Function">invl</a> <a id="14201" class="Symbol">:</a> <a id="14203" href="Cat.Functor.Kan.html#8564" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">cocomplete→lan</a> <a id="14218" class="Symbol">.</a><a id="14219" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a> <a id="14223" class="Symbol">.</a><a id="14224" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="14226" href="Cat.Functor.Kan.html#13712" class="Bound">x</a> <a id="14228" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">E.∘</a> <a id="14232" href="Cat.Functor.Kan.html#14122" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
E .Hom (colim (diagram colim F K (F₀ K x)) .bot .coapex) (₀ F x)" class="Function">to</a> <a id="14235" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="14237" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">E.id</a>
      <a id="14248" href="Cat.Functor.Kan.html#14196" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
E ._∘_ (cocomplete→lan colim F K .eta .η x) (to colim F K ff x) ≡
E .id" class="Function">invl</a> <a id="14253" class="Symbol">=</a> <a id="14255" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="14258" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a> <a id="14262" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="14264" href="1Lab.HLevel.html#3818" data-type="is-contr A → is-prop A" class="Function">is-contr→is-prop</a>
        <a id="14289" class="Symbol">(</a><a id="14290" href="Cat.Functor.Kan.html#6936" class="Bound">colim</a> <a id="14296" class="Symbol">_</a> <a id="14298" class="Symbol">.</a><a id="14299" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="14304" class="Symbol">(</a><a id="14305" href="Cat.Functor.Kan.html#6936" class="Bound">colim</a> <a id="14311" class="Symbol">(</a><a id="14312" href="Cat.Functor.Kan.html#6968" class="Bound">F</a> <a id="14314" href="Cat.Base.html#9697" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="14317" href="Cat.Instances.Comma.html#5380" data-type="(F : Functor A C) (G : Functor B₁ C) → Functor (F ↓ G) A" class="Function">Dom</a> <a id="14321" href="Cat.Functor.Kan.html#6988" class="Bound">K</a> <a id="14323" class="Symbol">(</a><a id="14324" href="Cat.Instances.Shape.Terminal.html#558" data-type="Ob A → Functor ⊤Cat A" class="Function">const!</a> <a id="14331" class="Symbol">_))</a> <a id="14335" class="Symbol">.</a><a id="14336" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a><a id="14339" class="Symbol">))</a>
        <a id="14350" class="Symbol">(</a><a id="14351" href="Cat.Diagram.Colimit.Base.html#4170" data-type="(hom : C .Hom (x .coapex) (y .coapex))
(commutes : (o : J₁ .Ob) → C ._∘_ hom (x .ψ o) ≡ y .ψ o) →
Cocone-hom F x y" class="InductiveConstructor">cocone-hom</a> <a id="14362" class="Symbol">_</a> <a id="14364" class="Symbol">λ</a> <a id="14366" href="Cat.Functor.Kan.html#14366" class="Bound">o</a> <a id="14368" class="Symbol">→</a>
            <a id="14382" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">E.pullr</a> <a id="14390" class="Symbol">(</a><a id="14391" href="Cat.Functor.Kan.html#6936" class="Bound">colim</a> <a id="14397" class="Symbol">_</a> <a id="14399" class="Symbol">.</a><a id="14400" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="14405" href="Cat.Functor.Kan.html#13759" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
Cocone (diagram colim F K (F₀ K x))" class="Function">cocone′</a> <a id="14413" class="Symbol">.</a><a id="14414" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="14421" class="Symbol">.</a><a id="14422" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="14431" class="Symbol">_)</a>
          <a id="14444" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="14446" href="Cat.Functor.Kan.html#6936" class="Bound">colim</a> <a id="14452" class="Symbol">_</a> <a id="14454" class="Symbol">.</a><a id="14455" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="14459" class="Symbol">.</a><a id="14460" href="Cat.Diagram.Colimit.Base.html#3115" data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" class="Field">commutes</a>
              <a id="14483" class="Symbol">(</a><a id="14484" class="Keyword">record</a> <a id="14491" class="Symbol">{</a> <a id="14493" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">sq</a> <a id="14496" class="Symbol">=</a> <a id="14498" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="14501" class="Symbol">(</a><a id="14502" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a> <a id="14507" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘_</a><a id="14511" class="Symbol">)</a> <a id="14513" class="Symbol">(</a><a id="14514" href="1Lab.Equiv.html#6548" data-type="(eqv₁ : is-equiv f) → is-right-inverse (equiv→inverse eqv₁) f" class="Function">equiv→section</a> <a id="14528" href="Cat.Functor.Kan.html#13576" class="Bound">ff</a> <a id="14531" class="Symbol">_)</a> <a id="14534" class="Symbol">}))</a>
        <a id="14546" class="Symbol">(</a><a id="14547" href="Cat.Diagram.Colimit.Base.html#4170" data-type="(hom : C .Hom (x .coapex) (y .coapex))
(commutes : (o : J₁ .Ob) → C ._∘_ hom (x .ψ o) ≡ y .ψ o) →
Cocone-hom F x y" class="InductiveConstructor">cocone-hom</a> <a id="14558" class="Symbol">_</a> <a id="14560" class="Symbol">λ</a> <a id="14562" href="Cat.Functor.Kan.html#14562" class="Bound">o</a> <a id="14564" class="Symbol">→</a> <a id="14566" href="Cat.Base.html#3482" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" class="Function">E.idl</a> <a id="14572" class="Symbol">_)</a>

      <a id="14582" href="Cat.Functor.Kan.html#14582" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
E ._∘_ (to colim F K ff x) (cocomplete→lan colim F K .eta .η x) ≡
E .id" class="Function">invr</a> <a id="14587" class="Symbol">:</a> <a id="14589" href="Cat.Functor.Kan.html#14122" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
E .Hom (colim (diagram colim F K (F₀ K x)) .bot .coapex) (₀ F x)" class="Function">to</a> <a id="14592" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">E.∘</a> <a id="14596" href="Cat.Functor.Kan.html#8564" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">cocomplete→lan</a> <a id="14611" class="Symbol">.</a><a id="14612" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a> <a id="14616" class="Symbol">.</a><a id="14617" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="14619" href="Cat.Functor.Kan.html#13712" class="Bound">x</a> <a id="14621" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="14623" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">E.id</a>
      <a id="14634" href="Cat.Functor.Kan.html#14582" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
E ._∘_ (to colim F K ff x) (cocomplete→lan colim F K .eta .η x) ≡
E .id" class="Function">invr</a> <a id="14639" class="Symbol">=</a> <a id="14641" href="Cat.Functor.Kan.html#6936" class="Bound">colim</a> <a id="14647" class="Symbol">_</a> <a id="14649" class="Symbol">.</a><a id="14650" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="14655" href="Cat.Functor.Kan.html#13759" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
Cocone (diagram colim F K (F₀ K x))" class="Function">cocone′</a> <a id="14663" class="Symbol">.</a><a id="14664" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="14671" class="Symbol">.</a><a id="14672" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="14681" class="Symbol">_</a>
           <a id="14694" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="14696" href="Cat.Functor.Reasoning.html#887" data-type="(F : Functor 𝒞 𝒟) (a≡id : a ≡ id F) → F₁ F a ≡ id F" class="Function">F.elim</a> <a id="14703" class="Symbol">(</a><a id="14704" href="Cat.Functor.Base.html#1212" data-type="is-fully-faithful F → is-faithful F" class="Function">fully-faithful→faithful</a> <a id="14728" class="Symbol">{</a><a id="14729" class="Argument">F</a> <a id="14731" class="Symbol">=</a> <a id="14733" href="Cat.Functor.Kan.html#6988" class="Bound">K</a><a id="14734" class="Symbol">}</a> <a id="14736" href="Cat.Functor.Kan.html#13576" class="Bound">ff</a>
                      <a id="14761" class="Symbol">(</a><a id="14762" href="1Lab.Equiv.html#6548" data-type="(eqv₁ : is-equiv f) → is-right-inverse (equiv→inverse eqv₁) f" class="Function">equiv→section</a> <a id="14776" href="Cat.Functor.Kan.html#13576" class="Bound">ff</a> <a id="14779" class="Symbol">_</a> <a id="14781" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="14783" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="14787" href="Cat.Base.html#8343" data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" class="Field">K.F-id</a><a id="14793" class="Symbol">))</a>

    <a id="14801" href="Cat.Functor.Kan.html#14801" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) →
is-invertible Cat[ C , E ] (cocomplete→lan colim F K .eta)" class="Function">inv</a> <a id="14805" class="Symbol">:</a> <a id="14807" href="Cat.Morphism.html#1930" data-type="(C : Precategory o h) (f : Hom C a b) → Type h" class="Record">Fn.is-invertible</a> <a id="14824" class="Symbol">(</a><a id="14825" href="Cat.Functor.Kan.html#8564" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">cocomplete→lan</a> <a id="14840" class="Symbol">.</a><a id="14841" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a><a id="14844" class="Symbol">)</a>
    <a id="14850" href="Cat.Functor.Kan.html#14801" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) →
is-invertible Cat[ C , E ] (cocomplete→lan colim F K .eta)" class="Function">inv</a> <a id="14854" class="Symbol">=</a> <a id="14856" href="Cat.Instances.Functor.html#8554" data-type="(eta : F =&gt; G) →
((x : C .Ob) → is-invertible D (eta .η x)) →
is-invertible Cat[ C , D ] eta" class="Function">componentwise-invertible→invertible</a> <a id="14892" class="Symbol">(</a><a id="14893" href="Cat.Functor.Kan.html#8564" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">cocomplete→lan</a> <a id="14908" class="Symbol">.</a><a id="14909" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a><a id="14912" class="Symbol">)</a> <a id="14914" href="Cat.Functor.Kan.html#13647" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
is-fully-faithful K →
(x : C .Ob) → is-invertible E (cocomplete→lan colim F K .eta .η x)" class="Function">inv′</a>
</pre>
  </article>
</div>
</main>
</body>
</html>
