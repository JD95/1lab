<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>Cat.Functor.Kan - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Cat.Functor.Kan - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="Cat.Functor.Kan - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script defer src="/main.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

  <!-- Google font embeds -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&amp;family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">Cat.Functor.Kan</a>
              </h3>

      <!-- Cube logo -->
      <a id="logo" href="/">
        <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />
      </a>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#kan-extensions"><a href="#kan-extensions" class="header-link">Kan extensions<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#ubiquity"><a href="#ubiquity" class="header-link">Ubiquity<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#a-formula"><a href="#a-formula" class="header-link">A formula<span class="header-link-emoji">🔗</span></a></a></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>

        <!-- Sidebar footnotes control -->
        <span class="inline-footnotes" style="display: none; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-fns" type="checkbox" class="inline-footnotes" id="sidebar-fns">
          <label for="sidebar-fns">Inline Footnotes</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
        <div class="search-form search-form-proxy" role="form">
          <input id="search-box-proxy" type_="text" placeholder="Search..." autocomplete="off" tabindex="0"></input>
        </div>

              <a href="/">back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/de8ff879b97ced1c0fe8e004a61a0316c5325086/src/Cat/Functor/Kan.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao and Naïm Favier</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="/">back to index</a>
      </div>
      
      <!-- Navbar equations control -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>

      <!-- Navbar footnotes control -->
      <span class="inline-footnotes" style="display: none; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-fns" type="checkbox" class="inline-footnotes" id="navbar-fns">
        <label for="navbar-fns">Inline Footnotes</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="Cat.Instances.Shape.Terminal.html" class="Module">Cat.Instances.Shape.Terminal</a>
<a id="50" class="Keyword">open</a> <a id="55" class="Keyword">import</a> <a id="62" href="Cat.Diagram.Colimit.Base.html" class="Module">Cat.Diagram.Colimit.Base</a>
<a id="87" class="Keyword">open</a> <a id="92" class="Keyword">import</a> <a id="99" href="Cat.Instances.Functor.html" class="Module">Cat.Instances.Functor</a>
<a id="121" class="Keyword">open</a> <a id="126" class="Keyword">import</a> <a id="133" href="Cat.Diagram.Initial.html" class="Module">Cat.Diagram.Initial</a>
<a id="153" class="Keyword">open</a> <a id="158" class="Keyword">import</a> <a id="165" href="Cat.Functor.Adjoint.html" class="Module">Cat.Functor.Adjoint</a>
<a id="185" class="Keyword">open</a> <a id="190" class="Keyword">import</a> <a id="197" href="Cat.Instances.Comma.html" class="Module">Cat.Instances.Comma</a>
<a id="217" class="Keyword">open</a> <a id="222" class="Keyword">import</a> <a id="229" href="Cat.Functor.Base.html" class="Module">Cat.Functor.Base</a>
<a id="246" class="Keyword">open</a> <a id="251" class="Keyword">import</a> <a id="258" href="Cat.Prelude.html" class="Module">Cat.Prelude</a>

<a id="271" class="Keyword">import</a> <a id="278" href="Cat.Functor.Reasoning.html" class="Module">Cat.Functor.Reasoning</a> <a id="300" class="Symbol">as</a> <a id="303" class="Module">Func</a>
<a id="308" class="Keyword">import</a> <a id="315" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="329" class="Symbol">as</a> <a id="332" class="Module">Cat</a>

<a id="337" class="Keyword">module</a> <a id="344" href="Cat.Functor.Kan.html" class="Module">Cat.Functor.Kan</a> <a id="360" class="Keyword">where</a>
</pre>
<!--
<pre class="Agda"><a id="384" class="Keyword">private</a>
  <a id="394" class="Keyword">variable</a>
    <a id="407" href="Cat.Functor.Kan.html#407" class="Generalizable">o</a> <a id="409" href="Cat.Functor.Kan.html#409" class="Generalizable">ℓ</a> <a id="411" class="Symbol">:</a> <a id="413" href="Agda.Primitive.html#597" data-type="Type" class="Postulate">Level</a>
    <a id="423" href="Cat.Functor.Kan.html#423" class="Generalizable">C</a> <a id="425" href="Cat.Functor.Kan.html#425" class="Generalizable">C′</a> <a id="428" href="Cat.Functor.Kan.html#428" class="Generalizable">D</a> <a id="430" class="Symbol">:</a> <a id="432" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="444" href="Cat.Functor.Kan.html#407" class="Generalizable">o</a> <a id="446" href="Cat.Functor.Kan.html#409" class="Generalizable">ℓ</a>
  <a id="kan-lvl"></a><a id="450" href="Cat.Functor.Kan.html#450" class="Function">kan-lvl</a> <a id="458" class="Symbol">:</a> <a id="460" class="Symbol">∀</a> <a id="462" class="Symbol">{</a><a id="463" href="Cat.Functor.Kan.html#463" class="Bound">o</a> <a id="465" href="Cat.Functor.Kan.html#465" class="Bound">ℓ</a> <a id="467" href="Cat.Functor.Kan.html#467" class="Bound">o′</a> <a id="470" href="Cat.Functor.Kan.html#470" class="Bound">ℓ′</a> <a id="473" href="Cat.Functor.Kan.html#473" class="Bound">o′′</a> <a id="477" href="Cat.Functor.Kan.html#477" class="Bound">ℓ′′</a><a id="480" class="Symbol">}</a> <a id="482" class="Symbol">{</a><a id="483" href="Cat.Functor.Kan.html#483" class="Bound">C</a> <a id="485" class="Symbol">:</a> <a id="487" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="499" href="Cat.Functor.Kan.html#463" class="Bound">o</a> <a id="501" href="Cat.Functor.Kan.html#465" class="Bound">ℓ</a><a id="502" class="Symbol">}</a> <a id="504" class="Symbol">{</a><a id="505" href="Cat.Functor.Kan.html#505" class="Bound">C′</a> <a id="508" class="Symbol">:</a> <a id="510" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="522" href="Cat.Functor.Kan.html#467" class="Bound">o′</a> <a id="525" href="Cat.Functor.Kan.html#470" class="Bound">ℓ′</a><a id="527" class="Symbol">}</a> <a id="529" class="Symbol">{</a><a id="530" href="Cat.Functor.Kan.html#530" class="Bound">D</a> <a id="532" class="Symbol">:</a> <a id="534" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="546" href="Cat.Functor.Kan.html#473" class="Bound">o′′</a> <a id="550" href="Cat.Functor.Kan.html#477" class="Bound">ℓ′′</a><a id="553" class="Symbol">}</a>
          <a id="565" class="Symbol">→</a> <a id="567" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="575" href="Cat.Functor.Kan.html#483" class="Bound">C</a> <a id="577" href="Cat.Functor.Kan.html#530" class="Bound">D</a> <a id="579" class="Symbol">→</a> <a id="581" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="589" href="Cat.Functor.Kan.html#483" class="Bound">C</a> <a id="591" href="Cat.Functor.Kan.html#505" class="Bound">C′</a> <a id="594" class="Symbol">→</a> <a id="596" href="Agda.Primitive.html#597" data-type="Type" class="Postulate">Level</a>
  <a id="604" href="Cat.Functor.Kan.html#450" class="Function">kan-lvl</a> <a id="612" class="Symbol">{</a><a id="613" href="Cat.Functor.Kan.html#613" class="Bound">a</a><a id="614" class="Symbol">}</a> <a id="616" class="Symbol">{</a><a id="617" href="Cat.Functor.Kan.html#617" class="Bound">b</a><a id="618" class="Symbol">}</a> <a id="620" class="Symbol">{</a><a id="621" href="Cat.Functor.Kan.html#621" class="Bound">c</a><a id="622" class="Symbol">}</a> <a id="624" class="Symbol">{</a><a id="625" href="Cat.Functor.Kan.html#625" class="Bound">d</a><a id="626" class="Symbol">}</a> <a id="628" class="Symbol">{</a><a id="629" href="Cat.Functor.Kan.html#629" class="Bound">e</a><a id="630" class="Symbol">}</a> <a id="632" class="Symbol">{</a><a id="633" href="Cat.Functor.Kan.html#633" class="Bound">f</a><a id="634" class="Symbol">}</a> <a id="636" class="Symbol">_</a> <a id="638" class="Symbol">_</a> <a id="640" class="Symbol">=</a> <a id="642" href="Cat.Functor.Kan.html#613" class="Bound">a</a> <a id="644" href="Agda.Primitive.html#810" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="646" href="Cat.Functor.Kan.html#617" class="Bound">b</a> <a id="648" href="Agda.Primitive.html#810" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="650" href="Cat.Functor.Kan.html#621" class="Bound">c</a> <a id="652" href="Agda.Primitive.html#810" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="654" href="Cat.Functor.Kan.html#625" class="Bound">d</a> <a id="656" href="Agda.Primitive.html#810" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="658" href="Cat.Functor.Kan.html#629" class="Bound">e</a> <a id="660" href="Agda.Primitive.html#810" data-type="Level → Level → Level" class="Primitive Operator">⊔</a> <a id="662" href="Cat.Functor.Kan.html#633" class="Bound">f</a>
</pre>-->
<h1 id="kan-extensions"><a href="#kan-extensions" class="header-link">Kan extensions<span class="header-link-emoji">🔗</span></a></h1>
<p>Suppose we have a functor <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi mathvariant="script">C</mi><mo>→</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">F : \ca{C} \to \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>,</span> and a functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>:</mo><mi mathvariant="script">C</mi><mo>→</mo><msup><mi mathvariant="script">C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">p : \ca{C} \to \ca{C}&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> — perhaps to be thought of as a <a href="Cat.Functor.FullSubcategory.html">full subcategory</a> inclusion, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="script">C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">\ca{C}&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> is a completion of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>,</span> but the situation applies just as well to any pair of functors — which naturally fit into a commutative diagram</p>
<div class="diagram-container">
<img src="6a32e823706fad23aaaa018b81e7575133a4f0dc.svg" title="commutative diagram" class="diagram quiver" />
</div>
<p>but as we can see this is a particularly sad commutative diagram; it’s crying out for a third edge <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="script">C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>→</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\ca{C}&#39; \to \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span></p>
<div class="diagram-container">
<img src="835eef6d4aa8e64f94cef52f789dacbb0d6419b8.svg" title="commutative diagram" class="diagram quiver" />
</div>
<p>extending <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> to a functor <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="script">C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>→</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\ca{C}&#39; \to \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>.</span> If there exists an <em>universal</em> such extension (we’ll define what “universal” means in just a second), we call it the <strong>left Kan extension</strong> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> along <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>,</span> and denote it <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mi>p</mi></msub><mi>F</mi></mrow><annotation encoding="application/x-tex">\Lan_p F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Lan</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>.</span> Such extensions do not come for free (in a sense they’re pretty hard to come by), but concept of Kan extension can be used to rephrase the definition of both <a href="Cat.Diagram.Limit.Base.html">limit</a> and <a href="Cat.Functor.Adjoint.html">adjoint functor</a>.</p>
<p>A left Kan extension <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mi>p</mi></msub><mi>F</mi></mrow><annotation encoding="application/x-tex">\Lan_p F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Lan</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> is equipped with a natural transformation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi><mo>:</mo><mi>F</mi><mo>⇒</mo><msub><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mi>p</mi></msub><mi>F</mi><mo>∘</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">\eta : F \To \Lan_p F \circ p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Lan</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> witnessing the (“directed”) commutativity of the triangle (so that it need not commute on-the-nose) which is universal among such transformations; Meaning that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>:</mo><msup><mi mathvariant="script">C</mi><mo mathvariant="script" lspace="0em" rspace="0em">′</mo></msup><mo>→</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">M : \ca{C&#39;} \to \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span> is another functor with a transformation <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>:</mo><mi>M</mi><mo>⇒</mo><mi>M</mi><mo>∘</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">\alpha : M \To M \circ p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>,</span> there is a unique natural transformation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo>:</mo><msub><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mi>p</mi></msub><mi>F</mi><mo>⇒</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\sigma : \Lan_p F \To M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Lan</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> which commutes with <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>.</span></p>
<p>Note that in general the triangle commutes “weakly”, but when <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> is <a href="Cat.Functor.Base.html#ff-functors">fully faithful</a> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span> is <a href="Cat.Diagram.Colimit.Base.html#cocompleteness">cocomplete</a>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mi>p</mi></msub><mi>F</mi></mrow><annotation encoding="application/x-tex">\Lan_p F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Lan</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> genuinely extends <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>,</span> in that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span> is a natural isomorphism.</p>
<pre class="Agda"><a id="2831" class="Keyword">record</a> <a id="Lan"></a><a id="2838" href="Cat.Functor.Kan.html#2838" data-type="(p : Functor C C′) (F : Functor C D) →
Type (C.o ⊔ C.ℓ ⊔ C′.o ⊔ C′.ℓ ⊔ D.o ⊔ D.ℓ)" class="Record">Lan</a> <a id="2842" class="Symbol">(</a><a id="2843" href="Cat.Functor.Kan.html#2843" class="Bound">p</a> <a id="2845" class="Symbol">:</a> <a id="2847" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="2855" href="Cat.Functor.Kan.html#423" class="Generalizable">C</a> <a id="2857" href="Cat.Functor.Kan.html#425" class="Generalizable">C′</a><a id="2859" class="Symbol">)</a> <a id="2861" class="Symbol">(</a><a id="2862" href="Cat.Functor.Kan.html#2862" class="Bound">F</a> <a id="2864" class="Symbol">:</a> <a id="2866" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="2874" href="Cat.Functor.Kan.html#423" class="Generalizable">C</a> <a id="2876" href="Cat.Functor.Kan.html#428" class="Generalizable">D</a><a id="2877" class="Symbol">)</a> <a id="2879" class="Symbol">:</a> <a id="2881" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2886" class="Symbol">(</a><a id="2887" href="Cat.Functor.Kan.html#450" class="Function">kan-lvl</a> <a id="2895" href="Cat.Functor.Kan.html#2843" class="Bound">p</a> <a id="2897" href="Cat.Functor.Kan.html#2862" class="Bound">F</a><a id="2898" class="Symbol">)</a> <a id="2900" class="Keyword">where</a>
  <a id="2908" class="Keyword">field</a>
    <a id="Lan.Ext"></a><a id="2918" href="Cat.Functor.Kan.html#2918" data-type="Lan p F → Functor C′ D" class="Field">Ext</a> <a id="2922" class="Symbol">:</a> <a id="2924" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="2932" href="Cat.Functor.Kan.html#2857" class="Bound">C′</a> <a id="2935" href="Cat.Functor.Kan.html#2876" class="Bound">D</a>
    <a id="Lan.eta"></a><a id="2941" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a> <a id="2945" class="Symbol">:</a> <a id="2947" href="Cat.Functor.Kan.html#2862" class="Bound">F</a> <a id="2949" href="Cat.Base.html#12241" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Record Operator">=&gt;</a> <a id="2952" href="Cat.Functor.Kan.html#2918" data-type="Lan p F → Functor C′ D" class="Field">Ext</a> <a id="2956" href="Cat.Base.html#9697" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="2959" href="Cat.Functor.Kan.html#2843" class="Bound">p</a>
</pre>
<p>Universality of <span class="Agda"><a href="Cat.Functor.Kan.html#2941" class="Field">eta</a></span> is witnessed by the following fields, which essentially say that, in the diagram below (assuming <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> has a natural transformation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> witnessing the same “directed commutativity” that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span> does for <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mi>p</mi></msub><mi>F</mi></mrow><annotation encoding="application/x-tex">\Lan_p F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Lan</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>),</span> the 2-cell exists and is unique.</p>
<div class="diagram-container">
<img src="f0ea9b4df8662303a1afd8dcde622d9329c08d48.svg" title="commutative diagram" class="diagram quiver" />
</div>
<pre class="Agda">    <a id="Lan.σ"></a><a id="3692" href="Cat.Functor.Kan.html#3692" data-type="(r : Lan p F) → F =&gt; M F∘ p → r .Ext =&gt; M" class="Field">σ</a> <a id="3694" class="Symbol">:</a> <a id="3696" class="Symbol">{</a><a id="3697" href="Cat.Functor.Kan.html#3697" class="Bound">M</a> <a id="3699" class="Symbol">:</a> <a id="3701" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="3709" href="Cat.Functor.Kan.html#2857" class="Bound">C′</a> <a id="3712" href="Cat.Functor.Kan.html#2876" class="Bound">D</a><a id="3713" class="Symbol">}</a> <a id="3715" class="Symbol">(</a><a id="3716" href="Cat.Functor.Kan.html#3716" class="Bound">α</a> <a id="3718" class="Symbol">:</a> <a id="3720" href="Cat.Functor.Kan.html#2862" class="Bound">F</a> <a id="3722" href="Cat.Base.html#12241" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Record Operator">=&gt;</a> <a id="3725" href="Cat.Functor.Kan.html#3697" class="Bound">M</a> <a id="3727" href="Cat.Base.html#9697" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="3730" href="Cat.Functor.Kan.html#2843" class="Bound">p</a><a id="3731" class="Symbol">)</a> <a id="3733" class="Symbol">→</a> <a id="3735" href="Cat.Functor.Kan.html#2918" data-type="Lan p F → Functor C′ D" class="Field">Ext</a> <a id="3739" href="Cat.Base.html#12241" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Record Operator">=&gt;</a> <a id="3742" href="Cat.Functor.Kan.html#3697" class="Bound">M</a>
    <a id="Lan.σ-comm"></a><a id="3748" href="Cat.Functor.Kan.html#3748" data-type="(r : Lan p F) → (whiskerl (r .σ α) ∘nt r .eta) ≡ α" class="Field">σ-comm</a> <a id="3755" class="Symbol">:</a> <a id="3757" class="Symbol">{</a><a id="3758" href="Cat.Functor.Kan.html#3758" class="Bound">M</a> <a id="3760" class="Symbol">:</a> <a id="3762" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="3770" href="Cat.Functor.Kan.html#2857" class="Bound">C′</a> <a id="3773" href="Cat.Functor.Kan.html#2876" class="Bound">D</a><a id="3774" class="Symbol">}</a> <a id="3776" class="Symbol">{</a><a id="3777" href="Cat.Functor.Kan.html#3777" class="Bound">α</a> <a id="3779" class="Symbol">:</a> <a id="3781" href="Cat.Functor.Kan.html#2862" class="Bound">F</a> <a id="3783" href="Cat.Base.html#12241" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Record Operator">=&gt;</a> <a id="3786" href="Cat.Functor.Kan.html#3758" class="Bound">M</a> <a id="3788" href="Cat.Base.html#9697" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="3791" href="Cat.Functor.Kan.html#2843" class="Bound">p</a><a id="3792" class="Symbol">}</a> <a id="3794" class="Symbol">→</a> <a id="3796" href="Cat.Instances.Functor.html#13532" data-type="F =&gt; G → F F∘ H =&gt; G F∘ H" class="Function">whiskerl</a> <a id="3805" class="Symbol">(</a><a id="3806" href="Cat.Functor.Kan.html#3692" data-type="(r : Lan p F) → F =&gt; M F∘ p → r .Ext =&gt; M" class="Field">σ</a> <a id="3808" href="Cat.Functor.Kan.html#3777" class="Bound">α</a><a id="3809" class="Symbol">)</a> <a id="3811" href="Cat.Instances.Functor.html#890" data-type="G =&gt; H → F =&gt; G → F =&gt; H" class="Function Operator">∘nt</a> <a id="3815" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a> <a id="3819" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3821" href="Cat.Functor.Kan.html#3777" class="Bound">α</a>
    <a id="Lan.σ-uniq"></a><a id="3827" href="Cat.Functor.Kan.html#3827" data-type="(r : Lan p F) → α ≡ (whiskerl σ′ ∘nt r .eta) → r .σ α ≡ σ′" class="Field">σ-uniq</a> <a id="3834" class="Symbol">:</a> <a id="3836" class="Symbol">{</a><a id="3837" href="Cat.Functor.Kan.html#3837" class="Bound">M</a> <a id="3839" class="Symbol">:</a> <a id="3841" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="3849" href="Cat.Functor.Kan.html#2857" class="Bound">C′</a> <a id="3852" href="Cat.Functor.Kan.html#2876" class="Bound">D</a><a id="3853" class="Symbol">}</a> <a id="3855" class="Symbol">{</a><a id="3856" href="Cat.Functor.Kan.html#3856" class="Bound">α</a> <a id="3858" class="Symbol">:</a> <a id="3860" href="Cat.Functor.Kan.html#2862" class="Bound">F</a> <a id="3862" href="Cat.Base.html#12241" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Record Operator">=&gt;</a> <a id="3865" href="Cat.Functor.Kan.html#3837" class="Bound">M</a> <a id="3867" href="Cat.Base.html#9697" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="3870" href="Cat.Functor.Kan.html#2843" class="Bound">p</a><a id="3871" class="Symbol">}</a> <a id="3873" class="Symbol">{</a><a id="3874" href="Cat.Functor.Kan.html#3874" class="Bound">σ′</a> <a id="3877" class="Symbol">:</a> <a id="3879" href="Cat.Functor.Kan.html#2918" data-type="Lan p F → Functor C′ D" class="Field">Ext</a> <a id="3883" href="Cat.Base.html#12241" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Record Operator">=&gt;</a> <a id="3886" href="Cat.Functor.Kan.html#3837" class="Bound">M</a><a id="3887" class="Symbol">}</a>
           <a id="3900" class="Symbol">→</a> <a id="3902" href="Cat.Functor.Kan.html#3856" class="Bound">α</a> <a id="3904" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3906" href="Cat.Instances.Functor.html#13532" data-type="F =&gt; G → F F∘ H =&gt; G F∘ H" class="Function">whiskerl</a> <a id="3915" href="Cat.Functor.Kan.html#3874" class="Bound">σ′</a> <a id="3918" href="Cat.Instances.Functor.html#890" data-type="G =&gt; H → F =&gt; G → F =&gt; H" class="Function Operator">∘nt</a> <a id="3922" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a>
           <a id="3937" class="Symbol">→</a> <a id="3939" href="Cat.Functor.Kan.html#3692" data-type="(r : Lan p F) → F =&gt; M F∘ p → r .Ext =&gt; M" class="Field">σ</a> <a id="3941" href="Cat.Functor.Kan.html#3856" class="Bound">α</a> <a id="3943" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="3945" href="Cat.Functor.Kan.html#3874" class="Bound">σ′</a>
</pre>
<h2 id="ubiquity"><a href="#ubiquity" class="header-link">Ubiquity<span class="header-link-emoji">🔗</span></a></h2>
<p>The elevator pitch for Kan extensions is that “all concepts are Kan extensions”. The example we will give here is that, if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>⊣</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">F \dashv G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> is an adjunction, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mi>η</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(G, \eta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span><span class="mclose">)</span></span></span></span> gives <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mi>F</mi></msub><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">d</mi></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Lan_F(\id{Id})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Lan</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">Id</span></span><span class="mclose">)</span></span></span></span>.</span> This isn’t exactly enlightening: adjunctions and Kan extensions have very different vibes, but the latter concept <em>is</em> a legitimate generalisation.</p>
<!--
<pre class="Agda"><a id="4324" class="Keyword">module</a> <a id="4331" href="Cat.Functor.Kan.html#4331" class="Module">_</a> <a id="4333" class="Symbol">{</a><a id="4334" href="Cat.Functor.Kan.html#4334" class="Bound">F</a> <a id="4336" class="Symbol">:</a> <a id="4338" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="4346" href="Cat.Functor.Kan.html#423" class="Generalizable">C</a> <a id="4348" href="Cat.Functor.Kan.html#428" class="Generalizable">D</a><a id="4349" class="Symbol">}</a> <a id="4351" class="Symbol">{</a><a id="4352" href="Cat.Functor.Kan.html#4352" class="Bound">G</a> <a id="4354" class="Symbol">:</a> <a id="4356" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="4364" href="Cat.Functor.Kan.html#428" class="Generalizable">D</a> <a id="4366" href="Cat.Functor.Kan.html#423" class="Generalizable">C</a><a id="4367" class="Symbol">}</a> <a id="4369" class="Symbol">(</a><a id="4370" href="Cat.Functor.Kan.html#4370" class="Bound">adj</a> <a id="4374" class="Symbol">:</a> <a id="4376" href="Cat.Functor.Kan.html#4334" class="Bound">F</a> <a id="4378" href="Cat.Functor.Adjoint.html#1933" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Record Operator">⊣</a> <a id="4380" href="Cat.Functor.Kan.html#4352" class="Bound">G</a><a id="4381" class="Symbol">)</a> <a id="4383" class="Keyword">where</a>
  <a id="4391" class="Keyword">open</a> <a id="4396" href="Cat.Functor.Kan.html#2838" data-type="(p : Functor C C′) (F : Functor C D) →
Type (C.o ⊔ C.ℓ ⊔ C′.o ⊔ C′.ℓ ⊔ D.o ⊔ D.ℓ)" class="Module">Lan</a>
  <a id="4402" class="Keyword">private</a>
    <a id="4414" class="Keyword">module</a> <a id="4421" href="Cat.Functor.Kan.html#4421" class="Module">F</a> <a id="4423" class="Symbol">=</a> <a id="4425" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Module">Functor</a> <a id="4433" href="Cat.Functor.Kan.html#4334" class="Bound">F</a>
    <a id="4439" class="Keyword">module</a> <a id="4446" href="Cat.Functor.Kan.html#4446" class="Module">G</a> <a id="4448" class="Symbol">=</a> <a id="4450" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Module">Functor</a> <a id="4458" href="Cat.Functor.Kan.html#4352" class="Bound">G</a>
    <a id="4464" class="Keyword">module</a> <a id="4471" href="Cat.Functor.Kan.html#4471" class="Module">C</a> <a id="4473" class="Symbol">=</a> <a id="4475" href="Cat.Reasoning.html" class="Module">Cat</a> <a id="4479" href="Cat.Functor.Kan.html#4346" class="Bound">C</a>
    <a id="4485" class="Keyword">module</a> <a id="4492" href="Cat.Functor.Kan.html#4492" class="Module">D</a> <a id="4494" class="Symbol">=</a> <a id="4496" href="Cat.Reasoning.html" class="Module">Cat</a> <a id="4500" href="Cat.Functor.Kan.html#4348" class="Bound">D</a>
  <a id="4504" class="Keyword">open</a> <a id="4509" href="Cat.Functor.Adjoint.html#1933" data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" class="Module Operator">_⊣_</a> <a id="4513" href="Cat.Functor.Kan.html#4370" class="Bound">adj</a>
  <a id="4519" class="Keyword">open</a> <a id="4524" href="Cat.Base.html#12241" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Module Operator">_=&gt;_</a>
</pre>-->
<pre class="Agda">  <a id="4548" href="Cat.Functor.Kan.html#4548" data-type="(adj : F ⊣ G) → Lan F Id" class="Function">adjoint→lan</a> <a id="4560" class="Symbol">:</a> <a id="4562" href="Cat.Functor.Kan.html#2838" data-type="(p : Functor C C′) (F : Functor C D) →
Type (C.o ⊔ C.ℓ ⊔ C′.o ⊔ C′.ℓ ⊔ D.o ⊔ D.ℓ)" class="Record">Lan</a> <a id="4566" href="Cat.Functor.Kan.html#4334" class="Bound">F</a> <a id="4568" href="Cat.Base.html#11722" data-type="Functor C C" class="Function">Id</a>
  <a id="4573" href="Cat.Functor.Kan.html#4548" data-type="(adj : F ⊣ G) → Lan F Id" class="Function">adjoint→lan</a> <a id="4585" class="Symbol">.</a><a id="4586" href="Cat.Functor.Kan.html#2918" data-type="Lan p F → Functor C′ D" class="Field">Ext</a> <a id="4590" class="Symbol">=</a> <a id="4592" href="Cat.Functor.Kan.html#4352" class="Bound">G</a>
  <a id="4596" href="Cat.Functor.Kan.html#4548" data-type="(adj : F ⊣ G) → Lan F Id" class="Function">adjoint→lan</a> <a id="4608" class="Symbol">.</a><a id="4609" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a> <a id="4613" class="Symbol">=</a> <a id="4615" href="Cat.Functor.Adjoint.html#2083" data-type="L ⊣ R₁ → Id =&gt; R₁ F∘ L" class="Field">unit</a>
</pre>
<p>The proof is mostly pushing symbols around, and the calculation is available below unabridged. In components, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> must give, assuming a map <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>:</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">d</mi></mrow><mo>⇒</mo><mi>M</mi><mi>F</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\alpha : \id{Id} \To MFx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">Id</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">MF</span><span class="mord mathnormal">x</span></span></span></span>,</span> a map <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>x</mi><mo>→</mo><mi>M</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">Gx \to Mx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">x</span></span></span></span>.</span> The transformation we’re looking for arises as the composite</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>G</mi><mi>x</mi><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mi>α</mi></mpadded></mover><mi>M</mi><mi>F</mi><mi>G</mi><mi>x</mi><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mrow><mi>M</mi><mi>ε</mi></mrow></mpadded></mover><mi>M</mi><mi>x</mi><mtext>,</mtext></mrow><annotation encoding="application/x-tex">
Gx \xto{\alpha} MFGx \xto{M\epsilon} Mx\text{,}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9344em;vertical-align:-0.011em;"></span><span class="mord mathnormal">G</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9234em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1113em;vertical-align:-0.011em;"></span><span class="mord mathnormal">MFG</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1003em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight">Mε</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">x</span><span class="mord text"><span class="mord">,</span></span></span></span></span></span></p>
<p>where uniqueness and commutativity follows from the triangle identities <span class="Agda"><a href="Cat.Functor.Adjoint.html#2684" class="Field">zig</a></span> and <span class="Agda"><a href="Cat.Functor.Adjoint.html#2747" class="Field">zag</a></span>.</p>
<pre class="Agda">  <a id="5050" href="Cat.Functor.Kan.html#4548" data-type="(adj : F ⊣ G) → Lan F Id" class="Function">adjoint→lan</a> <a id="5062" class="Symbol">.</a><a id="5063" href="Cat.Functor.Kan.html#3692" data-type="(r : Lan p F) → F =&gt; M F∘ p → r .Ext =&gt; M" class="Field">σ</a> <a id="5065" class="Symbol">{</a><a id="5066" href="Cat.Functor.Kan.html#5066" class="Bound">M</a><a id="5067" class="Symbol">}</a> <a id="5069" href="Cat.Functor.Kan.html#5069" class="Bound">α</a> <a id="5071" class="Symbol">.</a><a id="5072" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="5074" href="Cat.Functor.Kan.html#5074" class="Bound">x</a> <a id="5076" class="Symbol">=</a> <a id="5078" href="Cat.Functor.Kan.html#5066" class="Bound">M</a> <a id="5080" class="Symbol">.</a><a id="5081" href="Cat.Base.html#8017" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">Functor.F₁</a> <a id="5092" class="Symbol">(</a><a id="5093" href="Cat.Functor.Adjoint.html#2207" class="Function">counit.ε</a> <a id="5102" class="Symbol">_)</a> <a id="5105" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5109" href="Cat.Functor.Kan.html#5069" class="Bound">α</a> <a id="5111" class="Symbol">.</a><a id="5112" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="5114" class="Symbol">(</a><a id="5115" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">G.₀</a> <a id="5119" href="Cat.Functor.Kan.html#5074" class="Bound">x</a><a id="5120" class="Symbol">)</a>
  <a id="5124" href="Cat.Functor.Kan.html#4548" data-type="(adj : F ⊣ G) → Lan F Id" class="Function">adjoint→lan</a> <a id="5136" class="Symbol">.</a><a id="5137" href="Cat.Functor.Kan.html#3692" data-type="(r : Lan p F) → F =&gt; M F∘ p → r .Ext =&gt; M" class="Field">σ</a> <a id="5139" class="Symbol">{</a><a id="5140" href="Cat.Functor.Kan.html#5140" class="Bound">M</a><a id="5141" class="Symbol">}</a> <a id="5143" href="Cat.Functor.Kan.html#5143" class="Bound">nt</a> <a id="5146" class="Symbol">.</a><a id="5147" href="Cat.Base.html#13369" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="5158" href="Cat.Functor.Kan.html#5158" class="Bound">x</a> <a id="5160" href="Cat.Functor.Kan.html#5160" class="Bound">y</a> <a id="5162" href="Cat.Functor.Kan.html#5162" class="Bound">f</a> <a id="5164" class="Symbol">=</a>
    <a id="5170" class="Symbol">(</a><a id="5171" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="5175" class="Symbol">(</a><a id="5176" href="Cat.Functor.Adjoint.html#2207" class="Function">counit.ε</a> <a id="5185" class="Symbol">_)</a> <a id="5188" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5192" href="Cat.Functor.Kan.html#5143" class="Bound">nt</a> <a id="5195" class="Symbol">.</a><a id="5196" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="5198" class="Symbol">_)</a> <a id="5201" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5205" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">G.₁</a> <a id="5209" href="Cat.Functor.Kan.html#5162" class="Bound">f</a>            <a id="5222" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5225" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">C.pullr</a> <a id="5233" class="Symbol">(</a><a id="5234" href="Cat.Functor.Kan.html#5143" class="Bound">nt</a> <a id="5237" class="Symbol">.</a><a id="5238" href="Cat.Base.html#13369" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="5249" class="Symbol">_</a> <a id="5251" class="Symbol">_</a> <a id="5253" class="Symbol">_)</a> <a id="5256" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
    <a id="5262" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="5266" class="Symbol">(</a><a id="5267" href="Cat.Functor.Adjoint.html#2207" class="Function">counit.ε</a> <a id="5276" class="Symbol">_)</a> <a id="5279" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5283" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="5287" class="Symbol">(</a><a id="5288" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">F.₁</a> <a id="5292" class="Symbol">(</a><a id="5293" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">G.₁</a> <a id="5297" href="Cat.Functor.Kan.html#5162" class="Bound">f</a><a id="5298" class="Symbol">))</a> <a id="5301" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5305" href="Cat.Functor.Kan.html#5143" class="Bound">nt</a> <a id="5308" class="Symbol">.</a><a id="5309" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="5311" class="Symbol">_</a>  <a id="5314" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5317" href="Cat.Functor.Reasoning.html#1799" data-type="(F : Functor 𝒞 𝒟) (p : (F ∘ a) c ≡ (F ∘ b) d) →
(F ∘ F₁ F a) ((F ∘ F₁ F c) f) ≡ (F ∘ F₁ F b) ((F ∘ F₁ F d) f)" class="Function">M.extendl</a> <a id="5327" class="Symbol">(</a><a id="5328" href="Cat.Base.html#13369" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Function">counit.is-natural</a> <a id="5346" class="Symbol">_</a> <a id="5348" class="Symbol">_</a> <a id="5350" class="Symbol">_)</a> <a id="5353" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
    <a id="5359" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="5363" href="Cat.Functor.Kan.html#5162" class="Bound">f</a> <a id="5365" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5369" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="5373" class="Symbol">(</a><a id="5374" href="Cat.Functor.Adjoint.html#2207" class="Function">counit.ε</a> <a id="5383" class="Symbol">_)</a> <a id="5386" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5390" href="Cat.Functor.Kan.html#5143" class="Bound">nt</a> <a id="5393" class="Symbol">.</a><a id="5394" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="5396" class="Symbol">_</a>              <a id="5411" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
    <a id="5417" class="Keyword">where</a> <a id="5423" class="Keyword">module</a> <a id="5430" href="Cat.Functor.Kan.html#5430" class="Module">M</a> <a id="5432" class="Symbol">=</a> <a id="5434" href="Cat.Functor.Reasoning.html" class="Module">Func</a> <a id="5439" href="Cat.Functor.Kan.html#5140" class="Bound">M</a>

  <a id="5444" href="Cat.Functor.Kan.html#4548" data-type="(adj : F ⊣ G) → Lan F Id" class="Function">adjoint→lan</a> <a id="5456" class="Symbol">.</a><a id="5457" href="Cat.Functor.Kan.html#3748" data-type="(r : Lan p F) → (whiskerl (r .σ α) ∘nt r .eta) ≡ α" class="Field">σ-comm</a> <a id="5464" class="Symbol">{</a><a id="5465" href="Cat.Functor.Kan.html#5465" class="Bound">M</a><a id="5466" class="Symbol">}</a> <a id="5468" class="Symbol">{</a><a id="5469" href="Cat.Functor.Kan.html#5469" class="Bound">α</a><a id="5470" class="Symbol">}</a> <a id="5472" class="Symbol">=</a> <a id="5474" href="Cat.Base.html#15597" data-type="((x : C .Ob) → a .η x ≡ b .η x) → a ≡ b" class="Function">Nat-path</a> <a id="5483" class="Symbol">λ</a> <a id="5485" href="Cat.Functor.Kan.html#5485" class="Bound">_</a> <a id="5487" class="Symbol">→</a>
    <a id="5493" class="Symbol">(</a><a id="5494" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="5498" class="Symbol">(</a><a id="5499" href="Cat.Functor.Adjoint.html#2207" class="Function">counit.ε</a> <a id="5508" class="Symbol">_)</a> <a id="5511" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5515" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">α.η</a> <a id="5519" class="Symbol">_)</a> <a id="5522" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5526" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">unit.η</a> <a id="5533" class="Symbol">_</a>              <a id="5548" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5551" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">C.pullr</a> <a id="5559" class="Symbol">(</a><a id="5560" href="Cat.Base.html#13369" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">α.is-natural</a> <a id="5573" class="Symbol">_</a> <a id="5575" class="Symbol">_</a> <a id="5577" class="Symbol">_)</a> <a id="5580" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
    <a id="5586" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="5590" class="Symbol">(</a><a id="5591" href="Cat.Functor.Adjoint.html#2207" class="Function">counit.ε</a> <a id="5600" class="Symbol">_)</a> <a id="5603" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5607" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="5611" class="Symbol">(</a><a id="5612" href="Cat.Base.html#8017" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Function">F.F₁</a> <a id="5617" class="Symbol">(</a><a id="5618" href="Cat.Functor.Adjoint.html#2083" data-type="L ⊣ R₁ → Id =&gt; R₁ F∘ L" class="Field">unit</a> <a id="5623" class="Symbol">.</a><a id="5624" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="5626" class="Symbol">_))</a> <a id="5630" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5634" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">α.η</a> <a id="5638" class="Symbol">_</a>  <a id="5641" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5644" href="Cat.Functor.Reasoning.html#2239" data-type="(F : Functor 𝒞 𝒟) (inv₁ : (F ∘ a) b ≡ id F) →
(F ∘ F₁ F a) ((F ∘ F₁ F b) f) ≡ f" class="Function">M.cancell</a> <a id="5654" href="Cat.Functor.Adjoint.html#2684" data-type="(r : L ⊣ R₁) →
D ._∘_ (η (r .counit) (F₀ L A)) (F₁ L (r .unit .η A)) ≡ D .id" class="Field">zig</a> <a id="5658" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
    <a id="5664" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">α.η</a> <a id="5668" class="Symbol">_</a>                                                  <a id="5719" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
    <a id="5725" class="Keyword">where</a> <a id="5731" class="Keyword">module</a> <a id="5738" href="Cat.Functor.Kan.html#5738" class="Module">α</a> <a id="5740" class="Symbol">=</a> <a id="5742" href="Cat.Base.html#12241" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Module Operator">_=&gt;_</a> <a id="5747" href="Cat.Functor.Kan.html#5469" class="Bound">α</a>
          <a id="5759" class="Keyword">module</a> <a id="5766" href="Cat.Functor.Kan.html#5766" class="Module">M</a> <a id="5768" class="Symbol">=</a> <a id="5770" href="Cat.Functor.Reasoning.html" class="Module">Func</a> <a id="5775" href="Cat.Functor.Kan.html#5465" class="Bound">M</a>

  <a id="5780" href="Cat.Functor.Kan.html#4548" data-type="(adj : F ⊣ G) → Lan F Id" class="Function">adjoint→lan</a> <a id="5792" class="Symbol">.</a><a id="5793" href="Cat.Functor.Kan.html#3827" data-type="(r : Lan p F) → α ≡ (whiskerl σ′ ∘nt r .eta) → r .σ α ≡ σ′" class="Field">σ-uniq</a> <a id="5800" class="Symbol">{</a><a id="5801" href="Cat.Functor.Kan.html#5801" class="Bound">M</a><a id="5802" class="Symbol">}</a> <a id="5804" class="Symbol">{</a><a id="5805" href="Cat.Functor.Kan.html#5805" class="Bound">α</a><a id="5806" class="Symbol">}</a> <a id="5808" class="Symbol">{</a><a id="5809" href="Cat.Functor.Kan.html#5809" class="Bound">σ&#39;</a><a id="5811" class="Symbol">}</a> <a id="5813" href="Cat.Functor.Kan.html#5813" class="Bound">p</a> <a id="5815" class="Symbol">=</a> <a id="5817" href="Cat.Base.html#15597" data-type="((x : C .Ob) → a .η x ≡ b .η x) → a ≡ b" class="Function">Nat-path</a> <a id="5826" class="Symbol">λ</a> <a id="5828" href="Cat.Functor.Kan.html#5828" class="Bound">x</a> <a id="5830" class="Symbol">→</a>
    <a id="5836" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="5840" class="Symbol">(</a><a id="5841" href="Cat.Functor.Adjoint.html#2207" class="Function">counit.ε</a> <a id="5850" class="Symbol">_)</a> <a id="5853" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5857" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">α.η</a> <a id="5861" class="Symbol">_</a>                <a id="5878" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5881" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="5884" class="Symbol">(_</a> <a id="5887" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘_</a><a id="5891" class="Symbol">)</a> <a id="5893" class="Symbol">(</a><a id="5894" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="5897" class="Symbol">(λ</a> <a id="5900" href="Cat.Functor.Kan.html#5900" class="Bound">e</a> <a id="5902" class="Symbol">→</a> <a id="5904" href="Cat.Functor.Kan.html#5900" class="Bound">e</a> <a id="5906" class="Symbol">.</a><a id="5907" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="5909" class="Symbol">_)</a> <a id="5912" href="Cat.Functor.Kan.html#5813" class="Bound">p</a><a id="5913" class="Symbol">)</a> <a id="5915" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
    <a id="5921" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="5925" class="Symbol">(</a><a id="5926" href="Cat.Functor.Adjoint.html#2207" class="Function">counit.ε</a> <a id="5935" class="Symbol">_)</a> <a id="5938" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5942" href="Cat.Functor.Kan.html#5809" class="Bound">σ&#39;</a> <a id="5945" class="Symbol">.</a><a id="5946" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="5948" class="Symbol">_</a> <a id="5950" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="5954" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">unit.η</a> <a id="5961" class="Symbol">_</a> <a id="5963" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="5966" href="Cat.Reasoning.html#2007" data-type="(C : Precategory o ℓ) (p : (C ∘ f) h ≡ (C ∘ g) i) →
(C ∘ f) ((C ∘ h) b) ≡ (C ∘ g) ((C ∘ i) b)" class="Function">C.extendl</a> <a id="5976" class="Symbol">(</a><a id="5977" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="5981" class="Symbol">(</a><a id="5982" href="Cat.Functor.Kan.html#5809" class="Bound">σ&#39;</a> <a id="5985" class="Symbol">.</a><a id="5986" href="Cat.Base.html#13369" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="5997" class="Symbol">_</a> <a id="5999" class="Symbol">_</a> <a id="6001" class="Symbol">_))</a> <a id="6005" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
    <a id="6011" href="Cat.Functor.Kan.html#5809" class="Bound">σ&#39;</a> <a id="6014" class="Symbol">.</a><a id="6015" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="6017" class="Symbol">_</a> <a id="6019" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="6023" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">G.₁</a> <a id="6027" class="Symbol">(</a><a id="6028" href="Cat.Functor.Adjoint.html#2207" class="Function">counit.ε</a> <a id="6037" class="Symbol">_)</a> <a id="6040" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">C.∘</a> <a id="6044" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Function">unit.η</a> <a id="6051" class="Symbol">_</a> <a id="6053" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="6056" href="Cat.Reasoning.html#1108" data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" class="Function">C.elimr</a> <a id="6064" href="Cat.Functor.Adjoint.html#2747" data-type="(r : L ⊣ R₁) →
C ._∘_ (F₁ R₁ (η (r .counit) B₁)) (r .unit .η (F₀ R₁ B₁)) ≡ C .id" class="Field">zag</a> <a id="6068" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
    <a id="6074" href="Cat.Functor.Kan.html#5809" class="Bound">σ&#39;</a> <a id="6077" class="Symbol">.</a><a id="6078" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="6080" href="Cat.Functor.Kan.html#5828" class="Bound">x</a>                                   <a id="6116" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>
    <a id="6122" class="Keyword">where</a> <a id="6128" class="Keyword">module</a> <a id="6135" href="Cat.Functor.Kan.html#6135" class="Module">α</a> <a id="6137" class="Symbol">=</a> <a id="6139" href="Cat.Base.html#12241" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Module Operator">_=&gt;_</a> <a id="6144" href="Cat.Functor.Kan.html#5805" class="Bound">α</a>
          <a id="6156" class="Keyword">module</a> <a id="6163" href="Cat.Functor.Kan.html#6163" class="Module">M</a> <a id="6165" class="Symbol">=</a> <a id="6167" href="Cat.Functor.Reasoning.html" class="Module">Func</a> <a id="6172" href="Cat.Functor.Kan.html#5801" class="Bound">M</a>
</pre>
<h1 id="a-formula"><a href="#a-formula" class="header-link">A formula<span class="header-link-emoji">🔗</span></a></h1>
<p>In the cases where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi><mo separator="true">,</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\ca{C}, \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span> are “small enough” and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">E</mi></mrow><annotation encoding="application/x-tex">\ca{E}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.08944em;">E</span></span></span></span> is “cocomplete enough”, the left Kan extension of <em>any</em> functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi mathvariant="script">C</mi><mo>→</mo><mi mathvariant="script">E</mi></mrow><annotation encoding="application/x-tex">F : \ca{C} \to \ca{E}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.08944em;">E</span></span></span></span> along <em>any</em> functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>:</mo><mi mathvariant="script">C</mi><mo>→</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">K : \ca{C} \to \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span> exists, and is computed as a colimit in <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">E</mi></mrow><annotation encoding="application/x-tex">\ca{E}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.08944em;">E</span></span></span></span>.</span> The size concerns here is unavoidable, so let’s be explicit about them: Suppose that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">E</mi></mrow><annotation encoding="application/x-tex">\ca{E}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.08944em;">E</span></span></span></span> admits colimits of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">κ</span></span></span></span>-small</span> diagrams, e.g. because it is <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="bold">S</mi><mi mathvariant="bold">e</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">s</mi></mrow><mi>κ</mi></msub></mrow><annotation encoding="application/x-tex">\sets_\kappa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8361em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">Sets</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">κ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span> Then the category <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span> must be <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">κ</span></span></span></span>-small,</span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span> must be locally <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">κ</span></span></span></span>-small,</span> i.e. its Hom-sets must live in the <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">κ</span></span></span></span>th</span> universe.</p>
<!--
<pre class="Agda"><a id="6781" class="Keyword">module</a> <a id="6788" href="Cat.Functor.Kan.html#6788" class="Module">_</a>
  <a id="6792" class="Symbol">{</a><a id="6793" href="Cat.Functor.Kan.html#6793" class="Bound">o</a> <a id="6795" href="Cat.Functor.Kan.html#6795" class="Bound">o′</a> <a id="6798" href="Cat.Functor.Kan.html#6798" class="Bound">ℓ</a> <a id="6800" href="Cat.Functor.Kan.html#6800" class="Bound">κ</a><a id="6801" class="Symbol">}</a> <a id="6803" class="Symbol">{</a><a id="6804" href="Cat.Functor.Kan.html#6804" class="Bound">C</a> <a id="6806" class="Symbol">:</a> <a id="6808" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="6820" href="Cat.Functor.Kan.html#6800" class="Bound">κ</a> <a id="6822" href="Cat.Functor.Kan.html#6800" class="Bound">κ</a><a id="6823" class="Symbol">}</a> <a id="6825" class="Symbol">{</a><a id="6826" href="Cat.Functor.Kan.html#6826" class="Bound">D</a> <a id="6828" class="Symbol">:</a> <a id="6830" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="6842" href="Cat.Functor.Kan.html#6795" class="Bound">o′</a> <a id="6845" href="Cat.Functor.Kan.html#6800" class="Bound">κ</a><a id="6846" class="Symbol">}</a> <a id="6848" class="Symbol">{</a><a id="6849" href="Cat.Functor.Kan.html#6849" class="Bound">E</a> <a id="6851" class="Symbol">:</a> <a id="6853" href="Cat.Base.html#704" data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" class="Record">Precategory</a> <a id="6865" href="Cat.Functor.Kan.html#6793" class="Bound">o</a> <a id="6867" href="Cat.Functor.Kan.html#6798" class="Bound">ℓ</a><a id="6868" class="Symbol">}</a>
  <a id="6872" class="Symbol">(</a><a id="6873" href="Cat.Functor.Kan.html#6873" class="Bound">colim</a> <a id="6879" class="Symbol">:</a> <a id="6881" href="Cat.Diagram.Colimit.Base.html#8150" data-type="(o ℓ : Level) →
Precategory oc ℓc → Type (oc ⊔ ℓc ⊔ lsuc o ⊔ lsuc ℓ)" class="Function">is-cocomplete</a> <a id="6895" href="Cat.Functor.Kan.html#6800" class="Bound">κ</a> <a id="6897" href="Cat.Functor.Kan.html#6800" class="Bound">κ</a> <a id="6899" href="Cat.Functor.Kan.html#6849" class="Bound">E</a><a id="6900" class="Symbol">)</a>
  <a id="6904" class="Symbol">(</a><a id="6905" href="Cat.Functor.Kan.html#6905" class="Bound">F</a> <a id="6907" class="Symbol">:</a> <a id="6909" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="6917" href="Cat.Functor.Kan.html#6804" class="Bound">C</a> <a id="6919" href="Cat.Functor.Kan.html#6849" class="Bound">E</a><a id="6920" class="Symbol">)</a>
  <a id="6924" class="Symbol">(</a><a id="6925" href="Cat.Functor.Kan.html#6925" class="Bound">K</a> <a id="6927" class="Symbol">:</a> <a id="6929" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="6937" href="Cat.Functor.Kan.html#6804" class="Bound">C</a> <a id="6939" href="Cat.Functor.Kan.html#6826" class="Bound">D</a><a id="6940" class="Symbol">)</a>
  <a id="6944" class="Keyword">where</a>
  <a id="6952" class="Keyword">private</a>
    <a id="6964" class="Keyword">module</a> <a id="6971" href="Cat.Functor.Kan.html#6971" class="Module">C</a> <a id="6973" class="Symbol">=</a> <a id="6975" href="Cat.Reasoning.html" class="Module">Cat</a> <a id="6979" href="Cat.Functor.Kan.html#6804" class="Bound">C</a>
    <a id="6985" class="Keyword">module</a> <a id="6992" href="Cat.Functor.Kan.html#6992" class="Module">D</a> <a id="6994" class="Symbol">=</a> <a id="6996" href="Cat.Reasoning.html" class="Module">Cat</a> <a id="7000" href="Cat.Functor.Kan.html#6826" class="Bound">D</a>
    <a id="7006" class="Keyword">module</a> <a id="7013" href="Cat.Functor.Kan.html#7013" class="Module">E</a> <a id="7015" class="Symbol">=</a> <a id="7017" href="Cat.Reasoning.html" class="Module">Cat</a> <a id="7021" href="Cat.Functor.Kan.html#6849" class="Bound">E</a>
    <a id="7027" class="Keyword">module</a> <a id="7034" href="Cat.Functor.Kan.html#7034" class="Module">F</a> <a id="7036" class="Symbol">=</a> <a id="7038" href="Cat.Functor.Reasoning.html" class="Module">Func</a> <a id="7043" href="Cat.Functor.Kan.html#6905" class="Bound">F</a>
    <a id="7049" class="Keyword">module</a> <a id="7056" href="Cat.Functor.Kan.html#7056" class="Module">K</a> <a id="7058" class="Symbol">=</a> <a id="7060" href="Cat.Functor.Reasoning.html" class="Module">Func</a> <a id="7065" href="Cat.Functor.Kan.html#6925" class="Bound">K</a>
    <a id="7071" class="Keyword">open</a> <a id="7076" href="Cat.Diagram.Colimit.Base.html#4086" data-type="(F : Functor J₁ C) (x y : Cocone F) → Type (o ⊔ ℓ′)" class="Module">Cocone-hom</a>
    <a id="7091" class="Keyword">open</a> <a id="7096" href="Cat.Diagram.Initial.html#401" data-type="(C : Precategory o h) → Type (o ⊔ h)" class="Module">Initial</a>
    <a id="7108" class="Keyword">open</a> <a id="7113" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Module">Functor</a>
    <a id="7125" class="Keyword">open</a> <a id="7130" href="Cat.Diagram.Colimit.Base.html#2300" data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Module">Cocone</a>
    <a id="7141" class="Keyword">open</a> <a id="7146" href="Cat.Functor.Kan.html#2838" data-type="(p : Functor C C′) (F : Functor C D) →
Type (C.o ⊔ C.ℓ ⊔ C′.o ⊔ C′.ℓ ⊔ D.o ⊔ D.ℓ)" class="Module">Lan</a>
    <a id="7154" class="Keyword">open</a> <a id="7159" href="Cat.Instances.Comma.html#1730" data-type="(F : Functor A C) (G : Functor B₁ C) → Type (ao ⊔ bo ⊔ h)" class="Module">↓Obj</a>
    <a id="7168" class="Keyword">open</a> <a id="7173" href="Cat.Instances.Comma.html#2452" data-type="(F : Functor A C) (G : Functor B₁ C) (a b : ↓Obj F G) →
Type (ah ⊔ bh ⊔ h)" class="Module">↓Hom</a>
</pre>-->
<p>The size restrictions on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span> ensure that the <a href="Cat.Instances.Comma.html">comma category</a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>↘</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">K \searrow d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↘</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span> is <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">κ</span></span></span></span>-small,</span> so that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">E</mi></mrow><annotation encoding="application/x-tex">\ca{E}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.08944em;">E</span></span></span></span> has a colimit for it. The objects of this category can be considered “approximations of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span> coming from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>”, so the colimit over this category is a “best approximation of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>”! The rest of the computation is “straightforward” in the way that most category-theoretic computations are: it looks mighty complicated from the outside, but when you’re actually working them out, there’s only one step you can take at each point. Agda’s goal-and-context display guides you the whole way.</p>
<pre class="Agda">  <a id="7860" href="Cat.Functor.Kan.html#7860" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">lan-approximate</a> <a id="7876" class="Symbol">:</a> <a id="7878" class="Symbol">∀</a> <a id="7880" class="Symbol">{</a><a id="7881" href="Cat.Functor.Kan.html#7881" class="Bound">d</a> <a id="7883" href="Cat.Functor.Kan.html#7883" class="Bound">e</a><a id="7884" class="Symbol">}</a> <a id="7886" class="Symbol">(</a><a id="7887" href="Cat.Functor.Kan.html#7887" class="Bound">f</a> <a id="7889" class="Symbol">:</a> <a id="7891" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">D.Hom</a> <a id="7897" href="Cat.Functor.Kan.html#7881" class="Bound">d</a> <a id="7899" href="Cat.Functor.Kan.html#7883" class="Bound">e</a><a id="7900" class="Symbol">)</a> <a id="7902" class="Symbol">→</a> <a id="7904" href="Cat.Diagram.Colimit.Base.html#2300" data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Record">Cocone</a> <a id="7911" class="Symbol">(</a><a id="7912" href="Cat.Functor.Kan.html#6905" class="Bound">F</a> <a id="7914" href="Cat.Base.html#9697" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="7917" href="Cat.Instances.Comma.html#5380" data-type="(F : Functor A C) (G : Functor B₁ C) → Functor (F ↓ G) A" class="Function">Dom</a> <a id="7921" href="Cat.Functor.Kan.html#6925" class="Bound">K</a> <a id="7923" class="Symbol">(</a><a id="7924" href="Cat.Instances.Shape.Terminal.html#558" data-type="Ob A → Functor ⊤Cat A" class="Function">const!</a> <a id="7931" href="Cat.Functor.Kan.html#7881" class="Bound">d</a><a id="7932" class="Symbol">))</a>
  <a id="7937" href="Cat.Functor.Kan.html#7860" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">lan-approximate</a> <a id="7953" class="Symbol">{</a><a id="7954" class="Argument">e</a> <a id="7956" class="Symbol">=</a> <a id="7958" href="Cat.Functor.Kan.html#7958" class="Bound">e</a><a id="7959" class="Symbol">}</a> <a id="7961" href="Cat.Functor.Kan.html#7961" class="Bound">f</a> <a id="7963" class="Symbol">.</a><a id="7964" href="Cat.Diagram.Colimit.Base.html#2661" data-type="Cocone F → C .Ob" class="Field">coapex</a> <a id="7971" class="Symbol">=</a> <a id="7973" href="Cat.Functor.Kan.html#6873" class="Bound">colim</a> <a id="7979" class="Symbol">(</a><a id="7980" href="Cat.Functor.Kan.html#6905" class="Bound">F</a> <a id="7982" href="Cat.Base.html#9697" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="7985" href="Cat.Instances.Comma.html#5380" data-type="(F : Functor A C) (G : Functor B₁ C) → Functor (F ↓ G) A" class="Function">Dom</a> <a id="7989" href="Cat.Functor.Kan.html#6925" class="Bound">K</a> <a id="7991" class="Symbol">(</a><a id="7992" href="Cat.Instances.Shape.Terminal.html#558" data-type="Ob A → Functor ⊤Cat A" class="Function">const!</a> <a id="7999" href="Cat.Functor.Kan.html#7958" class="Bound">e</a><a id="8000" class="Symbol">))</a> <a id="8003" class="Symbol">.</a><a id="8004" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="8008" class="Symbol">.</a><a id="8009" href="Cat.Diagram.Colimit.Base.html#2661" data-type="Cocone F → C .Ob" class="Field">coapex</a>
  <a id="8018" href="Cat.Functor.Kan.html#7860" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">lan-approximate</a> <a id="8034" class="Symbol">{</a><a id="8035" class="Argument">e</a> <a id="8037" class="Symbol">=</a> <a id="8039" href="Cat.Functor.Kan.html#8039" class="Bound">e</a><a id="8040" class="Symbol">}</a> <a id="8042" href="Cat.Functor.Kan.html#8042" class="Bound">f</a> <a id="8044" class="Symbol">.</a><a id="8045" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a> <a id="8047" href="Cat.Functor.Kan.html#8047" class="Bound">x</a> <a id="8049" class="Symbol">=</a>
    <a id="8055" href="Cat.Functor.Kan.html#6873" class="Bound">colim</a> <a id="8061" class="Symbol">(</a><a id="8062" href="Cat.Functor.Kan.html#6905" class="Bound">F</a> <a id="8064" href="Cat.Base.html#9697" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="8067" href="Cat.Instances.Comma.html#5380" data-type="(F : Functor A C) (G : Functor B₁ C) → Functor (F ↓ G) A" class="Function">Dom</a> <a id="8071" href="Cat.Functor.Kan.html#6925" class="Bound">K</a> <a id="8073" class="Symbol">(</a><a id="8074" href="Cat.Instances.Shape.Terminal.html#558" data-type="Ob A → Functor ⊤Cat A" class="Function">const!</a> <a id="8081" href="Cat.Functor.Kan.html#8039" class="Bound">e</a><a id="8082" class="Symbol">))</a> <a id="8085" class="Symbol">.</a><a id="8086" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="8090" class="Symbol">.</a><a id="8091" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a> <a id="8093" class="Symbol">(</a><a id="8094" class="Keyword">record</a> <a id="8101" class="Symbol">{</a> <a id="8103" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a> <a id="8107" class="Symbol">=</a> <a id="8109" href="Cat.Functor.Kan.html#8042" class="Bound">f</a> <a id="8111" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8115" href="Cat.Functor.Kan.html#8047" class="Bound">x</a> <a id="8117" class="Symbol">.</a><a id="8118" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a> <a id="8122" class="Symbol">})</a>
  <a id="8127" href="Cat.Functor.Kan.html#7860" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">lan-approximate</a> <a id="8143" class="Symbol">{</a><a id="8144" class="Argument">e</a> <a id="8146" class="Symbol">=</a> <a id="8148" href="Cat.Functor.Kan.html#8148" class="Bound">e</a><a id="8149" class="Symbol">}</a> <a id="8151" href="Cat.Functor.Kan.html#8151" class="Bound">f</a> <a id="8153" class="Symbol">.</a><a id="8154" href="Cat.Diagram.Colimit.Base.html#3115" data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" class="Field">commutes</a> <a id="8163" class="Symbol">{</a><a id="8164" href="Cat.Functor.Kan.html#8164" class="Bound">x</a><a id="8165" class="Symbol">}</a> <a id="8167" class="Symbol">{</a><a id="8168" href="Cat.Functor.Kan.html#8168" class="Bound">y</a><a id="8169" class="Symbol">}</a> <a id="8171" href="Cat.Functor.Kan.html#8171" class="Bound">h</a> <a id="8173" class="Symbol">=</a>
    <a id="8179" href="Cat.Functor.Kan.html#6873" class="Bound">colim</a> <a id="8185" class="Symbol">(</a><a id="8186" href="Cat.Functor.Kan.html#6905" class="Bound">F</a> <a id="8188" href="Cat.Base.html#9697" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="8191" href="Cat.Instances.Comma.html#5380" data-type="(F : Functor A C) (G : Functor B₁ C) → Functor (F ↓ G) A" class="Function">Dom</a> <a id="8195" href="Cat.Functor.Kan.html#6925" class="Bound">K</a> <a id="8197" class="Symbol">(</a><a id="8198" href="Cat.Instances.Shape.Terminal.html#558" data-type="Ob A → Functor ⊤Cat A" class="Function">const!</a> <a id="8205" href="Cat.Functor.Kan.html#8148" class="Bound">e</a><a id="8206" class="Symbol">))</a> <a id="8209" class="Symbol">.</a><a id="8210" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="8214" class="Symbol">.</a><a id="8215" href="Cat.Diagram.Colimit.Base.html#3115" data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" class="Field">commutes</a> <a id="8224" class="Symbol">(</a><a id="8225" class="Keyword">record</a> <a id="8232" class="Symbol">{</a> <a id="8234" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">sq</a> <a id="8237" class="Symbol">=</a> <a id="8239" href="Cat.Functor.Kan.html#8272" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(f : D .Hom d e) (h : (K ↓ const! d) .Hom x y) →
D ._∘_ (D ._∘_ f (y .map)) (₁ K (h .α)) ≡
D ._∘_ (D .id) (D ._∘_ f (x .map))" class="Function">path</a> <a id="8244" class="Symbol">})</a>
    <a id="8251" class="Keyword">where</a> <a id="8257" class="Keyword">abstract</a>
      <a id="8272" href="Cat.Functor.Kan.html#8272" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(f : D .Hom d e) (h : (K ↓ const! d) .Hom x y) →
D ._∘_ (D ._∘_ f (y .map)) (₁ K (h .α)) ≡
D ._∘_ (D .id) (D ._∘_ f (x .map))" class="Function">path</a> <a id="8277" class="Symbol">:</a> <a id="8279" class="Symbol">(</a><a id="8280" href="Cat.Functor.Kan.html#8151" class="Bound">f</a> <a id="8282" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8286" href="Cat.Functor.Kan.html#8168" class="Bound">y</a> <a id="8288" class="Symbol">.</a><a id="8289" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a><a id="8292" class="Symbol">)</a> <a id="8294" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8298" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">K.₁</a> <a id="8302" class="Symbol">(</a><a id="8303" href="Cat.Functor.Kan.html#8171" class="Bound">h</a> <a id="8305" class="Symbol">.</a><a id="8306" href="Cat.Instances.Comma.html#2595" data-type="↓Hom F G a b → Hom A (a .x) (x b)" class="Field">α</a><a id="8307" class="Symbol">)</a> <a id="8309" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="8311" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a> <a id="8316" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8320" class="Symbol">(</a><a id="8321" href="Cat.Functor.Kan.html#8151" class="Bound">f</a> <a id="8323" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8327" href="Cat.Functor.Kan.html#8164" class="Bound">x</a> <a id="8329" class="Symbol">.</a><a id="8330" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a><a id="8333" class="Symbol">)</a>
      <a id="8341" href="Cat.Functor.Kan.html#8272" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(f : D .Hom d e) (h : (K ↓ const! d) .Hom x y) →
D ._∘_ (D ._∘_ f (y .map)) (₁ K (h .α)) ≡
D ._∘_ (D .id) (D ._∘_ f (x .map))" class="Function">path</a> <a id="8346" class="Symbol">=</a>
        <a id="8356" class="Symbol">(</a><a id="8357" href="Cat.Functor.Kan.html#8151" class="Bound">f</a> <a id="8359" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8363" href="Cat.Functor.Kan.html#8168" class="Bound">y</a> <a id="8365" class="Symbol">.</a><a id="8366" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a><a id="8369" class="Symbol">)</a> <a id="8371" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8375" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">K.₁</a> <a id="8379" class="Symbol">(</a><a id="8380" href="Cat.Functor.Kan.html#8171" class="Bound">h</a> <a id="8382" class="Symbol">.</a><a id="8383" href="Cat.Instances.Comma.html#2595" data-type="↓Hom F G a b → Hom A (a .x) (x b)" class="Field">α</a><a id="8384" class="Symbol">)</a> <a id="8386" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8389" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">D.pullr</a> <a id="8397" class="Symbol">(</a><a id="8398" href="Cat.Functor.Kan.html#8171" class="Bound">h</a> <a id="8400" class="Symbol">.</a><a id="8401" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">sq</a><a id="8403" class="Symbol">)</a> <a id="8405" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
        <a id="8415" href="Cat.Functor.Kan.html#8151" class="Bound">f</a> <a id="8417" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8421" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a> <a id="8426" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8430" href="Cat.Functor.Kan.html#8164" class="Bound">x</a> <a id="8432" class="Symbol">.</a><a id="8433" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a>         <a id="8445" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="8448" href="Cat.Solver.html#7426" data-type="Term → Term → TC ⊤" class="Macro">solve</a> <a id="8454" href="Cat.Functor.Kan.html#6826" class="Bound">D</a> <a id="8456" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
        <a id="8466" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a> <a id="8471" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8475" class="Symbol">(</a><a id="8476" href="Cat.Functor.Kan.html#8151" class="Bound">f</a> <a id="8478" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="8482" href="Cat.Functor.Kan.html#8164" class="Bound">x</a> <a id="8484" class="Symbol">.</a><a id="8485" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a><a id="8488" class="Symbol">)</a>       <a id="8496" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

  <a id="8501" href="Cat.Functor.Kan.html#8501" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">cocomplete→lan</a> <a id="8516" class="Symbol">:</a> <a id="8518" href="Cat.Functor.Kan.html#2838" data-type="(p : Functor C C′) (F : Functor C D) →
Type (C.o ⊔ C.ℓ ⊔ C′.o ⊔ C′.ℓ ⊔ D.o ⊔ D.ℓ)" class="Record">Lan</a> <a id="8522" href="Cat.Functor.Kan.html#6925" class="Bound">K</a> <a id="8524" href="Cat.Functor.Kan.html#6905" class="Bound">F</a>
  <a id="8528" href="Cat.Functor.Kan.html#8501" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">cocomplete→lan</a> <a id="8543" class="Symbol">=</a> <a id="8545" href="Cat.Functor.Kan.html#11070" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">lan</a> <a id="8549" class="Keyword">where</a>
    <a id="8559" href="Cat.Functor.Kan.html#8559" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="8567" class="Symbol">:</a> <a id="8569" class="Symbol">∀</a> <a id="8571" href="Cat.Functor.Kan.html#8571" class="Bound">d</a> <a id="8573" class="Symbol">→</a> <a id="8575" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="8583" class="Symbol">(</a><a id="8584" href="Cat.Functor.Kan.html#6925" class="Bound">K</a> <a id="8586" href="Cat.Instances.Comma.html#5869" data-type="Functor B₁ A →
A .Ob → Precategory (ah ⊔ bo ⊔ lzero) (ah ⊔ bh ⊔ lzero)" class="Function Operator">↘</a> <a id="8588" href="Cat.Functor.Kan.html#8571" class="Bound">d</a><a id="8589" class="Symbol">)</a> <a id="8591" href="Cat.Functor.Kan.html#6849" class="Bound">E</a>
    <a id="8597" href="Cat.Functor.Kan.html#8559" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="8605" href="Cat.Functor.Kan.html#8605" class="Bound">d</a> <a id="8607" class="Symbol">=</a> <a id="8609" href="Cat.Functor.Kan.html#6905" class="Bound">F</a> <a id="8611" href="Cat.Base.html#9697" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="8614" href="Cat.Instances.Comma.html#5380" data-type="(F : Functor A C) (G : Functor B₁ C) → Functor (F ↓ G) A" class="Function">Dom</a> <a id="8618" href="Cat.Functor.Kan.html#6925" class="Bound">K</a> <a id="8620" class="Symbol">(</a><a id="8621" href="Cat.Instances.Shape.Terminal.html#558" data-type="Ob A → Functor ⊤Cat A" class="Function">const!</a> <a id="8628" href="Cat.Functor.Kan.html#8605" class="Bound">d</a><a id="8629" class="Symbol">)</a>

    <a id="8636" href="Cat.Functor.Kan.html#8636" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">approx</a> <a id="8643" class="Symbol">=</a> <a id="8645" href="Cat.Functor.Kan.html#7860" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">lan-approximate</a>
</pre>
<p>Our extension will associate to each object <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span> the colimit of</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>K</mi><mo>↘</mo><mi>d</mi><mo stretchy="false">)</mo><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mrow><mi mathvariant="normal">D</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow></mpadded></mover><mi>C</mi><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mi>F</mi></mpadded></mover><mi>E</mi><mtext>,</mtext></mrow><annotation encoding="application/x-tex">
(K \searrow d) \xto{\id{Dom}} C \xto{F} E\text{,}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↘</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3503em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1003em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">Dom</span></span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1113em;vertical-align:-0.011em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1003em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord text"><span class="mord">,</span></span></span></span></span></span></p>
<p>where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">D</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow><annotation encoding="application/x-tex">\id{Dom}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">Dom</span></span></span></span></span> is the functor which projects out the <em>dom</em>ain of each object of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>↘</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">K \searrow d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↘</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>.</span> Now, we must also associate <em>arrows</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>d</mi><mo>→</mo><mi>e</mi><mo>∈</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">f : d \to e \in \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span> to arrows between the respective colimits of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span> and <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span>.</span> What we note is that any arrow <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>d</mi><mo>→</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">f : d \to e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> displays (the colimit associated with) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> as a cocone under <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>,</span> as can be seen in the computation of <span class="Agda"><a href="Cat.Functor.Kan.html#8636" class="Function">approx</a></span> above.</p>
<p>Our functor can then take an arrow <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>d</mi><mo>→</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">f : d \to e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> to the uniqueness arrow from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">colim</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo><mo>→</mo><mi mathvariant="normal">colim</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\colim(d) \to \colim(e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">colim</span></span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">colim</span></span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span> (punning <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> for their respective diagrams), which exists because <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">colim</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\colim(d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">colim</span></span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span> is initial. Uniqueness of this arrow ensures that this assignment is functorial — but as the functoriality proof is (to use a technical term) goddamn nasty, we leave it hidden from the page.</p>
<pre class="Agda">    <a id="9573" href="Cat.Functor.Kan.html#9573" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Functor D E" class="Function">func</a> <a id="9578" class="Symbol">:</a> <a id="9580" href="Cat.Base.html#7206" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" class="Record">Functor</a> <a id="9588" href="Cat.Functor.Kan.html#6826" class="Bound">D</a> <a id="9590" href="Cat.Functor.Kan.html#6849" class="Bound">E</a>
    <a id="9596" href="Cat.Functor.Kan.html#9573" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Functor D E" class="Function">func</a> <a id="9601" class="Symbol">.</a><a id="9602" href="Cat.Base.html#7996" data-type="Functor C D → C .Ob → Ob D" class="Field">F₀</a> <a id="9605" href="Cat.Functor.Kan.html#9605" class="Bound">d</a> <a id="9607" class="Symbol">=</a> <a id="9609" href="Cat.Functor.Kan.html#6873" class="Bound">colim</a> <a id="9615" class="Symbol">(</a><a id="9616" href="Cat.Functor.Kan.html#8559" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="9624" href="Cat.Functor.Kan.html#9605" class="Bound">d</a><a id="9625" class="Symbol">)</a> <a id="9627" class="Symbol">.</a><a id="9628" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="9632" class="Symbol">.</a><a id="9633" href="Cat.Diagram.Colimit.Base.html#2661" data-type="Cocone F → C .Ob" class="Field">coapex</a>
    <a id="9644" href="Cat.Functor.Kan.html#9573" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Functor D E" class="Function">func</a> <a id="9649" class="Symbol">.</a><a id="9650" href="Cat.Base.html#8017" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="9653" class="Symbol">{</a><a id="9654" href="Cat.Functor.Kan.html#9654" class="Bound">d</a><a id="9655" class="Symbol">}</a> <a id="9657" class="Symbol">{</a><a id="9658" href="Cat.Functor.Kan.html#9658" class="Bound">e</a><a id="9659" class="Symbol">}</a> <a id="9661" href="Cat.Functor.Kan.html#9661" class="Bound">f</a> <a id="9663" class="Symbol">=</a> <a id="9665" href="Cat.Functor.Kan.html#6873" class="Bound">colim</a> <a id="9671" class="Symbol">(</a><a id="9672" href="Cat.Functor.Kan.html#8559" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="9680" href="Cat.Functor.Kan.html#9654" class="Bound">d</a><a id="9681" class="Symbol">)</a> <a id="9683" class="Symbol">.</a><a id="9684" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="9689" class="Symbol">(</a><a id="9690" href="Cat.Functor.Kan.html#8636" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">approx</a> <a id="9697" href="Cat.Functor.Kan.html#9661" class="Bound">f</a><a id="9698" class="Symbol">)</a> <a id="9700" class="Symbol">.</a><a id="9701" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="9708" class="Symbol">.</a><a id="9709" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a>
</pre>
<!--
<pre class="Agda">    <a id="9735" href="Cat.Functor.Kan.html#9573" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Functor D E" class="Function">func</a> <a id="9740" class="Symbol">.</a><a id="9741" href="Cat.Base.html#8343" data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" class="Field">F-id</a> <a id="9746" class="Symbol">{</a><a id="9747" href="Cat.Functor.Kan.html#9747" class="Bound">d</a><a id="9748" class="Symbol">}</a> <a id="9750" class="Symbol">=</a> <a id="9752" href="Cat.Functor.Kan.html#9778" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
func colim F K .F₁ (D .id) ≡ E .id" class="Function">path</a> <a id="9757" class="Keyword">where</a> <a id="9763" class="Keyword">abstract</a>
      <a id="9778" href="Cat.Functor.Kan.html#9778" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
func colim F K .F₁ (D .id) ≡ E .id" class="Function">path</a> <a id="9783" class="Symbol">:</a> <a id="9785" href="Cat.Functor.Kan.html#9573" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Functor D E" class="Function">func</a> <a id="9790" class="Symbol">.</a><a id="9791" href="Cat.Base.html#8017" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="9794" class="Symbol">(</a><a id="9795" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a> <a id="9800" class="Symbol">{</a><a id="9801" class="Argument">x</a> <a id="9803" class="Symbol">=</a> <a id="9805" href="Cat.Functor.Kan.html#9747" class="Bound">d</a><a id="9806" class="Symbol">})</a> <a id="9809" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="9811" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">E.id</a>
      <a id="9822" href="Cat.Functor.Kan.html#9778" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
func colim F K .F₁ (D .id) ≡ E .id" class="Function">path</a> <a id="9827" class="Symbol">=</a> <a id="9829" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="9832" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a> <a id="9836" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="9838" href="Cat.Functor.Kan.html#6873" class="Bound">colim</a> <a id="9844" class="Symbol">(</a><a id="9845" href="Cat.Functor.Kan.html#8559" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="9853" href="Cat.Functor.Kan.html#9747" class="Bound">d</a><a id="9854" class="Symbol">)</a> <a id="9856" class="Symbol">.</a><a id="9857" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="9862" class="Symbol">(</a><a id="9863" href="Cat.Functor.Kan.html#8636" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">approx</a> <a id="9870" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a><a id="9874" class="Symbol">)</a> <a id="9876" class="Symbol">.</a><a id="9877" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a>
        <a id="9891" class="Symbol">(</a><a id="9892" href="Cat.Diagram.Colimit.Base.html#4170" data-type="(hom : C .Hom (x .coapex) (y .coapex))
(commutes : (o : J₁ .Ob) → C ._∘_ hom (x .ψ o) ≡ y .ψ o) →
Cocone-hom F x y" class="InductiveConstructor">cocone-hom</a> <a id="9903" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">E.id</a> <a id="9908" class="Symbol">(λ</a> <a id="9911" href="Cat.Functor.Kan.html#9911" class="Bound">o</a> <a id="9913" class="Symbol">→</a> <a id="9915" href="Cat.Base.html#3482" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" class="Function">E.idl</a> <a id="9921" class="Symbol">_</a>
                         <a id="9948" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="9950" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="9953" class="Symbol">(</a><a id="9954" href="Cat.Functor.Kan.html#6873" class="Bound">colim</a> <a id="9960" class="Symbol">(</a><a id="9961" href="Cat.Functor.Kan.html#8559" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="9969" href="Cat.Functor.Kan.html#9747" class="Bound">d</a><a id="9970" class="Symbol">)</a> <a id="9972" class="Symbol">.</a><a id="9973" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="9977" class="Symbol">.</a><a id="9978" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a><a id="9979" class="Symbol">)</a>
                              <a id="10011" class="Symbol">(</a><a id="10012" href="Cat.Instances.Comma.html#3533" data-type="(F : Functor A C) (G : Functor B₁ C) (p : a .x ≡ b .x)
(q : a .y ≡ b .y) →
PathP (λ i → Hom C (F₀ F (p i)) (F₀ G (q i))) (a .map) (b .map) →
a ≡ b" class="Function">↓Obj-path</a> <a id="10022" class="Symbol">_</a> <a id="10024" class="Symbol">_</a> <a id="10026" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="10031" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="10036" class="Symbol">(</a><a id="10037" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="10041" class="Symbol">(</a><a id="10042" href="Cat.Base.html#3482" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" class="Function">D.idl</a> <a id="10048" class="Symbol">_)))))</a>
    <a id="10059" href="Cat.Functor.Kan.html#9573" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Functor D E" class="Function">func</a> <a id="10064" class="Symbol">.</a><a id="10065" href="Cat.Base.html#8383" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Field">F-∘</a> <a id="10069" class="Symbol">{</a><a id="10070" href="Cat.Functor.Kan.html#10070" class="Bound">d</a><a id="10071" class="Symbol">}</a> <a id="10073" class="Symbol">{</a><a id="10074" href="Cat.Functor.Kan.html#10074" class="Bound">e</a><a id="10075" class="Symbol">}</a> <a id="10077" class="Symbol">{</a><a id="10078" href="Cat.Functor.Kan.html#10078" class="Bound">f</a><a id="10079" class="Symbol">}</a> <a id="10081" href="Cat.Functor.Kan.html#10081" class="Bound">g</a> <a id="10083" href="Cat.Functor.Kan.html#10083" class="Bound">h</a> <a id="10085" class="Symbol">=</a> <a id="10087" href="Cat.Functor.Kan.html#10113" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(g : D .Hom e f) (h : D .Hom d e) →
func colim F K .F₁ (D ._∘_ g h) ≡
E ._∘_ (func colim F K .F₁ g) (func colim F K .F₁ h)" class="Function">path</a> <a id="10092" class="Keyword">where</a> <a id="10098" class="Keyword">abstract</a>
      <a id="10113" href="Cat.Functor.Kan.html#10113" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(g : D .Hom e f) (h : D .Hom d e) →
func colim F K .F₁ (D ._∘_ g h) ≡
E ._∘_ (func colim F K .F₁ g) (func colim F K .F₁ h)" class="Function">path</a> <a id="10118" class="Symbol">:</a> <a id="10120" href="Cat.Functor.Kan.html#9573" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Functor D E" class="Function">func</a> <a id="10125" class="Symbol">.</a><a id="10126" href="Cat.Base.html#8017" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="10129" class="Symbol">(</a><a id="10130" href="Cat.Functor.Kan.html#10081" class="Bound">g</a> <a id="10132" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘</a> <a id="10136" href="Cat.Functor.Kan.html#10083" class="Bound">h</a><a id="10137" class="Symbol">)</a> <a id="10139" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="10141" href="Cat.Functor.Kan.html#9573" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Functor D E" class="Function">func</a> <a id="10146" class="Symbol">.</a><a id="10147" href="Cat.Base.html#8017" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="10150" href="Cat.Functor.Kan.html#10081" class="Bound">g</a> <a id="10152" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">E.∘</a> <a id="10156" href="Cat.Functor.Kan.html#9573" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Functor D E" class="Function">func</a> <a id="10161" class="Symbol">.</a><a id="10162" href="Cat.Base.html#8017" data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" class="Field">F₁</a> <a id="10165" href="Cat.Functor.Kan.html#10083" class="Bound">h</a>
      <a id="10173" href="Cat.Functor.Kan.html#10113" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(g : D .Hom e f) (h : D .Hom d e) →
func colim F K .F₁ (D ._∘_ g h) ≡
E ._∘_ (func colim F K .F₁ g) (func colim F K .F₁ h)" class="Function">path</a> <a id="10178" class="Symbol">=</a> <a id="10180" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="10183" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a> <a id="10187" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="10189" href="Cat.Functor.Kan.html#6873" class="Bound">colim</a> <a id="10195" class="Symbol">(</a><a id="10196" href="Cat.Functor.Kan.html#8559" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="10204" href="Cat.Functor.Kan.html#10070" class="Bound">d</a><a id="10205" class="Symbol">)</a> <a id="10207" class="Symbol">.</a><a id="10208" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="10213" class="Symbol">(</a><a id="10214" href="Cat.Functor.Kan.html#8636" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">approx</a> <a id="10221" class="Symbol">_)</a> <a id="10224" class="Symbol">.</a><a id="10225" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a>
        <a id="10239" class="Symbol">(</a><a id="10240" href="Cat.Diagram.Colimit.Base.html#4170" data-type="(hom : C .Hom (x .coapex) (y .coapex))
(commutes : (o : J₁ .Ob) → C ._∘_ hom (x .ψ o) ≡ y .ψ o) →
Cocone-hom F x y" class="InductiveConstructor">cocone-hom</a> <a id="10251" class="Symbol">_</a> <a id="10253" class="Symbol">λ</a> <a id="10255" href="Cat.Functor.Kan.html#10255" class="Bound">o</a> <a id="10257" class="Symbol">→</a>
            <a id="10271" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">E.pullr</a> <a id="10279" class="Symbol">(</a><a id="10280" href="Cat.Functor.Kan.html#6873" class="Bound">colim</a> <a id="10286" class="Symbol">(</a><a id="10287" href="Cat.Functor.Kan.html#8559" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="10295" href="Cat.Functor.Kan.html#10070" class="Bound">d</a><a id="10296" class="Symbol">)</a> <a id="10298" class="Symbol">.</a><a id="10299" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="10304" class="Symbol">(</a><a id="10305" href="Cat.Functor.Kan.html#8636" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">approx</a> <a id="10312" href="Cat.Functor.Kan.html#10083" class="Bound">h</a><a id="10313" class="Symbol">)</a> <a id="10315" class="Symbol">.</a><a id="10316" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="10323" class="Symbol">.</a><a id="10324" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="10333" class="Symbol">_)</a>
          <a id="10346" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="10348" href="Cat.Functor.Kan.html#6873" class="Bound">colim</a> <a id="10354" class="Symbol">(</a><a id="10355" href="Cat.Functor.Kan.html#8559" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="10363" href="Cat.Functor.Kan.html#10074" class="Bound">e</a><a id="10364" class="Symbol">)</a> <a id="10366" class="Symbol">.</a><a id="10367" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="10372" class="Symbol">(</a><a id="10373" href="Cat.Functor.Kan.html#8636" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">approx</a> <a id="10380" href="Cat.Functor.Kan.html#10081" class="Bound">g</a><a id="10381" class="Symbol">)</a> <a id="10383" class="Symbol">.</a><a id="10384" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="10391" class="Symbol">.</a><a id="10392" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="10401" class="Symbol">_</a>
          <a id="10413" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="10415" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="10418" class="Symbol">(</a><a id="10419" href="Cat.Functor.Kan.html#6873" class="Bound">colim</a> <a id="10425" class="Symbol">(</a><a id="10426" href="Cat.Functor.Kan.html#8559" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="10434" href="Cat.Functor.Kan.html#10078" class="Bound">f</a><a id="10435" class="Symbol">)</a> <a id="10437" class="Symbol">.</a><a id="10438" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="10442" class="Symbol">.</a><a id="10443" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a><a id="10444" class="Symbol">)</a>
               <a id="10461" class="Symbol">(</a><a id="10462" href="Cat.Instances.Comma.html#3533" data-type="(F : Functor A C) (G : Functor B₁ C) (p : a .x ≡ b .x)
(q : a .y ≡ b .y) →
PathP (λ i → Hom C (F₀ F (p i)) (F₀ G (q i))) (a .map) (b .map) →
a ≡ b" class="Function">↓Obj-path</a> <a id="10472" class="Symbol">_</a> <a id="10474" class="Symbol">_</a> <a id="10476" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="10481" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="10486" class="Symbol">(</a><a id="10487" href="Cat.Base.html#3857" data-type="(r : Precategory o h) (f : r .Hom y z) (g : r .Hom x y)
(h : r .Hom w x) →
r ._∘_ f (r ._∘_ g h) ≡ r ._∘_ (r ._∘_ f g) h" class="Function">D.assoc</a> <a id="10495" class="Symbol">_</a> <a id="10497" class="Symbol">_</a> <a id="10499" class="Symbol">_)))</a>

    <a id="10509" class="Keyword">open</a> <a id="10514" href="Cat.Base.html#12241" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Module Operator">_=&gt;_</a>
</pre>-->
<p>It remains to show that our extension functor admits a natural transformation (with components) <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>x</mi><mo>→</mo><mi mathvariant="normal">colim</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>F</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Fx \to \colim(Fx)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">colim</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>,</span> but we can take these arrows to be the colimit coprojections <span class="Agda"><a href="Cat.Diagram.Colimit.Base.html#2681" class="Field">ψ</a></span>; The factoring natural transformation <span class="Agda"><a href="Cat.Functor.Kan.html#3692" class="Field">σ</a></span> is given by eliminating the colimit, which ensures commutativity and uniqueness. We leave the rest of the computation in this <code class="sourceCode html"><span class="kw">&lt;details&gt;</span></code> tag, for the interested reader.</p>
<details>
<summary>
Fair advance warning that the computation here doesn’t have any further comments.
</summary>
<pre class="Agda">    <a id="11070" href="Cat.Functor.Kan.html#11070" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">lan</a> <a id="11074" class="Symbol">:</a> <a id="11076" href="Cat.Functor.Kan.html#2838" data-type="(p : Functor C C′) (F : Functor C D) →
Type (C.o ⊔ C.ℓ ⊔ C′.o ⊔ C′.ℓ ⊔ D.o ⊔ D.ℓ)" class="Record">Lan</a> <a id="11080" href="Cat.Functor.Kan.html#6925" class="Bound">K</a> <a id="11082" href="Cat.Functor.Kan.html#6905" class="Bound">F</a>
    <a id="11088" href="Cat.Functor.Kan.html#11070" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">lan</a> <a id="11092" class="Symbol">.</a><a id="11093" href="Cat.Functor.Kan.html#2918" data-type="Lan p F → Functor C′ D" class="Field">Ext</a> <a id="11097" class="Symbol">=</a> <a id="11099" href="Cat.Functor.Kan.html#9573" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Functor D E" class="Function">func</a>
    <a id="11108" href="Cat.Functor.Kan.html#11070" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">lan</a> <a id="11112" class="Symbol">.</a><a id="11113" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a> <a id="11117" class="Symbol">.</a><a id="11118" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="11120" href="Cat.Functor.Kan.html#11120" class="Bound">x</a> <a id="11122" class="Symbol">=</a> <a id="11124" href="Cat.Functor.Kan.html#6873" class="Bound">colim</a> <a id="11130" class="Symbol">(</a><a id="11131" href="Cat.Functor.Kan.html#8559" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="11139" class="Symbol">(</a><a id="11140" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">K.₀</a> <a id="11144" href="Cat.Functor.Kan.html#11120" class="Bound">x</a><a id="11145" class="Symbol">))</a> <a id="11148" class="Symbol">.</a><a id="11149" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="11153" class="Symbol">.</a><a id="11154" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a> <a id="11156" class="Symbol">(</a><a id="11157" class="Keyword">record</a> <a id="11164" class="Symbol">{</a> <a id="11166" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a> <a id="11170" class="Symbol">=</a> <a id="11172" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a> <a id="11177" class="Symbol">})</a>

    <a id="11185" href="Cat.Functor.Kan.html#11070" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">lan</a> <a id="11189" class="Symbol">.</a><a id="11190" href="Cat.Functor.Kan.html#3692" data-type="(r : Lan p F) → F =&gt; M F∘ p → r .Ext =&gt; M" class="Field">σ</a> <a id="11192" class="Symbol">{</a><a id="11193" href="Cat.Functor.Kan.html#11193" class="Bound">M</a><a id="11194" class="Symbol">}</a> <a id="11196" href="Cat.Functor.Kan.html#11196" class="Bound">α</a> <a id="11198" class="Symbol">.</a><a id="11199" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="11201" href="Cat.Functor.Kan.html#11201" class="Bound">x</a> <a id="11203" class="Symbol">=</a> <a id="11205" href="Cat.Functor.Kan.html#6873" class="Bound">colim</a> <a id="11211" class="Symbol">(</a><a id="11212" href="Cat.Functor.Kan.html#8559" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="11220" href="Cat.Functor.Kan.html#11201" class="Bound">x</a><a id="11221" class="Symbol">)</a> <a id="11223" class="Symbol">.</a><a id="11224" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="11229" href="Cat.Functor.Kan.html#11297" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(α : F =&gt; M F∘ K) (x : D .Ob) →
Cocone (diagram colim F K x)" class="Function">cocone′</a> <a id="11237" class="Symbol">.</a><a id="11238" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="11245" class="Symbol">.</a><a id="11246" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a>
      <a id="11256" class="Keyword">where</a>
        <a id="11270" class="Keyword">module</a> <a id="11277" href="Cat.Functor.Kan.html#11277" class="Module">M</a> <a id="11279" class="Symbol">=</a> <a id="11281" href="Cat.Functor.Reasoning.html" class="Module">Func</a> <a id="11286" href="Cat.Functor.Kan.html#11193" class="Bound">M</a>

        <a id="11297" href="Cat.Functor.Kan.html#11297" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(α : F =&gt; M F∘ K) (x : D .Ob) →
Cocone (diagram colim F K x)" class="Function">cocone′</a> <a id="11305" class="Symbol">:</a> <a id="11307" href="Cat.Diagram.Colimit.Base.html#2300" data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Record">Cocone</a> <a id="11314" class="Symbol">_</a>
        <a id="11324" href="Cat.Functor.Kan.html#11297" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(α : F =&gt; M F∘ K) (x : D .Ob) →
Cocone (diagram colim F K x)" class="Function">cocone′</a> <a id="11332" class="Symbol">.</a><a id="11333" href="Cat.Diagram.Colimit.Base.html#2661" data-type="Cocone F → C .Ob" class="Field">coapex</a> <a id="11340" class="Symbol">=</a> <a id="11342" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">M.₀</a> <a id="11346" href="Cat.Functor.Kan.html#11201" class="Bound">x</a>
        <a id="11356" href="Cat.Functor.Kan.html#11297" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(α : F =&gt; M F∘ K) (x : D .Ob) →
Cocone (diagram colim F K x)" class="Function">cocone′</a> <a id="11364" class="Symbol">.</a><a id="11365" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a> <a id="11367" href="Cat.Functor.Kan.html#11367" class="Bound">ob</a> <a id="11370" class="Symbol">=</a> <a id="11372" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="11376" class="Symbol">(</a><a id="11377" href="Cat.Functor.Kan.html#11367" class="Bound">ob</a> <a id="11380" class="Symbol">.</a><a id="11381" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a><a id="11384" class="Symbol">)</a> <a id="11386" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">E.∘</a> <a id="11390" href="Cat.Functor.Kan.html#11196" class="Bound">α</a> <a id="11392" class="Symbol">.</a><a id="11393" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="11395" class="Symbol">_</a>
        <a id="11405" href="Cat.Functor.Kan.html#11297" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(α : F =&gt; M F∘ K) (x : D .Ob) →
Cocone (diagram colim F K x)" class="Function">cocone′</a> <a id="11413" class="Symbol">.</a><a id="11414" href="Cat.Diagram.Colimit.Base.html#3115" data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" class="Field">commutes</a> <a id="11423" class="Symbol">{</a><a id="11424" href="Cat.Functor.Kan.html#11424" class="Bound">x</a><a id="11425" class="Symbol">}</a> <a id="11427" class="Symbol">{</a><a id="11428" href="Cat.Functor.Kan.html#11428" class="Bound">y</a><a id="11429" class="Symbol">}</a> <a id="11431" href="Cat.Functor.Kan.html#11431" class="Bound">f</a> <a id="11433" class="Symbol">=</a>
          <a id="11445" class="Symbol">(</a><a id="11446" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="11450" class="Symbol">(</a><a id="11451" href="Cat.Functor.Kan.html#11428" class="Bound">y</a> <a id="11453" class="Symbol">.</a><a id="11454" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a><a id="11457" class="Symbol">)</a> <a id="11459" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">E.∘</a> <a id="11463" href="Cat.Functor.Kan.html#11196" class="Bound">α</a> <a id="11465" class="Symbol">.</a><a id="11466" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="11468" class="Symbol">_)</a> <a id="11471" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">E.∘</a> <a id="11475" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">F.₁</a> <a id="11479" class="Symbol">(</a><a id="11480" href="Cat.Functor.Kan.html#11431" class="Bound">f</a> <a id="11482" class="Symbol">.</a><a id="11483" href="Cat.Instances.Comma.html#2595" data-type="↓Hom F G a b → Hom A (a .x) (x b)" class="Field">↓Hom.α</a><a id="11489" class="Symbol">)</a>      <a id="11496" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="11499" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">E.pullr</a> <a id="11507" class="Symbol">(</a><a id="11508" href="Cat.Functor.Kan.html#11196" class="Bound">α</a> <a id="11510" class="Symbol">.</a><a id="11511" href="Cat.Base.html#13369" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="11522" class="Symbol">_</a> <a id="11524" class="Symbol">_</a> <a id="11526" class="Symbol">_)</a> <a id="11529" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
          <a id="11541" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="11545" class="Symbol">(</a><a id="11546" href="Cat.Functor.Kan.html#11428" class="Bound">y</a> <a id="11548" class="Symbol">.</a><a id="11549" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a><a id="11552" class="Symbol">)</a> <a id="11554" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">E.∘</a> <a id="11558" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="11562" class="Symbol">(</a><a id="11563" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">K.₁</a> <a id="11567" class="Symbol">(</a><a id="11568" href="Cat.Functor.Kan.html#11431" class="Bound">f</a> <a id="11570" class="Symbol">.</a><a id="11571" href="Cat.Instances.Comma.html#2595" data-type="↓Hom F G a b → Hom A (a .x) (x b)" class="Field">↓Hom.α</a><a id="11577" class="Symbol">))</a> <a id="11580" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">E.∘</a> <a id="11584" href="Cat.Functor.Kan.html#11196" class="Bound">α</a> <a id="11586" class="Symbol">.</a><a id="11587" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="11589" class="Symbol">_</a>  <a id="11592" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">≡⟨</a> <a id="11595" href="Cat.Functor.Reasoning.html#1281" data-type="(F : Functor 𝒞 𝒟) (ab≡c : (F ∘ a) b ≡ c) →
(F ∘ F₁ F a) ((F ∘ F₁ F b) f) ≡ (F ∘ F₁ F c) f" class="Function">M.pulll</a> <a id="11603" class="Symbol">(</a><a id="11604" href="Cat.Functor.Kan.html#11431" class="Bound">f</a> <a id="11606" class="Symbol">.</a><a id="11607" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">↓Hom.sq</a> <a id="11615" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="11617" href="Cat.Base.html#3482" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" class="Function">D.idl</a> <a id="11623" class="Symbol">_)</a> <a id="11626" href="1Lab.Path.html#46629" data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" class="Function">⟩</a>
          <a id="11638" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">M.₁</a> <a id="11642" class="Symbol">(</a><a id="11643" href="Cat.Functor.Kan.html#11424" class="Bound">x</a> <a id="11645" class="Symbol">.</a><a id="11646" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a><a id="11649" class="Symbol">)</a> <a id="11651" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">E.∘</a> <a id="11655" href="Cat.Functor.Kan.html#11196" class="Bound">α</a> <a id="11657" class="Symbol">.</a><a id="11658" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="11660" class="Symbol">_</a>                            <a id="11689" href="1Lab.Path.html#46957" data-type="(x : A) → x ≡ x" class="Function Operator">∎</a>

    <a id="11696" href="Cat.Functor.Kan.html#11070" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">lan</a> <a id="11700" class="Symbol">.</a><a id="11701" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a> <a id="11705" class="Symbol">.</a><a id="11706" href="Cat.Base.html#13369" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="11717" href="Cat.Functor.Kan.html#11717" class="Bound">x</a> <a id="11719" href="Cat.Functor.Kan.html#11719" class="Bound">y</a> <a id="11721" href="Cat.Functor.Kan.html#11721" class="Bound">f</a> <a id="11723" class="Symbol">=</a> <a id="11725" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="11729" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a>
        <a id="11739" href="Cat.Functor.Kan.html#6873" class="Bound">colim</a> <a id="11745" class="Symbol">(</a><a id="11746" href="Cat.Functor.Kan.html#8559" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="11754" class="Symbol">(</a><a id="11755" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">K.₀</a> <a id="11759" href="Cat.Functor.Kan.html#11717" class="Bound">x</a><a id="11760" class="Symbol">))</a> <a id="11763" class="Symbol">.</a><a id="11764" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="11769" class="Symbol">(</a><a id="11770" href="Cat.Functor.Kan.html#8636" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">approx</a> <a id="11777" class="Symbol">(</a><a id="11778" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">K.₁</a> <a id="11782" href="Cat.Functor.Kan.html#11721" class="Bound">f</a><a id="11783" class="Symbol">))</a> <a id="11786" class="Symbol">.</a><a id="11787" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="11794" class="Symbol">.</a><a id="11795" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="11804" class="Symbol">_</a>
      <a id="11812" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="11814" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="11818" class="Symbol">(</a><a id="11819" href="Cat.Functor.Kan.html#6873" class="Bound">colim</a> <a id="11825" class="Symbol">(</a><a id="11826" href="Cat.Functor.Kan.html#8559" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="11834" class="Symbol">(</a><a id="11835" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">K.₀</a> <a id="11839" href="Cat.Functor.Kan.html#11719" class="Bound">y</a><a id="11840" class="Symbol">))</a> <a id="11843" class="Symbol">.</a><a id="11844" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="11848" class="Symbol">.</a><a id="11849" href="Cat.Diagram.Colimit.Base.html#3115" data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" class="Field">commutes</a>
            <a id="11870" class="Symbol">(</a><a id="11871" class="Keyword">record</a> <a id="11878" class="Symbol">{</a> <a id="11880" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">sq</a> <a id="11883" class="Symbol">=</a> <a id="11885" href="Cat.Reasoning.html#1207" data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → f ≡ (C ∘ a) f" class="Function">D.introl</a> <a id="11894" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="11899" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="11901" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="11905" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D._∘_</a> <a id="11911" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="11916" class="Symbol">(</a><a id="11917" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="11921" href="Cat.Reasoning.html#789" data-type="(C : Precategory o ℓ) → (C ∘ f) (id C) ≡ (C ∘ id C) f" class="Function">D.id-comm</a><a id="11930" class="Symbol">)</a> <a id="11932" class="Symbol">}))</a>

    <a id="11941" href="Cat.Functor.Kan.html#11070" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">lan</a> <a id="11945" class="Symbol">.</a><a id="11946" href="Cat.Functor.Kan.html#3692" data-type="(r : Lan p F) → F =&gt; M F∘ p → r .Ext =&gt; M" class="Field">σ</a> <a id="11948" class="Symbol">{</a><a id="11949" href="Cat.Functor.Kan.html#11949" class="Bound">M</a><a id="11950" class="Symbol">}</a> <a id="11952" href="Cat.Functor.Kan.html#11952" class="Bound">α</a> <a id="11954" class="Symbol">.</a><a id="11955" href="Cat.Base.html#13369" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="11966" href="Cat.Functor.Kan.html#11966" class="Bound">x</a> <a id="11968" href="Cat.Functor.Kan.html#11968" class="Bound">y</a> <a id="11970" href="Cat.Functor.Kan.html#11970" class="Bound">f</a> <a id="11972" class="Symbol">=</a>
      <a id="11980" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="11983" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a> <a id="11987" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="11989" href="1Lab.HLevel.html#3818" data-type="is-contr A → is-prop A" class="Function">is-contr→is-prop</a> <a id="12006" class="Symbol">(</a><a id="12007" href="Cat.Functor.Kan.html#6873" class="Bound">colim</a> <a id="12013" class="Symbol">(</a><a id="12014" href="Cat.Functor.Kan.html#8559" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="12022" href="Cat.Functor.Kan.html#11966" class="Bound">x</a><a id="12023" class="Symbol">)</a> <a id="12025" class="Symbol">.</a><a id="12026" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="12031" href="Cat.Functor.Kan.html#12381" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(α : F =&gt; M F∘ K) (x y : D .Ob) (f : D .Hom x y) →
Cocone (diagram colim F K x)" class="Function">cocone′</a><a id="12038" class="Symbol">)</a>
        <a id="12048" class="Symbol">(</a><a id="12049" href="Cat.Diagram.Colimit.Base.html#4170" data-type="(hom : C .Hom (x .coapex) (y .coapex))
(commutes : (o : J₁ .Ob) → C ._∘_ hom (x .ψ o) ≡ y .ψ o) →
Cocone-hom F x y" class="InductiveConstructor">cocone-hom</a> <a id="12060" class="Symbol">_</a> <a id="12062" class="Symbol">λ</a> <a id="12064" href="Cat.Functor.Kan.html#12064" class="Bound">o</a> <a id="12066" class="Symbol">→</a> <a id="12068" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">E.pullr</a> <a id="12076" class="Symbol">(</a><a id="12077" href="Cat.Functor.Kan.html#6873" class="Bound">colim</a> <a id="12083" class="Symbol">(</a><a id="12084" href="Cat.Functor.Kan.html#8559" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="12092" href="Cat.Functor.Kan.html#11966" class="Bound">x</a><a id="12093" class="Symbol">)</a> <a id="12095" class="Symbol">.</a><a id="12096" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="12101" class="Symbol">(</a><a id="12102" href="Cat.Functor.Kan.html#8636" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
D .Hom d e → Cocone (F F∘ Dom K (const! d))" class="Function">approx</a> <a id="12109" href="Cat.Functor.Kan.html#11970" class="Bound">f</a><a id="12110" class="Symbol">)</a> <a id="12112" class="Symbol">.</a><a id="12113" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="12120" class="Symbol">.</a><a id="12121" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="12130" class="Symbol">_)</a>
                          <a id="12159" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="12161" href="Cat.Functor.Kan.html#6873" class="Bound">colim</a> <a id="12167" class="Symbol">(</a><a id="12168" href="Cat.Functor.Kan.html#8559" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="12176" href="Cat.Functor.Kan.html#11968" class="Bound">y</a><a id="12177" class="Symbol">)</a> <a id="12179" class="Symbol">.</a><a id="12180" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="12185" class="Symbol">_</a> <a id="12187" class="Symbol">.</a><a id="12188" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="12195" class="Symbol">.</a><a id="12196" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="12205" class="Symbol">_)</a>
        <a id="12216" class="Symbol">(</a><a id="12217" href="Cat.Diagram.Colimit.Base.html#4170" data-type="(hom : C .Hom (x .coapex) (y .coapex))
(commutes : (o : J₁ .Ob) → C ._∘_ hom (x .ψ o) ≡ y .ψ o) →
Cocone-hom F x y" class="InductiveConstructor">cocone-hom</a> <a id="12228" class="Symbol">_</a> <a id="12230" class="Symbol">λ</a> <a id="12232" href="Cat.Functor.Kan.html#12232" class="Bound">o</a> <a id="12234" class="Symbol">→</a> <a id="12236" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">E.pullr</a> <a id="12244" class="Symbol">(</a><a id="12245" href="Cat.Functor.Kan.html#6873" class="Bound">colim</a> <a id="12251" class="Symbol">(</a><a id="12252" href="Cat.Functor.Kan.html#8559" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="12260" href="Cat.Functor.Kan.html#11966" class="Bound">x</a><a id="12261" class="Symbol">)</a> <a id="12263" class="Symbol">.</a><a id="12264" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="12269" class="Symbol">_</a> <a id="12271" class="Symbol">.</a><a id="12272" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="12279" class="Symbol">.</a><a id="12280" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="12289" class="Symbol">_)</a>
                          <a id="12318" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="12320" href="Cat.Functor.Reasoning.html#1281" data-type="(F : Functor 𝒞 𝒟) (ab≡c : (F ∘ a) b ≡ c) →
(F ∘ F₁ F a) ((F ∘ F₁ F b) f) ≡ (F ∘ F₁ F c) f" class="Function">M.pulll</a> <a id="12328" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a><a id="12332" class="Symbol">)</a>
      <a id="12340" class="Keyword">where</a>
        <a id="12354" class="Keyword">module</a> <a id="12361" href="Cat.Functor.Kan.html#12361" class="Module">M</a> <a id="12363" class="Symbol">=</a> <a id="12365" href="Cat.Functor.Reasoning.html" class="Module">Func</a> <a id="12370" href="Cat.Functor.Kan.html#11949" class="Bound">M</a>

        <a id="12381" href="Cat.Functor.Kan.html#12381" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(α : F =&gt; M F∘ K) (x y : D .Ob) (f : D .Hom x y) →
Cocone (diagram colim F K x)" class="Function">cocone′</a> <a id="12389" class="Symbol">:</a> <a id="12391" href="Cat.Diagram.Colimit.Base.html#2300" data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Record">Cocone</a> <a id="12398" class="Symbol">_</a>
        <a id="12408" href="Cat.Functor.Kan.html#12381" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(α : F =&gt; M F∘ K) (x y : D .Ob) (f : D .Hom x y) →
Cocone (diagram colim F K x)" class="Function">cocone′</a> <a id="12416" class="Symbol">.</a><a id="12417" href="Cat.Diagram.Colimit.Base.html#2661" data-type="Cocone F → C .Ob" class="Field">coapex</a> <a id="12424" class="Symbol">=</a> <a id="12426" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">M.₀</a> <a id="12430" href="Cat.Functor.Kan.html#11968" class="Bound">y</a>
        <a id="12440" href="Cat.Functor.Kan.html#12381" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(α : F =&gt; M F∘ K) (x y : D .Ob) (f : D .Hom x y) →
Cocone (diagram colim F K x)" class="Function">cocone′</a> <a id="12448" class="Symbol">.</a><a id="12449" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a> <a id="12451" href="Cat.Functor.Kan.html#12451" class="Bound">x</a> <a id="12453" class="Symbol">=</a> <a id="12455" class="Symbol">_</a>
        <a id="12465" href="Cat.Functor.Kan.html#12381" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(α : F =&gt; M F∘ K) (x y : D .Ob) (f : D .Hom x y) →
Cocone (diagram colim F K x)" class="Function">cocone′</a> <a id="12473" class="Symbol">.</a><a id="12474" href="Cat.Diagram.Colimit.Base.html#3115" data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" class="Field">commutes</a> <a id="12483" class="Symbol">{</a><a id="12484" href="Cat.Functor.Kan.html#12484" class="Bound">x</a><a id="12485" class="Symbol">}</a> <a id="12487" class="Symbol">{</a><a id="12488" href="Cat.Functor.Kan.html#12488" class="Bound">y</a><a id="12489" class="Symbol">}</a> <a id="12491" href="Cat.Functor.Kan.html#12491" class="Bound">f</a> <a id="12493" class="Symbol">=</a>
            <a id="12507" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">E.pullr</a> <a id="12515" class="Symbol">(</a><a id="12516" href="Cat.Functor.Kan.html#11952" class="Bound">α</a> <a id="12518" class="Symbol">.</a><a id="12519" href="Cat.Base.html#13369" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="12530" class="Symbol">_</a> <a id="12532" class="Symbol">_</a> <a id="12534" class="Symbol">_)</a>
          <a id="12547" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="12549" href="Cat.Functor.Reasoning.html#1281" data-type="(F : Functor 𝒞 𝒟) (ab≡c : (F ∘ a) b ≡ c) →
(F ∘ F₁ F a) ((F ∘ F₁ F b) f) ≡ (F ∘ F₁ F c) f" class="Function">M.pulll</a> <a id="12557" class="Symbol">(</a><a id="12558" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">D.pullr</a> <a id="12566" class="Symbol">(</a><a id="12567" href="Cat.Functor.Kan.html#12491" class="Bound">f</a> <a id="12569" class="Symbol">.</a><a id="12570" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">↓Hom.sq</a> <a id="12578" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="12580" href="Cat.Base.html#3482" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" class="Function">D.idl</a> <a id="12586" class="Symbol">_))</a>

    <a id="12595" href="Cat.Functor.Kan.html#11070" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">lan</a> <a id="12599" class="Symbol">.</a><a id="12600" href="Cat.Functor.Kan.html#3748" data-type="(r : Lan p F) → (whiskerl (r .σ α) ∘nt r .eta) ≡ α" class="Field">σ-comm</a> <a id="12607" class="Symbol">{</a><a id="12608" class="Argument">M</a> <a id="12610" class="Symbol">=</a> <a id="12612" href="Cat.Functor.Kan.html#12612" class="Bound">M</a><a id="12613" class="Symbol">}</a> <a id="12615" class="Symbol">=</a>
      <a id="12623" href="Cat.Base.html#15597" data-type="((x : C .Ob) → a .η x ≡ b .η x) → a ≡ b" class="Function">Nat-path</a> <a id="12632" class="Symbol">λ</a> <a id="12634" href="Cat.Functor.Kan.html#12634" class="Bound">x</a> <a id="12636" class="Symbol">→</a> <a id="12638" href="Cat.Functor.Kan.html#6873" class="Bound">colim</a> <a id="12644" class="Symbol">(</a><a id="12645" href="Cat.Functor.Kan.html#8559" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="12653" class="Symbol">(</a><a id="12654" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">K.₀</a> <a id="12658" href="Cat.Functor.Kan.html#12634" class="Bound">x</a><a id="12659" class="Symbol">))</a> <a id="12662" class="Symbol">.</a><a id="12663" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="12668" class="Symbol">_</a>  <a id="12671" class="Symbol">.</a><a id="12672" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="12679" class="Symbol">.</a><a id="12680" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="12689" class="Symbol">_</a> <a id="12691" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="12693" href="Cat.Functor.Reasoning.html#936" data-type="(F : Functor 𝒞 𝒟) (a≡id : a ≡ id F) → (F ∘ F₁ F a) f ≡ f" class="Function">M.eliml</a> <a id="12701" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
      <a id="12712" class="Keyword">where</a> <a id="12718" class="Keyword">module</a> <a id="12725" href="Cat.Functor.Kan.html#12725" class="Module">M</a> <a id="12727" class="Symbol">=</a> <a id="12729" href="Cat.Functor.Reasoning.html" class="Module">Func</a> <a id="12734" href="Cat.Functor.Kan.html#12612" class="Bound">M</a>

    <a id="12741" href="Cat.Functor.Kan.html#11070" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">lan</a> <a id="12745" class="Symbol">.</a><a id="12746" href="Cat.Functor.Kan.html#3827" data-type="(r : Lan p F) → α ≡ (whiskerl σ′ ∘nt r .eta) → r .σ α ≡ σ′" class="Field">σ-uniq</a> <a id="12753" class="Symbol">{</a><a id="12754" class="Argument">M</a> <a id="12756" class="Symbol">=</a> <a id="12758" href="Cat.Functor.Kan.html#12758" class="Bound">M</a><a id="12759" class="Symbol">}</a> <a id="12761" class="Symbol">{</a><a id="12762" href="Cat.Functor.Kan.html#12762" class="Bound">α</a><a id="12763" class="Symbol">}</a> <a id="12765" class="Symbol">{</a><a id="12766" href="Cat.Functor.Kan.html#12766" class="Bound">σ&#39;</a><a id="12768" class="Symbol">}</a> <a id="12770" href="Cat.Functor.Kan.html#12770" class="Bound">path</a> <a id="12775" class="Symbol">=</a> <a id="12777" href="Cat.Base.html#15597" data-type="((x : C .Ob) → a .η x ≡ b .η x) → a ≡ b" class="Function">Nat-path</a> <a id="12786" class="Symbol">λ</a> <a id="12788" href="Cat.Functor.Kan.html#12788" class="Bound">x</a> <a id="12790" class="Symbol">→</a>
      <a id="12798" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="12801" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a> <a id="12805" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="12807" href="Cat.Functor.Kan.html#6873" class="Bound">colim</a> <a id="12813" class="Symbol">(</a><a id="12814" href="Cat.Functor.Kan.html#8559" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="12822" class="Symbol">_)</a> <a id="12825" class="Symbol">.</a><a id="12826" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="12831" class="Symbol">_</a> <a id="12833" class="Symbol">.</a><a id="12834" href="1Lab.HLevel.html#1416" data-type="(r : is-contr A) (x : A) → r .centre ≡ x" class="Field">paths</a>
        <a id="12848" class="Symbol">(</a><a id="12849" href="Cat.Diagram.Colimit.Base.html#4170" data-type="(hom : C .Hom (x .coapex) (y .coapex))
(commutes : (o : J₁ .Ob) → C ._∘_ hom (x .ψ o) ≡ y .ψ o) →
Cocone-hom F x y" class="InductiveConstructor">cocone-hom</a> <a id="12860" class="Symbol">_</a> <a id="12862" class="Symbol">λ</a> <a id="12864" href="Cat.Functor.Kan.html#12864" class="Bound">o</a> <a id="12866" class="Symbol">→</a> <a id="12868" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="12872" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a>
            <a id="12886" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="12890" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">E._∘_</a> <a id="12896" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="12901" class="Symbol">(</a><a id="12902" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="12905" class="Symbol">(λ</a> <a id="12908" href="Cat.Functor.Kan.html#12908" class="Bound">e</a> <a id="12910" class="Symbol">→</a> <a id="12912" href="Cat.Functor.Kan.html#12908" class="Bound">e</a> <a id="12914" class="Symbol">.</a><a id="12915" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="12917" class="Symbol">_)</a> <a id="12920" href="Cat.Functor.Kan.html#12770" class="Bound">path</a><a id="12924" class="Symbol">)</a>
          <a id="12936" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="12938" href="Cat.Reasoning.html#1548" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ a) ((C ∘ b) f) ≡ (C ∘ c) f" class="Function">E.pulll</a> <a id="12946" class="Symbol">(</a><a id="12947" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="12951" class="Symbol">(</a><a id="12952" href="Cat.Functor.Kan.html#12766" class="Bound">σ&#39;</a> <a id="12955" class="Symbol">.</a><a id="12956" href="Cat.Base.html#13369" data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" class="Field">is-natural</a> <a id="12967" class="Symbol">_</a> <a id="12969" class="Symbol">_</a> <a id="12971" class="Symbol">_))</a>
          <a id="12985" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="12987" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">E.pullr</a> <a id="12995" class="Symbol">(</a> <a id="12997" href="Cat.Functor.Kan.html#6873" class="Bound">colim</a> <a id="13003" class="Symbol">_</a> <a id="13005" class="Symbol">.</a><a id="13006" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="13011" class="Symbol">_</a> <a id="13013" class="Symbol">.</a><a id="13014" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="13021" class="Symbol">.</a><a id="13022" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="13031" class="Symbol">_</a>
                    <a id="13053" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="13055" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="13058" class="Symbol">(</a><a id="13059" href="Cat.Functor.Kan.html#6873" class="Bound">colim</a> <a id="13065" class="Symbol">(</a><a id="13066" href="Cat.Functor.Kan.html#8559" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(d : D .Ob) →
Functor (K ↘ d) E" class="Function">diagram</a> <a id="13074" href="Cat.Functor.Kan.html#12788" class="Bound">x</a><a id="13075" class="Symbol">)</a> <a id="13077" class="Symbol">.</a><a id="13078" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="13082" class="Symbol">.</a><a id="13083" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a><a id="13084" class="Symbol">)</a>
                         <a id="13111" class="Symbol">(</a><a id="13112" href="Cat.Instances.Comma.html#3533" data-type="(F : Functor A C) (G : Functor B₁ C) (p : a .x ≡ b .x)
(q : a .y ≡ b .y) →
PathP (λ i → Hom C (F₀ F (p i)) (F₀ G (q i))) (a .map) (b .map) →
a ≡ b" class="Function">↓Obj-path</a> <a id="13122" class="Symbol">_</a> <a id="13124" class="Symbol">_</a> <a id="13126" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="13131" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a> <a id="13136" class="Symbol">(</a><a id="13137" href="Cat.Base.html#3437" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" class="Function">D.idr</a> <a id="13143" class="Symbol">_))))</a>
</pre>
</details>
<p>A useful result about this calculation of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mi>F</mi></msub><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Lan_F(G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Lan</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span></span></span></span> is that, if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> is fully faithful, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mi>F</mi></msub><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>∘</mo><mi>F</mi><mo>≅</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">\Lan_F(G) \circ F \cong G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Lan</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> — the left Kan extension along a fully-faithful functor does actually <em>extend</em>.</p>
<pre class="Agda">  <a id="13380" class="Keyword">private</a> <a id="13388" class="Keyword">module</a> <a id="13395" href="Cat.Functor.Kan.html#13395" class="Module">Fn</a> <a id="13398" class="Symbol">=</a> <a id="13400" href="Cat.Reasoning.html" class="Module">Cat</a> <a id="13404" href="Cat.Instances.Functor.html#2100" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Precategory (o₁ ⊔ o₂ ⊔ h₁ ⊔ h₂) (o₁ ⊔ h₁ ⊔ h₂)" class="Function Operator">Cat[</a> <a id="13409" href="Cat.Functor.Kan.html#6804" class="Bound">C</a> <a id="13411" href="Cat.Instances.Functor.html#2100" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Precategory (o₁ ⊔ o₂ ⊔ h₁ ⊔ h₂) (o₁ ⊔ h₁ ⊔ h₂)" class="Function Operator">,</a> <a id="13413" href="Cat.Functor.Kan.html#6849" class="Bound">E</a> <a id="13415" href="Cat.Instances.Functor.html#2100" data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Precategory (o₁ ⊔ o₂ ⊔ h₁ ⊔ h₂) (o₁ ⊔ h₁ ⊔ h₂)" class="Function Operator">]</a>
  <a id="13419" class="Keyword">open</a> <a id="13424" href="Cat.Base.html#12241" data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" class="Module Operator">_=&gt;_</a>

  <a id="13432" href="Cat.Functor.Kan.html#13432" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
is-fully-faithful K →
(Cat[ C , E ] ≅ (cocomplete→lan colim F K .Ext F∘ K)) F" class="Function">ff-lan-ext</a> <a id="13443" class="Symbol">:</a> <a id="13445" href="Cat.Functor.Base.html#1110" data-type="Functor C D → Type (C.o ⊔ C.h ⊔ D.h)" class="Function">is-fully-faithful</a> <a id="13463" href="Cat.Functor.Kan.html#6925" class="Bound">K</a> <a id="13465" class="Symbol">→</a> <a id="13467" href="Cat.Functor.Kan.html#8501" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">cocomplete→lan</a> <a id="13482" class="Symbol">.</a><a id="13483" href="Cat.Functor.Kan.html#2918" data-type="Lan p F → Functor C′ D" class="Field">Ext</a> <a id="13487" href="Cat.Base.html#9697" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="13490" href="Cat.Functor.Kan.html#6925" class="Bound">K</a> <a id="13492" href="Cat.Morphism.html#2202" data-type="(C : Precategory o h) (a b : Ob C) → Type h" class="Record Operator">Fn.≅</a> <a id="13497" href="Cat.Functor.Kan.html#6905" class="Bound">F</a>

  <a id="13502" href="Cat.Functor.Kan.html#13432" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
is-fully-faithful K →
(Cat[ C , E ] ≅ (cocomplete→lan colim F K .Ext F∘ K)) F" class="Function">ff-lan-ext</a> <a id="13513" href="Cat.Functor.Kan.html#13513" class="Bound">ff</a> <a id="13516" class="Symbol">=</a> <a id="13518" href="Cat.Morphism.html#7747" data-type="(C : Precategory o h) → (C ≅ a) b → (C ≅ b) a" class="Function Operator">Fn._Iso⁻¹</a> <a id="13528" class="Symbol">(</a><a id="13529" href="Cat.Morphism.html#3941" data-type="(C : Precategory o h) (f : Hom C a b) →
is-invertible C f → (C ≅ a) b" class="Function">Fn.invertible→iso</a> <a id="13547" class="Symbol">(</a><a id="13548" href="Cat.Functor.Kan.html#8501" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">cocomplete→lan</a> <a id="13563" class="Symbol">.</a><a id="13564" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a><a id="13567" class="Symbol">)</a> <a id="13569" href="Cat.Functor.Kan.html#14738" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) →
is-invertible Cat[ C , E ] (cocomplete→lan colim F K .eta)" class="Function">inv</a><a id="13572" class="Symbol">)</a> <a id="13574" class="Keyword">where</a>
    <a id="13584" href="Cat.Functor.Kan.html#13584" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
is-fully-faithful K →
(x : C .Ob) → is-invertible E (cocomplete→lan colim F K .eta .η x)" class="Function">inv′</a> <a id="13589" class="Symbol">:</a> <a id="13591" class="Symbol">∀</a> <a id="13593" href="Cat.Functor.Kan.html#13593" class="Bound">x</a> <a id="13595" class="Symbol">→</a> <a id="13597" href="Cat.Morphism.html#1930" data-type="(C : Precategory o h) (f : Hom C a b) → Type h" class="Record">E.is-invertible</a> <a id="13613" class="Symbol">(</a><a id="13614" href="Cat.Functor.Kan.html#8501" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">cocomplete→lan</a> <a id="13629" class="Symbol">.</a><a id="13630" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a> <a id="13634" class="Symbol">.</a><a id="13635" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="13637" href="Cat.Functor.Kan.html#13593" class="Bound">x</a><a id="13638" class="Symbol">)</a>
    <a id="13644" href="Cat.Functor.Kan.html#13584" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
is-fully-faithful K →
(x : C .Ob) → is-invertible E (cocomplete→lan colim F K .eta .η x)" class="Function">inv′</a> <a id="13649" href="Cat.Functor.Kan.html#13649" class="Bound">x</a> <a id="13651" class="Symbol">=</a> <a id="13653" href="Cat.Morphism.html#3457" data-type="(C : Precategory o h) (g : Hom C b a) →
(C ∘ f) g ≡ id C → (C ∘ g) f ≡ id C → is-invertible C f" class="Function">E.make-invertible</a> <a id="13671" href="Cat.Functor.Kan.html#14059" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
E .Hom (colim (diagram colim F K (F₀ K x)) .bot .coapex) (₀ F x)" class="Function">to</a> <a id="13674" href="Cat.Functor.Kan.html#14133" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
E ._∘_ (cocomplete→lan colim F K .eta .η x) (to colim F K ff x) ≡
E .id" class="Function">invl</a> <a id="13679" href="Cat.Functor.Kan.html#14519" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
E ._∘_ (to colim F K ff x) (cocomplete→lan colim F K .eta .η x) ≡
E .id" class="Function">invr</a> <a id="13684" class="Keyword">where</a>
      <a id="13696" href="Cat.Functor.Kan.html#13696" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
Cocone (diagram colim F K (F₀ K x))" class="Function">cocone′</a> <a id="13704" class="Symbol">:</a> <a id="13706" href="Cat.Diagram.Colimit.Base.html#2300" data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" class="Record">Cocone</a> <a id="13713" class="Symbol">_</a>
      <a id="13721" href="Cat.Functor.Kan.html#13696" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
Cocone (diagram colim F K (F₀ K x))" class="Function">cocone′</a> <a id="13729" class="Symbol">.</a><a id="13730" href="Cat.Diagram.Colimit.Base.html#2661" data-type="Cocone F → C .Ob" class="Field">coapex</a> <a id="13737" class="Symbol">=</a> <a id="13739" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">F.₀</a> <a id="13743" href="Cat.Functor.Kan.html#13649" class="Bound">x</a>
      <a id="13751" href="Cat.Functor.Kan.html#13696" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
Cocone (diagram colim F K (F₀ K x))" class="Function">cocone′</a> <a id="13759" class="Symbol">.</a><a id="13760" href="Cat.Diagram.Colimit.Base.html#2681" data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" class="Field">ψ</a> <a id="13762" href="Cat.Functor.Kan.html#13762" class="Bound">ob</a> <a id="13765" class="Symbol">=</a> <a id="13767" href="Cat.Base.html#8808" data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" class="Function">F.₁</a> <a id="13771" class="Symbol">(</a><a id="13772" href="1Lab.Equiv.html#6449" data-type="is-equiv f → B₁ → A" class="Function">equiv→inverse</a> <a id="13786" href="Cat.Functor.Kan.html#13513" class="Bound">ff</a> <a id="13789" class="Symbol">(</a><a id="13790" href="Cat.Functor.Kan.html#13762" class="Bound">ob</a> <a id="13793" class="Symbol">.</a><a id="13794" href="Cat.Instances.Comma.html#1832" data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" class="Field">map</a><a id="13797" class="Symbol">))</a>
      <a id="13806" href="Cat.Functor.Kan.html#13696" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
Cocone (diagram colim F K (F₀ K x))" class="Function">cocone′</a> <a id="13814" class="Symbol">.</a><a id="13815" href="Cat.Diagram.Colimit.Base.html#3115" data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" class="Field">commutes</a> <a id="13824" class="Symbol">{</a><a id="13825" class="Argument">x</a> <a id="13827" class="Symbol">=</a> <a id="13829" href="Cat.Functor.Kan.html#13829" class="Bound">y</a><a id="13830" class="Symbol">}</a> <a id="13832" class="Symbol">{</a><a id="13833" href="Cat.Functor.Kan.html#13833" class="Bound">z</a><a id="13834" class="Symbol">}</a> <a id="13836" href="Cat.Functor.Kan.html#13836" class="Bound">f</a> <a id="13838" class="Symbol">=</a>
        <a id="13848" href="Cat.Functor.Reasoning.html#1206" data-type="(F : Functor 𝒞 𝒟) (ab≡c : (F ∘ a) b ≡ c) →
(F ∘ F₁ F a) (F₁ F b) ≡ F₁ F c" class="Function">F.collapse</a> <a id="13859" class="Symbol">(</a><a id="13860" href="Cat.Functor.Base.html#1212" data-type="is-fully-faithful F → is-faithful F" class="Function">fully-faithful→faithful</a> <a id="13884" class="Symbol">{</a><a id="13885" class="Argument">F</a> <a id="13887" class="Symbol">=</a> <a id="13889" href="Cat.Functor.Kan.html#6925" class="Bound">K</a><a id="13890" class="Symbol">}</a> <a id="13892" href="Cat.Functor.Kan.html#13513" class="Bound">ff</a>
          <a id="13905" class="Symbol">(</a> <a id="13907" href="Cat.Functor.Kan.html#6925" class="Bound">K</a> <a id="13909" class="Symbol">.</a><a id="13910" href="Cat.Base.html#8383" data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" class="Field">Functor.F-∘</a>  <a id="13923" class="Symbol">_</a> <a id="13925" class="Symbol">_</a>
          <a id="13937" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="13939" href="1Lab.Path.html#21189" data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" class="Function">ap₂</a> <a id="13943" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D._∘_</a> <a id="13949" class="Symbol">(</a><a id="13950" href="1Lab.Equiv.html#6548" data-type="(eqv₁ : is-equiv f) → is-right-inverse (equiv→inverse eqv₁) f" class="Function">equiv→section</a> <a id="13964" href="Cat.Functor.Kan.html#13513" class="Bound">ff</a> <a id="13967" class="Symbol">_)</a> <a id="13970" href="1Lab.Path.html#3593" data-type="x ≡ x" class="Function">refl</a>
          <a id="13985" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="13987" href="Cat.Functor.Kan.html#13836" class="Bound">f</a> <a id="13989" class="Symbol">.</a><a id="13990" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">sq</a>
          <a id="14003" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="14005" href="Cat.Base.html#3482" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" class="Function">D.idl</a> <a id="14011" class="Symbol">_</a>
          <a id="14023" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="14025" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="14029" class="Symbol">(</a><a id="14030" href="1Lab.Equiv.html#6548" data-type="(eqv₁ : is-equiv f) → is-right-inverse (equiv→inverse eqv₁) f" class="Function">equiv→section</a> <a id="14044" href="Cat.Functor.Kan.html#13513" class="Bound">ff</a> <a id="14047" class="Symbol">_)))</a>

      <a id="14059" href="Cat.Functor.Kan.html#14059" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
E .Hom (colim (diagram colim F K (F₀ K x)) .bot .coapex) (₀ F x)" class="Function">to</a> <a id="14062" class="Symbol">:</a> <a id="14064" href="Cat.Base.html#1436" data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" class="Function">E.Hom</a> <a id="14070" class="Symbol">_</a> <a id="14072" class="Symbol">(</a><a id="14073" href="Cat.Base.html#8727" data-type="(r : Functor C D) → C .Ob → D .Ob" class="Function">F.₀</a> <a id="14077" href="Cat.Functor.Kan.html#13649" class="Bound">x</a><a id="14078" class="Symbol">)</a>
      <a id="14086" href="Cat.Functor.Kan.html#14059" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
E .Hom (colim (diagram colim F K (F₀ K x)) .bot .coapex) (₀ F x)" class="Function">to</a> <a id="14089" class="Symbol">=</a> <a id="14091" href="Cat.Functor.Kan.html#6873" class="Bound">colim</a> <a id="14097" class="Symbol">_</a> <a id="14099" class="Symbol">.</a><a id="14100" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="14105" href="Cat.Functor.Kan.html#13696" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
Cocone (diagram colim F K (F₀ K x))" class="Function">cocone′</a> <a id="14113" class="Symbol">.</a><a id="14114" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="14121" class="Symbol">.</a><a id="14122" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a>

      <a id="14133" href="Cat.Functor.Kan.html#14133" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
E ._∘_ (cocomplete→lan colim F K .eta .η x) (to colim F K ff x) ≡
E .id" class="Function">invl</a> <a id="14138" class="Symbol">:</a> <a id="14140" href="Cat.Functor.Kan.html#8501" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">cocomplete→lan</a> <a id="14155" class="Symbol">.</a><a id="14156" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a> <a id="14160" class="Symbol">.</a><a id="14161" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="14163" href="Cat.Functor.Kan.html#13649" class="Bound">x</a> <a id="14165" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">E.∘</a> <a id="14169" href="Cat.Functor.Kan.html#14059" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
E .Hom (colim (diagram colim F K (F₀ K x)) .bot .coapex) (₀ F x)" class="Function">to</a> <a id="14172" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="14174" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">E.id</a>
      <a id="14185" href="Cat.Functor.Kan.html#14133" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
E ._∘_ (cocomplete→lan colim F K .eta .η x) (to colim F K ff x) ≡
E .id" class="Function">invl</a> <a id="14190" class="Symbol">=</a> <a id="14192" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="14195" href="Cat.Diagram.Colimit.Base.html#4197" data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" class="Field">hom</a> <a id="14199" href="1Lab.Type.html#2481" data-type="((x : A) → B₁ x) → (x : A) → B₁ x" class="Function Operator">$</a> <a id="14201" href="1Lab.HLevel.html#3818" data-type="is-contr A → is-prop A" class="Function">is-contr→is-prop</a>
        <a id="14226" class="Symbol">(</a><a id="14227" href="Cat.Functor.Kan.html#6873" class="Bound">colim</a> <a id="14233" class="Symbol">_</a> <a id="14235" class="Symbol">.</a><a id="14236" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="14241" class="Symbol">(</a><a id="14242" href="Cat.Functor.Kan.html#6873" class="Bound">colim</a> <a id="14248" class="Symbol">(</a><a id="14249" href="Cat.Functor.Kan.html#6905" class="Bound">F</a> <a id="14251" href="Cat.Base.html#9697" data-type="Functor D E → Functor C D → Functor C E" class="Function Operator">F∘</a> <a id="14254" href="Cat.Instances.Comma.html#5380" data-type="(F : Functor A C) (G : Functor B₁ C) → Functor (F ↓ G) A" class="Function">Dom</a> <a id="14258" href="Cat.Functor.Kan.html#6925" class="Bound">K</a> <a id="14260" class="Symbol">(</a><a id="14261" href="Cat.Instances.Shape.Terminal.html#558" data-type="Ob A → Functor ⊤Cat A" class="Function">const!</a> <a id="14268" class="Symbol">_))</a> <a id="14272" class="Symbol">.</a><a id="14273" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a><a id="14276" class="Symbol">))</a>
        <a id="14287" class="Symbol">(</a><a id="14288" href="Cat.Diagram.Colimit.Base.html#4170" data-type="(hom : C .Hom (x .coapex) (y .coapex))
(commutes : (o : J₁ .Ob) → C ._∘_ hom (x .ψ o) ≡ y .ψ o) →
Cocone-hom F x y" class="InductiveConstructor">cocone-hom</a> <a id="14299" class="Symbol">_</a> <a id="14301" class="Symbol">λ</a> <a id="14303" href="Cat.Functor.Kan.html#14303" class="Bound">o</a> <a id="14305" class="Symbol">→</a>
            <a id="14319" href="Cat.Reasoning.html#1678" data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" class="Function">E.pullr</a> <a id="14327" class="Symbol">(</a><a id="14328" href="Cat.Functor.Kan.html#6873" class="Bound">colim</a> <a id="14334" class="Symbol">_</a> <a id="14336" class="Symbol">.</a><a id="14337" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="14342" href="Cat.Functor.Kan.html#13696" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
Cocone (diagram colim F K (F₀ K x))" class="Function">cocone′</a> <a id="14350" class="Symbol">.</a><a id="14351" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="14358" class="Symbol">.</a><a id="14359" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="14368" class="Symbol">_)</a>
          <a id="14381" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="14383" href="Cat.Functor.Kan.html#6873" class="Bound">colim</a> <a id="14389" class="Symbol">_</a> <a id="14391" class="Symbol">.</a><a id="14392" href="Cat.Diagram.Initial.html#442" data-type="Initial C → Ob C" class="Field">bot</a> <a id="14396" class="Symbol">.</a><a id="14397" href="Cat.Diagram.Colimit.Base.html#3115" data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" class="Field">commutes</a>
              <a id="14420" class="Symbol">(</a><a id="14421" class="Keyword">record</a> <a id="14428" class="Symbol">{</a> <a id="14430" href="Cat.Instances.Comma.html#2646" data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" class="Field">sq</a> <a id="14433" class="Symbol">=</a> <a id="14435" href="1Lab.Path.html#20756" data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" class="Function">ap</a> <a id="14438" class="Symbol">(</a><a id="14439" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">D.id</a> <a id="14444" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">D.∘_</a><a id="14448" class="Symbol">)</a> <a id="14450" class="Symbol">(</a><a id="14451" href="1Lab.Equiv.html#6548" data-type="(eqv₁ : is-equiv f) → is-right-inverse (equiv→inverse eqv₁) f" class="Function">equiv→section</a> <a id="14465" href="Cat.Functor.Kan.html#13513" class="Bound">ff</a> <a id="14468" class="Symbol">_)</a> <a id="14471" class="Symbol">}))</a>
        <a id="14483" class="Symbol">(</a><a id="14484" href="Cat.Diagram.Colimit.Base.html#4170" data-type="(hom : C .Hom (x .coapex) (y .coapex))
(commutes : (o : J₁ .Ob) → C ._∘_ hom (x .ψ o) ≡ y .ψ o) →
Cocone-hom F x y" class="InductiveConstructor">cocone-hom</a> <a id="14495" class="Symbol">_</a> <a id="14497" class="Symbol">λ</a> <a id="14499" href="Cat.Functor.Kan.html#14499" class="Bound">o</a> <a id="14501" class="Symbol">→</a> <a id="14503" href="Cat.Base.html#3482" data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" class="Function">E.idl</a> <a id="14509" class="Symbol">_)</a>

      <a id="14519" href="Cat.Functor.Kan.html#14519" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
E ._∘_ (to colim F K ff x) (cocomplete→lan colim F K .eta .η x) ≡
E .id" class="Function">invr</a> <a id="14524" class="Symbol">:</a> <a id="14526" href="Cat.Functor.Kan.html#14059" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
E .Hom (colim (diagram colim F K (F₀ K x)) .bot .coapex) (₀ F x)" class="Function">to</a> <a id="14529" href="Cat.Base.html#3006" data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" class="Function Operator">E.∘</a> <a id="14533" href="Cat.Functor.Kan.html#8501" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">cocomplete→lan</a> <a id="14548" class="Symbol">.</a><a id="14549" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a> <a id="14553" class="Symbol">.</a><a id="14554" href="Cat.Base.html#12791" data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" class="Field">η</a> <a id="14556" href="Cat.Functor.Kan.html#13649" class="Bound">x</a> <a id="14558" href="Agda.Builtin.Cubical.Path.html#381" data-type="A → A → Type ℓ" class="Function Operator">≡</a> <a id="14560" href="Cat.Base.html#2976" data-type="(r : Precategory o h) → r .Hom x x" class="Function">E.id</a>
      <a id="14571" href="Cat.Functor.Kan.html#14519" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
E ._∘_ (to colim F K ff x) (cocomplete→lan colim F K .eta .η x) ≡
E .id" class="Function">invr</a> <a id="14576" class="Symbol">=</a> <a id="14578" href="Cat.Functor.Kan.html#6873" class="Bound">colim</a> <a id="14584" class="Symbol">_</a> <a id="14586" class="Symbol">.</a><a id="14587" href="Cat.Diagram.Initial.html#456" data-type="(r : Initial C) → is-initial C (r .bot)" class="Field">has⊥</a> <a id="14592" href="Cat.Functor.Kan.html#13696" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) (x : C .Ob) →
Cocone (diagram colim F K (F₀ K x))" class="Function">cocone′</a> <a id="14600" class="Symbol">.</a><a id="14601" href="1Lab.HLevel.html#1401" data-type="is-contr A → A" class="Field">centre</a> <a id="14608" class="Symbol">.</a><a id="14609" href="Cat.Diagram.Colimit.Base.html#4239" data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" class="Field">commutes</a> <a id="14618" class="Symbol">_</a>
           <a id="14631" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="14633" href="Cat.Functor.Reasoning.html#887" data-type="(F : Functor 𝒞 𝒟) (a≡id : a ≡ id F) → F₁ F a ≡ id F" class="Function">F.elim</a> <a id="14640" class="Symbol">(</a><a id="14641" href="Cat.Functor.Base.html#1212" data-type="is-fully-faithful F → is-faithful F" class="Function">fully-faithful→faithful</a> <a id="14665" class="Symbol">{</a><a id="14666" class="Argument">F</a> <a id="14668" class="Symbol">=</a> <a id="14670" href="Cat.Functor.Kan.html#6925" class="Bound">K</a><a id="14671" class="Symbol">}</a> <a id="14673" href="Cat.Functor.Kan.html#13513" class="Bound">ff</a>
                      <a id="14698" class="Symbol">(</a><a id="14699" href="1Lab.Equiv.html#6548" data-type="(eqv₁ : is-equiv f) → is-right-inverse (equiv→inverse eqv₁) f" class="Function">equiv→section</a> <a id="14713" href="Cat.Functor.Kan.html#13513" class="Bound">ff</a> <a id="14716" class="Symbol">_</a> <a id="14718" href="1Lab.Path.html#39472" data-type="x ≡ y → y ≡ z → x ≡ z" class="Function Operator">∙</a> <a id="14720" href="1Lab.Path.html#10558" data-type="x ≡ y → y ≡ x" class="Function">sym</a> <a id="14724" href="Cat.Base.html#8343" data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" class="Field">K.F-id</a><a id="14730" class="Symbol">))</a>

    <a id="14738" href="Cat.Functor.Kan.html#14738" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) →
is-invertible Cat[ C , E ] (cocomplete→lan colim F K .eta)" class="Function">inv</a> <a id="14742" class="Symbol">:</a> <a id="14744" href="Cat.Morphism.html#1930" data-type="(C : Precategory o h) (f : Hom C a b) → Type h" class="Record">Fn.is-invertible</a> <a id="14761" class="Symbol">(</a><a id="14762" href="Cat.Functor.Kan.html#8501" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">cocomplete→lan</a> <a id="14777" class="Symbol">.</a><a id="14778" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a><a id="14781" class="Symbol">)</a>
    <a id="14787" href="Cat.Functor.Kan.html#14738" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D)
(ff : is-fully-faithful K) →
is-invertible Cat[ C , E ] (cocomplete→lan colim F K .eta)" class="Function">inv</a> <a id="14791" class="Symbol">=</a> <a id="14793" href="Cat.Instances.Functor.html#8554" data-type="(eta : F =&gt; G) →
((x : C .Ob) → is-invertible D (eta .η x)) →
is-invertible Cat[ C , D ] eta" class="Function">componentwise-invertible→invertible</a> <a id="14829" class="Symbol">(</a><a id="14830" href="Cat.Functor.Kan.html#8501" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
Lan K F" class="Function">cocomplete→lan</a> <a id="14845" class="Symbol">.</a><a id="14846" href="Cat.Functor.Kan.html#2941" data-type="(r : Lan p F) → F =&gt; r .Ext F∘ p" class="Field">eta</a><a id="14849" class="Symbol">)</a> <a id="14851" href="Cat.Functor.Kan.html#13584" data-type="(colim : is-cocomplete κ κ E) (F : Functor C E) (K : Functor C D) →
is-fully-faithful K →
(x : C .Ob) → is-invertible E (cocomplete→lan colim F K .eta .η x)" class="Function">inv′</a>
</pre>
  </article>
</div>
</main>
</body>
</html>
